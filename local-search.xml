<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>关于小红书的德语作文</title>
    <link href="/2025/04/04/%E5%85%B3%E4%BA%8Exhs%E7%9A%84%E5%BE%B7%E8%AF%AD%E4%BD%9C%E6%96%87/"/>
    <url>/2025/04/04/%E5%85%B3%E4%BA%8Exhs%E7%9A%84%E5%BE%B7%E8%AF%AD%E4%BD%9C%E6%96%87/</url>
    
    <content type="html"><![CDATA[<p>Heutzutag ist die soziale App XHS in Chian sehr beliebt. Ich bin der Meinung, dass dies aus drei folgenden Gründen populär ist.</p><p>Der erste Grund ist, dass die chiesische Bevölkerung, egal junge oder ältere Generation, der mordernen Technik aufgeschlossen gegenüber stehen. Denn ist sie von diesem neuen App begeistert.</p><p>Zweistens entspricht XHS dem starken Verlangen der User, sein Leben zu präsentieren und teilen. Die Form, die aus Bilden und Schriften besteht, stimmt mit ihrem Verlangen überin. Einerseits wird das geteilte Glück doppelt, wenn die User den schönen Moment teilen. Andererseits besteht das Leben nicht nur aus Schokoladenseiten. Per XHS kann die User ihre Sorgen und Problemen aussagen. Auf diese Weise bekommen sie einige gute Vorschläge dazu. Das sorgt dafür, dass die geteilten Sorgen entlastet werden.</p><p>Nicht zuletzt ist, dass XHS mit einem mächtigen Algorithmus ausgestattet ist, damit sie sich von anderen sozialen Medien unterscheidet.  Nur die Inhalte, die dem GEschmack des Lesers entsprechend, werden empfohlen.</p>]]></content>
    
    
    <categories>
      
      <category>德语</category>
      
    </categories>
    
    
    <tags>
      
      <tag>德语</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>利用前缀和处理a-b问题时的一个易错点</title>
    <link href="/2025/03/17/2025-03-17-%E5%88%A9%E7%94%A8%E5%89%8D%E7%BC%80%E5%92%8C%E5%A4%84%E7%90%86a-b%E9%97%AE%E9%A2%98%E6%97%B6%E7%9A%84%E4%B8%80%E4%B8%AA%E6%98%93%E9%94%99%E7%82%B9/"/>
    <url>/2025/03/17/2025-03-17-%E5%88%A9%E7%94%A8%E5%89%8D%E7%BC%80%E5%92%8C%E5%A4%84%E7%90%86a-b%E9%97%AE%E9%A2%98%E6%97%B6%E7%9A%84%E4%B8%80%E4%B8%AA%E6%98%93%E9%94%99%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<blockquote><h1>题目</h1><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你统计并返回 <em>该数组中和为 <code>k</code> 的子数组的个数</em> 。</p><p>子数组是数组中元素的连续非空序列。</p><p><strong>示例 1：</strong></p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs md">输入：nums = [1,1,1], k = 2<br>输出：2<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs md">输入：nums = [1,2,3], k = 3<br>输出：2<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 2 * 104</code></li><li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li><li><code>-107 &lt;= k &lt;= 107</code></li></ul></blockquote><h1>题解</h1><p>我们很容易可以想到使用一个前缀和数组<code>presum[]</code>处理，然后将区间内连续子列的和转化为前缀和的差，于是就转化为了A-B问题<a href="https://kiriaotj.github.io/2025/03/04/2025-03-04-%E2%80%9CA-B%E2%80%9D%E9%97%AE%E9%A2%98%E7%9A%84%E4%BA%8C%E5%88%86%E3%80%81%E5%93%88%E5%B8%8C%E3%80%81%E5%8F%8C%E6%8C%87%E9%92%88%E5%86%99%E6%B3%95/">“A-B”问题的二分、哈希、双指针写法</a> ，利用哈希法解决。</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">subarraySum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n=nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">presum</span><span class="hljs-params">(n<span class="hljs-number">+1</span>,<span class="hljs-number">0</span>)</span></span>;<br>        presum[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>        unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; mp;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            presum[i]=presum[i<span class="hljs-number">-1</span>]+nums[i<span class="hljs-number">-1</span>];<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x:presum)&#123;<br>            mp[x]++;<br>        &#125;<br>        <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x:presum)&#123;<br>            ans+=mp[x-k];<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>但是这里会遇到一个问题！当nums={1}, k=0时，会错误返回2。这是因为：将所有的前缀和一次性存入哈希表，包括当前处理的前缀和<code>sum</code>本身，这样会导致当sum -k等于sum时（比如k=0），会统计到自身，从而产生错误的计数。例如，当sum=0时，在第一次遍历presum数组时，哈希表中已经有了这个sum=0，当处理到它时，x-k=0，这时候会统计到至少一次，即使这个sum对应的位置可能没有更早的前缀和。</p><p>对代码进行修正：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">subarraySum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> pre=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>        unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; cnt;<br>        cnt[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>; <span class="hljs-comment">//！！初始化前缀和为0的次数为1</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x:nums)&#123;<br>            pre+=x;<br>            ans+=cnt[pre-k];<br>            cnt[pre]++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>重点是<strong>避免自匹配</strong>：在计算<code>ans+=cnt[pre-k]</code>时，哈希表中仅包含遍历到当前元素<strong>之前</strong>的前缀和，确保不会将当前前缀和自身计入结果。</p>]]></content>
    
    
    <categories>
      
      <category>程设</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最长连续序列：hash与并查集写法</title>
    <link href="/2025/03/15/%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97%EF%BC%9Ahash%E4%B8%8E%E5%B9%B6%E6%9F%A5%E9%9B%86%E8%A7%A3%E6%B3%95/"/>
    <url>/2025/03/15/%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97%EF%BC%9Ahash%E4%B8%8E%E5%B9%B6%E6%9F%A5%E9%9B%86%E8%A7%A3%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<blockquote><h1>题目</h1><p>给定一个未排序的整数数组 <code>nums</code> ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p><p>设计并实现时间复杂度为 <code>O(n)</code> 的算法解决此问题。</p><h1>样例</h1><p>输入：nums = [100,4,200,1,3,2]<br>输出：4<br>解释：最长数字连续序列是[1, 2, 3, 4]。它的长度为4。</p></blockquote><h1>题解</h1><p>题目要求时间复杂度为$O(n)$，那么肯定不能排序，因为排序起码有$O(nlogn)$的复杂度。</p><p>下面我们通过两个角度来解决这道题：</p><h2 id="1-哈希">1.哈希</h2><p>我们先分析一个显然的暴力解法：先把所有数存到一个哈希集合中，然后双重循环遍历，判断其是否匹配。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestConsecutive</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    unordered_set&lt;<span class="hljs-type">int</span>&gt; s;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x:nums) s.<span class="hljs-built_in">insert</span>(x);<br>    <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x:s)&#123;<br>        <span class="hljs-type">int</span> l=<span class="hljs-number">1</span>; <span class="hljs-comment">//表示当前序列长度</span><br>        <span class="hljs-type">int</span> n=x<span class="hljs-number">+1</span>; <span class="hljs-comment">//表示当前的数</span><br>        <span class="hljs-keyword">while</span>(s.<span class="hljs-built_in">find</span>(n)!=s.<span class="hljs-built_in">end</span>())&#123;<br>            l++;<br>            n++;<br>        &#125;<br>        ans=<span class="hljs-built_in">max</span>(ans,l);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是这样的时间复杂度太高，我们仔细分析可以发现原因是外层循环做了很多不必要的枚举。我们可以这样进行优化：<strong>每次都判断这个数x的前驱x-1存不存在</strong>，如果存在那么我们接下来枚举的肯定不是最长的序列，所以我们每次都需要枚举不存在前驱的数即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestConsecutive</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        unordered_set&lt;<span class="hljs-type">int</span>&gt; s;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x:nums) s.<span class="hljs-built_in">insert</span>(x);<br>        <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x:s)&#123;<br>            <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">find</span>(x<span class="hljs-number">-1</span>)==s.<span class="hljs-built_in">end</span>())&#123;<br>                <span class="hljs-type">int</span> l=<span class="hljs-number">1</span>;<br>                <span class="hljs-type">int</span> n=x<span class="hljs-number">+1</span>;<br>                <span class="hljs-keyword">while</span>(s.<span class="hljs-built_in">find</span>(n)!=s.<span class="hljs-built_in">end</span>())&#123;<br>                    l++;<br>                    n++;<br>                &#125;<br>                ans=<span class="hljs-built_in">max</span>(ans,l);<br>            &#125;<br>            <br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="2-并查集">2.并查集</h2><p>将连续的数字作为一个集合。那么扫描到一个数字，只要将它和它的下一个数字（假如存在）Union在一个集合即可。同时更新这个集合的元素个数。同时更新当前最长记录。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; father;<br>    unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; cnt;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findFather</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (x == father[x]) <span class="hljs-keyword">return</span> x;<br>        <span class="hljs-keyword">return</span> father[x] = <span class="hljs-built_in">findFather</span>(father[x]);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Union</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>        <span class="hljs-type">int</span> fx = <span class="hljs-built_in">findFather</span>(x);<br>        <span class="hljs-type">int</span> fy = <span class="hljs-built_in">findFather</span>(y);<br>        <span class="hljs-keyword">if</span> (fx != fy) &#123;<br>            father[fx]=fy;<br>            cnt[fy]+=cnt[fx];<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestConsecutive</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x:nums)&#123;<br>            father[x]=x;<br>            cnt[x]=<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x:nums)&#123;<br>            <span class="hljs-keyword">if</span>(father.<span class="hljs-built_in">find</span>(x<span class="hljs-number">+1</span>)!=father.<span class="hljs-built_in">end</span>())&#123;<br>                <span class="hljs-built_in">Union</span>(x,x<span class="hljs-number">+1</span>);<br>                ans=<span class="hljs-built_in">max</span>(ans,cnt[<span class="hljs-built_in">findFather</span>(x)]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这里用了一个<code>cnt</code>来记录集合元素数，因为如果最后再计算时间复杂度会超出。</p>]]></content>
    
    
    <categories>
      
      <category>程设</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>电工电子实习 PCB板设计的一些要点</title>
    <link href="/2025/03/07/2025-03-05-%E7%94%B5%E5%B7%A5%E7%94%B5%E5%AD%90%E5%AE%9E%E4%B9%A0-PCB%E6%9D%BF%E8%AE%BE%E8%AE%A1%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A6%81%E7%82%B9/"/>
    <url>/2025/03/07/2025-03-05-%E7%94%B5%E5%B7%A5%E7%94%B5%E5%AD%90%E5%AE%9E%E4%B9%A0-PCB%E6%9D%BF%E8%AE%BE%E8%AE%A1%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A6%81%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h1>PCB 设计原则</h1><p>最好手动布线，自动布线分数更低</p><p>单位：1mil=0.0245mm</p><p>设计规则$\rarr$最小线宽：</p><table><thead><tr><th>类型</th><th>宽度</th></tr></thead><tbody><tr><td>一般</td><td>15mil</td></tr><tr><td>VCC</td><td>30mil</td></tr><tr><td>GND</td><td>30mil</td></tr></tbody></table><p>布线：最好不用使用锐角，有天线效应，最好走成钝角</p><p>布线可以在板的顶底两面，可以交叉。</p><p>走线技巧：</p><ul><li>附近器件比较多，可以一条线一半走顶一半走底，打个过孔就可以切换</li><li>贴片焊盘：贯穿，不能上下走线</li></ul><p>设计规则$\rarr$最小间距：20mil</p><p>但是在单走某根线的时候，可以暂时修改一下最小间距，使之更小。</p><p>可以查找过孔，使得所有过孔都高亮显示，然后修改其属性。</p><p>过孔：</p><ul><li><p>外径30mil，0.8mm</p></li><li><p>内径15mil，0.4mm</p></li></ul><p>Type-C的口，分清哪一头是对外，哪一头是对内，有两个横引脚是对内的。且稍微放出板的边界，<strong>切勿</strong>全放入板内，最好是边界与板的边界齐平且略突出。</p><p>编号、阻值最好靠近电阻，要保证能看到标号。</p><p>插入图片：底层丝印层</p><p>三极管的间距DRC报错不算错，自己判断</p><p>贴片电阻、二极管放得稍微开一点，因为在焊接的时候太近容易短路</p><p><strong>保证原理图要所有地方都能被点亮！</strong></p><p>电阻一定要<strong>标注阻值</strong>，方便焊接；电容也要标</p><p>LED灯不能和芯片垒在一起</p><p>芯片的封装也要做出相应的修改</p><p>全部设计完之后 设计-&gt;进行DRC检查</p><p>线宽设置为0.5，其余保持默认不变。只要DRC错误是0就可以</p><p>泪滴处理：焊盘和金属线条牢靠的在一起。直接采用默认值即可。依次检查每一个焊盘</p><p>稳定信号：铺铜管理器，PCB管理器中的铺铜，铺的是GND；顶层和底层分别铺铜；只要把PCB板包含进去即可；要在侧边栏设置中让铺铜区不可见；之后再进行一次DRC检查</p>]]></content>
    
    
    <categories>
      
      <category>电工电子实习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>电工电子式子</tag>
      
      <tag>嘉立创</tag>
      
      <tag>PCB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>“化学与工程材料学”第二章：材料的晶体结构 笔记</title>
    <link href="/2025/03/05/2025-03-05-%E2%80%9C%E5%8C%96%E5%AD%A6%E4%B8%8E%E5%B7%A5%E7%A8%8B%E6%9D%90%E6%96%99%E5%AD%A6%E2%80%9D%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E6%9D%90%E6%96%99%E7%9A%84%E6%99%B6%E4%BD%93%E7%BB%93%E6%9E%84-%E7%AC%94%E8%AE%B0/"/>
    <url>/2025/03/05/2025-03-05-%E2%80%9C%E5%8C%96%E5%AD%A6%E4%B8%8E%E5%B7%A5%E7%A8%8B%E6%9D%90%E6%96%99%E5%AD%A6%E2%80%9D%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E6%9D%90%E6%96%99%E7%9A%84%E6%99%B6%E4%BD%93%E7%BB%93%E6%9E%84-%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1>2 材料的晶体结构</h1>]]></content>
    
    
    <categories>
      
      <category>课程笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>化工材</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>“化学与工程材料学”第一章：材料的原子结合方式及性能 笔记</title>
    <link href="/2025/03/05/%E5%8C%96%E5%AD%A6%E4%B8%8E%E5%B7%A5%E7%A8%8B%E6%9D%90%E6%96%99%E5%AD%A6%E7%AC%AC%E4%B8%80%E7%AB%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2025/03/05/%E5%8C%96%E5%AD%A6%E4%B8%8E%E5%B7%A5%E7%A8%8B%E6%9D%90%E6%96%99%E5%AD%A6%E7%AC%AC%E4%B8%80%E7%AB%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1>1 材料的原子结合方式及性能</h1><h2 id="1-1-材料的结合方式与结合键">1.1 材料的结合方式与结合键</h2><h3 id="1-1-1-晶体与非晶体">1.1.1 晶体与非晶体</h3><p><strong>晶体</strong>：原子、分子或离子在三维空间有规则地周期性重复排列所构成的固体。其质点在空间的排序称为“长程有序”。</p><p><strong>晶体特点</strong>：结构有序；物理性质各向异性；有固定熔点；在一定条件下有规则的几何外形。</p><p><strong>非晶体</strong>：原子、分子或离子无规则堆积在一起形成的一种无序的聚集状态。</p><p><strong>非晶体结构特征</strong>：结构无序（长程无序、短程有序）；物理性质各向同性；无固定熔点；热导率和膨胀系数小；塑性变形大；组成非晶体的化学成分变化范围大。</p><h3 id="1-1-2-结合力与结合能">1.1.2 结合力与结合能</h3><h3 id="1-1-3-材料的结合键">1.1.3 材料的结合键</h3><h2 id="1-2-静载荷下材料的力学性能">1.2 静载荷下材料的力学性能</h2><p><strong>载荷</strong>：材料在加工及使用过程中所受的外力称为载荷</p><p>根据性质不同可以分为</p><ol><li>静载荷：不随时间变化的恒定载荷或加载缓慢的准静载荷</li><li>冲击载荷：短时间内快速变化的载荷</li><li>疲劳载荷：随时间做周期性或非周期性变化的动载荷（又称循环载荷）</li></ol><p>根据作用不同方式可分为</p><ol><li>拉伸载荷</li><li>压缩载荷</li><li>弯曲载荷</li><li>剪切载荷</li><li>扭转载荷</li></ol><p><strong>变形</strong>：材料受不同载荷作用而发生的几何形状和尺寸的变化称为变形。</p><p>一般可以分为</p><ol><li><strong>弹性变形</strong>：（<strong>弹性</strong>：材料在外力作用下产生变形，当外力取消后，材料变形即可消失并能完全恢复原来状态的性质），这种可恢复的变形称之为弹性变形。最重要的特征是其可逆性。</li><li><strong>塑性变形</strong>：不可逆的。</li></ol><p><strong>内力</strong>：材料受外力作用后，在材料内部作用着的与外力相抗衡的力。</p><p><strong>应力</strong>：单位截面积上的内力。</p><p>材料受拉伸载荷或者压缩载荷作用时，有计算公式：<br>$$<br>R=\frac{F}{S} \<br>F为外力，S为横截面积，R为应力，单位是Pa<br>$$</p><h3 id="1-2-1-强度、刚度和塑性">1.2.1 强度、刚度和塑性</h3><h4 id="1-强度">1.强度</h4><p><strong>强度</strong>：材料抵抗外力而不失效的能力。强度大小通常用应力来表示。</p><p>根据载荷作用方式不同，强度可分为：</p><ol><li>抗拉强度 $R_m$</li><li>抗压强度 $R_{me}$</li><li>抗弯强度 $R_{bb}$</li><li>抗剪强度 $\tau_b$</li><li>抗扭强度 $\tau_m$</li></ol><p>一般情况下多以<strong>抗拉强度</strong>作为判别材料强度高低的指标。</p><p>抗拉强度是通过<strong>拉伸试验</strong>测定的。拉伸试验的方法是用静拉力对标准试样进行轴向拉伸，同时连续测量力和相应的伸长，直至断裂。</p><h5 id="1-拉伸试样">1.拉伸试样</h5><p>形状一般有圆形和矩形两类。国家标准对尺寸和形状均有明确的规定。</p><ol><li>长试样 $L_0=11.3 \sqrt{S_0}$</li><li>短试样 $L_0=5.65 \sqrt{S_0}$</li></ol><p>$S_0$代表试样中间平行长度的横截面积。</p><h5 id="2-力伸长曲线">2.力伸长曲线</h5><p>会分别经历4个阶段：</p><ol><li>弹性变形阶段：试样的变形量$\propto$外加载荷量。载荷卸载试样恢复到原来的形状和尺寸。</li><li>屈服阶段：载荷超过$F_e$后，若卸载，试样的伸长只能部分回复，保留一部分残存变形（也就是塑性变形）。这个时候会产生<strong>屈服</strong>现象：在载荷不增加或略有减小的情况下，试样继续发生变形的现象。这个时候图上锯齿状达到的$F$的最大值称为屈服载荷。屈服后材料将产生较大的塑性变形。</li><li>强化阶段：在屈服阶段后如果还想要让试样继续伸长就必须加载。这个时候是一个非线性函数。随着塑性变形的增大，试样变形抗力也在逐渐增加，这种现象称为<strong>形变强化</strong>或<strong>加工硬化</strong>。</li><li>缩颈阶段（局部塑性变形阶段）：当载荷达到最大值时，试样的直径收缩，称为<strong>收颈</strong>。试样变形所需的载荷也不断降低，这时伸长集中于缩径部位直到断裂。</li></ol><p><em>但是工程上使用的材料多没有明显的屈服现象，而对于低塑性材料既没有屈服现象也不产生缩径。</em></p><h5 id="3-强度指标">3.强度指标</h5><h6 id="1-屈服强度">1.屈服强度</h6><p>分为<strong>上屈服强度</strong>和<strong>下屈服强度</strong>。上屈服强度是指试样发生屈服而力首次下降前的最大应力。下屈服强度是在屈服期间不计瞬时效应时的最小应力。<br>$$<br>R_{eH(L)}=\frac{F_{eH(L)}}{S_0} \<br>其中R_{eH(L)}为上（下）屈服强度，S_0为试样原始横截面积<br>$$</p><h6 id="2-抗拉强度">2.抗拉强度</h6><p><strong>抗拉强度</strong>：材料在拉断前（在拉伸载荷下的）所能承受的最大应力称为抗拉强度，用$R_m$表示。用下式计算：<br>$$<br>R_m=\frac{F_m}{S_0} \<br>式中F_m是试样承受的最大试验力<br>$$</p><h4 id="2-刚度">2.刚度</h4><p><strong>刚度</strong>：材料或结构在受力时抵抗弹性变形的能力，是材料或结构弹性变形难易程度的表征。材料的刚度通常用弹性模量E来衡量。</p><p>在宏观弹性范围内，位移=刚度*零件荷载，即刚度是零件荷载与位移成正比的比例系数，即引起单位位移所需要的力（<strong>弹簧的弹性系数就是刚度</strong>）。他的倒数称为<strong>柔度</strong>，即单位力引起的位移。</p><p>刚度可分两种：</p><p><strong>静刚度</strong>：静载荷下抵抗变形的能力；<strong>动刚度</strong>：动载荷下抵抗变形的能力。即引起单位振幅所需要的动态力。</p><p>考虑干扰频率与结构的固有频率的关系（共振）。</p><p>影响刚度的因素是材料的弹性模量和结构形式。在质量不变的情况下，刚度大则固有频率高。</p><p>刚度针对一般构件或结构而言，它的大小和材料本身的性质、构件或结构的截面与形状有关。</p><p>而强度只是针对一般材料而言，它的大小与材料本身的性质及受力形式有关，与材料的形状无关。</p><h4 id="3-塑性">3.塑性</h4><p><strong>塑性</strong>：断裂前材料在外力作用下变形而不断裂的能力。也是通过拉伸试验测得的，常用的塑性指标是<strong>断后伸长率</strong>和<strong>断面收缩率</strong>。</p><p><strong>伸长率</strong>：试样拉断后，标距的伸长与原始标距的百分比。<br>$$<br>A=\frac{L_u-L_0}{L_0} \times 100% \<br>式中A为伸长率，L_u是试样拉断后的标距，L_0为试样的原始标距<br>$$<br><strong>断面收缩率</strong>：试样拉断后，缩径处截面积的最大增减量与原始横截面积的百分比。<br>$$<br>Z=\frac{S_0-S_u}{S_0} \times 100 %<br>$$<br>A与Z越大，代表材料的塑性越好。</p><h3 id="1-2-2-硬度">1.2.2 硬度</h3><p><strong>硬度</strong>：材料抵抗局部变形（特别是塑性变形）、压痕或划痕的能力。</p><p>比较重要的是这三种方法各自的适用范围以及优点。</p><h4 id="1-布氏硬度">1.布氏硬度</h4><p><strong>优点</strong>：精度高，重复性好；</p><p><strong>缺点</strong>：不宜测定太厚、太硬的材料。</p><h4 id="2-洛氏硬度">2.洛氏硬度</h4><p><strong>优点</strong>：操作简单、迅速，可测定软硬不同、厚度不一的试样，可在成品上测试；</p><p><strong>缺点</strong>：精度差，数据重复性差。</p><h4 id="3-维氏硬度">3.维氏硬度</h4><p><strong>优点</strong>：精确度高，测量的硬度范围宽，特别适用于测定工件表面硬化层、金属镀层及薄片金属的硬度；</p><p><strong>缺点</strong>：测试手续复杂。</p><h2 id="1-3-动载荷下材料的力学性能">1.3 动载荷下材料的力学性能</h2><p><strong>韧性</strong>：材料断裂时所需能量的量度。</p><h3 id="1-3-1-冲击韧性">1.3.1 冲击韧性</h3><p><strong>冲击韧度</strong>：材料抵抗冲击载荷作用而不破坏的能力。</p><h4 id="1-冲击试样">1.冲击试样</h4><p>遵循国标</p><h4 id="2-冲击试验的原理及方法">2.冲击试验的原理及方法</h4><p>利用能量守恒原理，试样被冲断的过程中吸收的能量等于摆锤冲击试样前后的势能差。<br>$$<br>A_k=GH_1-GH_2 \<br>其中A_k为重力吸收功<br>$$<br>定义材料的冲击韧度为<br>$$<br>a_k=\frac{A_k}{S_0} \其中S_0为试样缺口处截面积<br>$$<br><strong>注意</strong>：使用不同类型的试样（U形缺口或者V形缺口）进行试验的时候，角标依次改成$A_{kU} \ A_{kV}$等，别的同理。</p><h4 id="3-小能量多次冲击试验">3.小能量多次冲击试验</h4><p>实践表明，承受冲击载荷的机械零件，很少遭到一次大能量冲击而被破坏，大部分情况是因为一次冲击不足以使零件破坏的小能量多次冲击作用下而破坏的。对于这样的零件使用冲击韧度来设计是不现实的。</p><p>实验表明在小能量多次冲击条件下，其冲击抗力主要取决于材料的强度和塑性。</p><h3 id="1-3-2-疲劳强度">1.3.2 疲劳强度</h3><p><strong>交变应力（循环应力）</strong>：轴、齿轮、轴承、叶片、弹簧等零件，在工作过程中各点的应力随时间作周期性的变化，这种随时间作周期性变化的应力。</p><p><strong>疲劳</strong>：材料在交变应力作用下产生裂纹或发生断裂的现象。</p><p><strong>疲劳曲线</strong>：交变应力与循环次数的关系曲线。</p><p>材料承受的最大交变应力<strong>越大</strong>，则断裂时应力循环次数N<strong>越小</strong>。</p><p><strong>疲劳强度（$\sigma_{-1}$）</strong>：材料在规定次数（钢铁：$10^7$，有色金属及合金：$10^8$次）的交变载荷作用下，而不至于引起断裂的最大应力。</p><p>一定是在<strong>远低于抗拉强度的条件下</strong>发生断裂，原因是<strong>内部有缺陷</strong>。</p><p><strong>疲劳断裂的原因</strong>：材料表面与内部缺陷。</p><p><strong>提高途径</strong>：合理选材；改善零件结构形状；降低零件表面粗糙度；表面强化处理；提高材料抗拉强度。</p><h3 id="1-3-3-断裂韧度">1.3.3 断裂韧度</h3><p><strong>断裂韧度</strong>：材料因抵抗裂纹失稳扩展断裂的能力。</p><p><strong>应力强度因子</strong>：$K_I=Y\sigma a^{\frac{1}{2}}$，裂纹前端附近应力场的强弱主要取决于这个力学参数。</p><p>式中$Y$为裂纹形状、加载方法及试样尺寸有关的量，无量纲；$\sigma$为外加拉应力；$a$为裂纹长度的一半。</p><h2 id="1-4-材料的物理、化学及工艺性能">1.4 材料的物理、化学及工艺性能</h2><h3 id="1-4-1-材料的物理性能">1.4.1 材料的物理性能</h3><h4 id="1-密度">1.密度</h4><p>比强度$\frac{R_m}{ρ}$，其中$R_m$为强度</p><p>比弹性模量$\frac{E}{ρ}$</p><h4 id="2-熔点">2.熔点</h4><h4 id="3-导热性">3.导热性</h4><h4 id="4-热膨胀性">4.热膨胀性</h4><p>取决于结合键的强度。</p><p>陶瓷的热胀系数最低，金属次之，高分子材料的线胀系数最高。</p><h4 id="5-导热性">5.导热性</h4><h4 id="6-磁性">6.磁性</h4><h3 id="1-4-2-材料的化学性能">1.4.2 材料的化学性能</h3><h4 id="1-耐腐蚀性">1.耐腐蚀性</h4><h4 id="2-抗氧化性">2.抗氧化性</h4><h4 id="3-化学稳定性">3.化学稳定性</h4><h3 id="1-4-3-材料的工艺性能">1.4.3 材料的工艺性能</h3><h4 id="1-铸造性能">1.铸造性能</h4><h4 id="2-锻造性能">2.锻造性能</h4><h4 id="3-焊接性能">3.焊接性能</h4><p>钢材含碳量越高，焊接性能越差。</p><h4 id="4-切削加工性能">4.切削加工性能</h4><h4 id="5-热处理工艺性能">5.热处理工艺性能</h4>]]></content>
    
    
    <categories>
      
      <category>课程笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>化工材</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>“A-B”问题的二分、哈希、双指针写法</title>
    <link href="/2025/03/04/2025-03-04-%E2%80%9CA-B%E2%80%9D%E9%97%AE%E9%A2%98%E7%9A%84%E4%BA%8C%E5%88%86%E3%80%81%E5%93%88%E5%B8%8C%E3%80%81%E5%8F%8C%E6%8C%87%E9%92%88%E5%86%99%E6%B3%95/"/>
    <url>/2025/03/04/2025-03-04-%E2%80%9CA-B%E2%80%9D%E9%97%AE%E9%A2%98%E7%9A%84%E4%BA%8C%E5%88%86%E3%80%81%E5%93%88%E5%B8%8C%E3%80%81%E5%8F%8C%E6%8C%87%E9%92%88%E5%86%99%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<blockquote><h2 id="题目描述">题目描述</h2><p>给出一串正整数数列以及一个正整数 $C$，要求计算出所有满足 $A - B = C$ 的数对的个数（不同位置的数字一样的数对算不同的数对）。</p><h2 id="输入格式">输入格式</h2><p>输入共两行。</p><p>第一行，两个正整数 $N,C$。</p><p>第二行，$N$ 个正整数，作为要求处理的那串数。</p><h2 id="输出格式">输出格式</h2><p>一行，表示该串正整数中包含的满足 $A - B = C$ 的数对的个数。</p><h2 id="输入输出样例-1">输入输出样例 #1</h2><h3 id="输入-1">输入 #1</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">1</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h3 id="输出-1">输出 #1</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">3<br></code></pre></td></tr></table></figure><h2 id="说明-提示">说明/提示</h2><p>对于 $75%$ 的数据，$1 \leq N \leq 2000$。</p><p>对于 $100%$ 的数据，$1 \leq N \leq 2 \times 10^5$，$0 \leq a_i &lt;2^{30}$，$1 \leq C &lt; 2^{30}$。</p></blockquote><h1>题解</h1><h2 id="二分写法">二分写法</h2><p>考虑原问题是要求满足$a_i-a_j=C$的二元组个数，如果我们考虑去枚举$a_i$，那么我们只需要在原序列中找到值为$a_j=a_i-C$的个数即可。</p><p>对于一个有序的数组，满足相等值的部分必然构成一段连续的序列，那么我们可以考虑<code>lower_bound()</code>和<code>upper_bound</code>函数，可以快速找到这个连续端的左端点和右端点，也就是$a_i-C$在序列中第一次出现和最后一次出现（的后一个）的位置，把这段区间长度加上即可。</p><p>由于<code>lower_bound()-a.begin()</code>和<code>upper_bound()-a.begin()</code>是各自所求的下标，将其相减就是区间的长度。</p><p>代码实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">using</span> i64=<span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> u64=<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> u32=<span class="hljs-type">unsigned</span>;<br><span class="hljs-keyword">using</span> u128=<span class="hljs-type">unsigned</span> __int128;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-type">int</span> n,c;<br>    cin&gt;&gt;n&gt;&gt;c;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        cin&gt;&gt;a[i];<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>(),a.<span class="hljs-built_in">end</span>());<br>    i64 ans=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x:a)&#123;<br>        ans+=<span class="hljs-built_in">upper_bound</span>(a.<span class="hljs-built_in">begin</span>(),a.<span class="hljs-built_in">end</span>(),x-c)-<span class="hljs-built_in">lower_bound</span>(a.<span class="hljs-built_in">begin</span>(),a.<span class="hljs-built_in">end</span>(),x-c);<br>    &#125;<br>    cout&lt;&lt;ans;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度$O(nlogn)$</p><h2 id="哈希写法">哈希写法</h2><p>和上面的一样，我们遍历$a_i$，则只需要在数组中寻找$a_i-c$的个数。</p><p>那么我们可以先使用一个线性表存住序列本身，然后再使用一个<code>map&lt;int,int&gt;</code>来存住每个数对应的个数，最后依次累加即可。</p><p>代码实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">using</span> i64=<span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> u64=<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> u32=<span class="hljs-type">unsigned</span>;<br><span class="hljs-keyword">using</span> u128=<span class="hljs-type">unsigned</span> __int128;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf=<span class="hljs-number">0x3f3f3f3f</span>;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-type">int</span> n,c;<br>    cin&gt;&gt;n&gt;&gt;c;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br>    map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; mp;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        cin&gt;&gt;a[i];<br>        mp[a[i]]++;<br>    &#125;<br>    i64 ans=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x:a)&#123;<br>        ans+=mp[x-c];<br>    &#125;<br>    cout&lt;&lt;ans;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于省去了一步排序，时间复杂度$O(n)$，是时间复杂度最优算法，因为读入本身就是$O(n)$了。</p><h2 id="双指针写法">双指针写法</h2><p>运用上面<code>lower_bound()</code>和<code>upper_bound()</code>函数的含义，我们可以考虑维护两个指针，左指针$left$和右指针$right$。</p><p>对于排序过的数组<code>vector&lt;int&gt; a</code>而言，遍历数组，令<code>a[left]</code>是首个≥<code>a[i]-c</code>的数，令<code>a[right]</code>是首个＞<code>a[i]-c</code>的数，这样从<code>a[left]</code>到<code>a[right]</code>都是等于<code>a[i]-c</code>的数，则等于<code>a[i]-c</code>的数的个数永远是<code>right-left</code>，累加入答案中。</p><p>在这个过程中<code>a[i]-c</code>递增，因此$left$和$right$都会越来越向右。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">using</span> i64=<span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> u64=<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> u32=<span class="hljs-type">unsigned</span>;<br><span class="hljs-keyword">using</span> u128=<span class="hljs-type">unsigned</span> __int128;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-type">int</span> n;<br>    i64 c;<br>    cin&gt;&gt;n&gt;&gt;c;<br>    <span class="hljs-function">vector&lt;i64&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        cin&gt;&gt;a[i];<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>(),a.<span class="hljs-built_in">end</span>());<br>    i64 cnt=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>,right=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">while</span>(a[left]&lt;a[i]-c) left++;<br>        <span class="hljs-keyword">while</span>(a[right]&lt;=a[i]-c) right++;<br>        <span class="hljs-keyword">if</span>(a[i]-c==a[left]) cnt+=right-left;<br>    &#125;<br>    cout&lt;&lt;cnt;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度$O(nlogn)$，是<code>sort()</code>的复杂度。排序后的复杂度是$O(n)$，因为无论是左指针还是右指针都只是从头移动到了尾。</p>]]></content>
    
    
    <categories>
      
      <category>程设</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mlf德语 3.03日笔记</title>
    <link href="/2025/03/03/3.3/"/>
    <url>/2025/03/03/3.3/</url>
    
    <content type="html"><![CDATA[<p>fremde Leute  陌生人</p><p>die Fortbildung = die Weitebildung  深造</p><p>berufliche Ausbildung  职业培训</p><p>unterschiedlich</p><p>Der Zweite Weltkrieg  二战</p><p>der Liebeskummer –  恋爱烦恼</p><p>feindlich  敌对的</p><h6 id="Ich-fuhle-mich-nicht-wohl-我不舒服">Ich fühle mich (nicht) wohl.  我不舒服</h6><h6 id="Beim-Computerspiel-fuhle-ich-mich-wohl-dann-kann-ich-u-meinen-Kummer-meine-Soger-vergessen-u">Beim Computerspiel fühle ich mich wohl, dann kann ich <u>meinen Kummer / meine Soger vergessen</u>.</h6><h6 id="Als-ich-10-Jahre-alt-war-hatte-ich-Liebeskummer">Als ich 10 Jahre alt war, hatte ich Liebeskummer.</h6><h6 id="Als-ich-6-war-habe-ich-meine-erste-Freundin-kennen-gelernt">Als ich 6 war, habe ich meine erste Freundin kennen gelernt.</h6><p>während der Winterferien</p><p>das Studium abschließen  大学毕业</p><h6 id="Nachdem-ich-an-der-Technischen-Universitat-Munchen-abgeschlossen-hatte-bin-ich-zuruckgekommen-um-zu-arbeiten">Nachdem ich an der Technischen Universität München abgeschlossen hatte, bin ich zurückgekommen, um zu arbeiten.</h6><blockquote><p>[!TIP]</p><p>“Nachdem” 所接从句，比主句提前一个时态。</p></blockquote><p>Gestern war ich beim Arzt.</p><p>简单的用一般过去时，如情态动词，助动词。</p><p>Als ich 14 Jahre alt war, war ich <u>zum ersten Mal</u> in Münschen.</p><p>Wie gefällt es dir in Shanghai? /Wie hat es dir in Münschen gafallen?</p><p>Warum bist du nach Shanghai gekommen?</p><blockquote><p>gefallen–gefiel–gafallen(haben)</p><p>fallen–fiel–gefallen(sein)</p></blockquote><p>Als ich 3 war, habe ich den Kindergarten gegangen.</p><p>Die Sonne scheint./ Es ist sonnig.</p><p>das Gefühl --e 感觉</p><h6 id="Ich-habe-das-dumpfe-Gefuhl-dass-heute-noch-etwas-Schlimmes-passiert">Ich habe das dumpfe Gefühl, dass heute noch etwas Schlimmes passiert.</h6><h6 id="我有种模糊的预感，今天要出事。">我有种模糊的预感，今天要出事。</h6><p>ins Zimmer treten  步入房间</p><p>Sie betreten den Saal.</p><blockquote><p>Ich habe es gesehen, hast du gehört, dass die Beiden zusammen sind.</p></blockquote><p>Wann treffen wir uns?</p><p>Wann ich Zeit habe, komme ich zu dir.</p><h6 id="Wann-ich-Geld-habe-mochte-ich-kundigen（离职）-ausziehen（搬家）">Wann ich Geld habe, möchte ich kündigen（离职） / ausziehen（搬家）.</h6><p>Wann ich kinder <u><strong>hätte</strong></u>, …</p><blockquote><p>[!NOTE]</p><h5 id="Das-Gefuhl"><strong>Das Gefühl</strong></h5><p>指的是 <strong>感觉</strong> 或 <strong>情感</strong>。它可以是身体上的感觉（如冷热、疼痛），也可以是心理上的情感（如快乐、悲伤、爱、恐惧等）。</p><ul><li>Ich habe das Gefühl, dass etwas nicht stimmt.<br>（我感觉有些不对劲。）</li><li>Sie hat ein warmes Gefühl in ihrem Herzen.<br>（她心里有一种温暖的感觉。）</li></ul><hr><h5 id="Der-Sinn"><strong>Der Sinn</strong></h5><p>指的是 <strong>意义</strong>、<strong>目的</strong> 或 <strong>感官</strong>（如视觉、听觉等）。它更偏向于理性或逻辑层面，用于描述事物的意义或功能。</p><ul><li>Was ist der Sinn des Lebens?<br>（生活的意义是什么？）</li><li>Der Sinn dieser Aufgabe ist, etwas Neues zu lernen.<br>（这项任务的意义是学习新东西。）</li><li>Die fünf Sinne des Menschen sind Sehen, Hören, Riechen, Schmecken und Tasten.<br>（人类的五种感官是视觉、听觉、嗅觉、味觉和触觉。）</li></ul><hr><h5 id="常见搭配：">常见搭配：</h5><ul><li><strong>Gefühl</strong>:</li><li>ein gutes/schlechtes Gefühl haben（有一种好/不好的感觉）</li><li>das Gefühl der Liebe（爱的感觉）/ ein Gefühl der Sicherheit（安全感）</li><li><strong>Sinn</strong>:<ul><li>der Sinn des Lebens（生活的意义）</li><li>im übertragenen Sinn（在比喻意义上）</li></ul></li></ul></blockquote><p>Nachdem er die Kinder zur Schule gebracht hatte, ging er zur Arbeit.</p><blockquote><p>Es war mir sofort klar, dass ich an der Tongji Universität,studieren kann.</p></blockquote><p>der Mauerfall / die Mauer ist gefallen.</p><blockquote><p>Ich bin mir (ganze) sicher, dass…</p></blockquote><h5 id="Zeitzeugen-berichten（报告）">Zeitzeugen berichten（报告）</h5><blockquote><p>Ich kam spät nach einer Sitzung nach Hause, da begrüßte mich meine Frau mit den <strong>Worten</strong>: „Die Mauer ist auf!“ Im Fernsehen sahen wir dann das <strong>Unfassbare</strong>, und <u>mir war sofort klar:</u> <u>Nun ist alles anders.</u> Die SED* <u>war am Ende</u>. Sie hatte ihre Macht verloren. Der Mauerfall <strong>verunsicherte</strong> uns <strong>zunächst</strong>. Für mich, der im Zentrum der <strong>geteilt</strong>en Stadt <strong>aufgewachsen</strong> ist, war das ein <strong>überwältigend</strong>es Gefühl. Noch heute <u><strong>lässt es mich nicht kalt</strong></u>, wenn ich in Berlin über den <strong>kaum</strong> <strong>erkennbar</strong>en Mauer<strong>streif</strong>en gehe.</p><p>（我开会回家晚了，妻子用这样的<strong>话</strong>迎接我：“墙倒了！”我们在电视上看到了<strong>难以置信</strong>的一幕，<u>我立刻意识到：</u><u>现在一切都不同了。</u>统一社会党（SED*）<u>走到了尽头</u>。它已经失去了权力。柏林墙的倒塌<strong>起初</strong>让我们感到<strong>不安</strong>。对我来说，在一个<strong>分裂的</strong>城市的中心<strong>长大</strong>，这是一种<strong>压倒性的</strong>感觉。直到今天，当我在柏林走过<strong>几乎难以辨认的</strong>墙<strong>迹</strong>时，我仍然<u><strong>心潮澎湃</strong></u>。）</p><p>Wir <u>hörten</u> im Radio <u>von</u> der Reisefreiheit. Wir <strong>trauten</strong> unseren Ohren nicht und liefen zum <strong>Grenzübergang</strong> an der Bornholmer Straße. Dort waren schon <strong>Zigtausend</strong>e Ostberliner <strong>versammelt</strong> und riefen: „Tor auf! Tor auf!“ Wir steckten <strong>mittendrin</strong>. <strong>Gegen（临近）</strong> Mitternacht öffneten die Grenz<strong>soldaten</strong> den Übergang. <strong>Anfangs</strong> kamen <u><strong>zwar nur Einzelne</strong></u> durch, aber <u>wir konnten das Glück kaum fassen und fielen uns in die Arme.</u> „<strong>Wahnsinn</strong>“, dachten wir immer wieder. Als wir auf der Westberliner Seite waren, <strong>stießen</strong> wir in irgendeiner fremden Wohnung mit fremden Leuten mit einer Dose Bier <strong>an</strong>. „Wahnsinn“ war das Wort <strong>damals</strong>.</p><p>（我们从广播中听到了旅行自由的消息。我们不敢<strong>相信</strong>自己的耳朵，于是跑到了博恩霍尔姆大街的<strong>过境点</strong>。那里已经<strong>聚集</strong>了<strong>成千上万的</strong>东柏林人，他们高喊着：“开门！开门！”我们也挤在人群<strong>中</strong>。午夜时分，边防<strong>士兵</strong>打开了过境点。<strong>起初</strong>只有<u><strong>零星的</strong></u>人通过，但<u>我们几乎无法相信这份幸运，互相拥抱在一起。</u>“太<strong>疯狂</strong>了，”我们一遍又一遍地想着。当我们到达西柏林一侧时，我们在某个陌生人的公寓里和陌生人用一罐啤酒<strong>干杯</strong>。“太疯狂了”是<strong>当时的</strong>流行语。）</p><p>Mein 9. November <strong><u>sah so aus:</u></strong> Als ich am Abend nach Hause kam, saßen meine Eltern vor dem Fernseher, mit Tränen in den Augen. Sie erzählten, dass die Mauer in Berlin <strong>offen</strong> war. Sie weinten <u>vor Glück</u> und hatten doch auch <u>Angst vor</u> dem, was dort noch passieren könnte. Ich war ziemlich ahnungslos. Aber am nächsten Tag fuhr ich mit Freunden sofort nach Berlin. Wir wollten <u>mit eigenen Augen sehen</u>, was dort passierte. Und diese Bilder <u><strong>werde（一将，强调永久）</strong></u> ich nie vergessen. Die Menschen feierten auf den Straßen und tanzten auf der Mauer.</p><p>（我的11月9日**<u>是这样的：</u><strong>当我晚上回到家时，我的父母正坐在电视机前，眼里含着泪水。他们告诉我，柏林墙已经</strong>开放**了。他们<u>因喜悦</u>而哭泣，但也对可能发生的事情<u>感到担忧</u>。我当时还不太明白。但第二天，我立刻和朋友一起去了柏林。我们想<u>亲眼看看</u>那里发生了什么。而这些画面我将<u><strong>永远</strong></u>难忘。人们在街上庆祝，在墙上跳舞。）</p></blockquote><p>Wie sieht es denn … aus?</p><p>sitzen-- saß–gesessen</p><p>fahren–fuhr–gafahren (sein)</p><p>rufen–rief–gerufen</p><p>singen–sang–gesungen</p><h6 id="Ich-habe-Angst-vor-dem-was-dort-passieren-konnte">Ich habe Angst vor dem, was dort passieren könnte.</h6><p>Das Ehepaar–e ist Kinderlos.</p><p>jn. entlassen // keine Arbeit/Job haben</p><p>Das hat keinen Sinn. /Das ist sinnlos.</p><h6 id="Mach-dir-keine-Sorgen-别担心！">Mach dir keine Sorgen!  别担心！</h6><p>gratis = kostenlos</p><p>deswegen = deshalb</p><blockquote><p>[!TIP]</p><h5 id="behalten"><strong>behalten</strong></h5><ul><li>可以用于具体物品（如保留<strong>某物</strong>）。</li><li>也可以用于抽象概念（如保持某种习惯或<strong>状态</strong>）。</li></ul><ol><li><em>Ich behalte das Buch.</em> （我保留这本书。）</li><li><em>Er behielt seine Ruhe.</em> （他保持冷静。）</li><li><em>Behalte den Schlüssel!</em> （留着钥匙吧！）</li></ol><hr><h5 id="beibehalten"><strong>beibehalten</strong></h5><ul><li>通常用于抽象概念（如<strong>规则、政策、习惯</strong>等）。</li><li>不能用于具体物品。</li></ul><ol><li><em>Wir werden die Regel beibehalten.</em> （我们会继续保留这条规则。）</li><li><em>Sie hat ihren alten Namen beibehalten.</em> （她保留了她的旧名字。）</li><li><em>Die Regierung will die aktuellen Maßnahmen beibehalten.</em> （政府希望维持目前的措施。）</li></ol></blockquote><blockquote><p>Das juckt mich nicht.  我不在乎。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>德语</category>
      
    </categories>
    
    
    <tags>
      
      <tag>德语</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《算法笔记》学习笔记</title>
    <link href="/2025/03/02/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2025/03/02/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1>第2章 C/C++快速入门</h1><h2 id="2-1-基本数据类型">2.1 基本数据类型</h2><h3 id="2-1-2-变量类型">2.1.2 变量类型</h3><h4 id="long-long类型赋大于-2-31-1-的初值，需要在初值后面加LL，否则会CE">long long类型赋大于$2^{31}-1$的初值，需要在初值后面加LL，否则会CE</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">long</span> <span class="hljs-type">long</span> bignum = <span class="hljs-number">1234567890123456LL</span>;<br></code></pre></td></tr></table></figure><p>简而言之，题目要求$10^{9}$以内，就用int；$10^{18}$以内，就用longlong</p><p>浮点型：不要用float，只用double就可以了</p><h4 id="char：小写字母比大写字母的ASCII值大32">char：小写字母比大写字母的ASCII值大32</h4><p>字符常量必须用单引号标注，以区分是作为字符变量还是字符常量</p><h4 id="转义字符">转义字符</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">\n 代表换行<br>\<span class="hljs-number">0</span> 代表空字符<span class="hljs-literal">NULL</span>，其ASCII码为<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h4 id="字符串常量：由双引号标记的字符集，可以作为初值赋值给字符数组并使用-s的形式输出">字符串常量：由双引号标记的字符集，可以作为初值赋值给字符数组并使用%s的形式输出</h4><p>不能把字符串常量赋值给字符变量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> c=<span class="hljs-string">&quot;abcd&quot;</span><br></code></pre></td></tr></table></figure><p>的写法是不允许的</p><h4 id="布尔型">布尔型</h4><p>只有0才是False，别的整数都是True</p><h3 id="2-1-3-强制类型转换">2.1.3 强制类型转换</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">(新类型名)变量名<br></code></pre></td></tr></table></figure><p>如果把一个类型的变量赋值给另一个类型的变量却没有写强转，那么IDE会自动强转</p><p>但是计算的时候需要强转，那就不能等到算完再强转</p><h3 id="2-1-4-符号常量和const常量">2.1.4 符号常量和const常量</h3><p><strong>格式为</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> 标识符 常量</span><br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> 数据类型 变量名 = 常量;<br></code></pre></td></tr></table></figure><p>常量的值一旦确定之后就不能改变了。</p><p><strong>define除了定义常量以外，还可以定义任何语句或者片段（宏定义），格式如下</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> 标识符 任何语句或者片段</span><br></code></pre></td></tr></table></figure><p>比如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ADD(a,b) ((a)+(b)) <span class="hljs-comment">//为什么要加这么多括号？是因为宏定义是直接将对应的部分替换，然后才进行编译和运行</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> num1 =<span class="hljs-number">3</span>, num2 =<span class="hljs-number">5</span>;<br>    <span class="hljs-built_in">prints</span>(<span class="hljs-string">&quot;%d&quot;</span>, <span class="hljs-built_in">ADD</span>(num1,num2)); <span class="hljs-comment">//8</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>所以，尽量不要用宏定义来做除了定义常量以外的事情</strong></p><h3 id="2-1-5-运算符">2.1.5 运算符</h3><p>只复习位运算符  <a href="https://oi-wiki.org/math/bit/">详见Oiwiki</a></p><h2 id="2-2-顺序结构">2.2 顺序结构</h2><h4 id="常见数据类型变量的scanf格式符">常见数据类型变量的scanf格式符</h4><table><thead><tr><th>数据类型</th><th>格式符</th></tr></thead><tbody><tr><td>int</td><td>%d</td></tr><tr><td>long long</td><td>%lld</td></tr><tr><td>float</td><td>%f</td></tr><tr><td>double</td><td>%lf</td></tr><tr><td>char</td><td>%c</td></tr><tr><td>字符串(char数组)</td><td>%s</td></tr></tbody></table><p><em>录入字符串不需要加&amp;</em></p><p>另外，如果要输入“3 4”这种用空格隔开的两个数字，两个%d直接可以不加空格</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a, b;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);<br></code></pre></td></tr></table></figure><p>原因：除了%c以外，scanf对于其他格式符(如%d)的输入是以空白符（空格、tab）座位结束判断标志的<br><em>另外，字符数组使用%s读入的时候以空格和换行座位读入结束的标识</em><br><strong>即scanf的%c格式是可以读入空格和换行的！</strong></p><h4 id="常见数据类型变量的printf格式符">常见数据类型变量的printf格式符</h4><table><thead><tr><th>数据类型</th><th>格式符</th></tr></thead><tbody><tr><td>int</td><td>%d</td></tr><tr><td>long long</td><td>%lld</td></tr><tr><td>float</td><td>%f</td></tr><tr><td>double</td><td>%f</td></tr><tr><td>char</td><td>%c</td></tr><tr><td>字符串(char数组)</td><td>%s</td></tr></tbody></table><p>与scanf的区别只在于double</p><h4 id="三种实用的输出格式">三种实用的输出格式</h4><ol><li>%md<br>%md可以使不足m位的int型变量以m位进行右对齐输出，其中高位用空格补齐，如果变量本身超过m位则保持原样（不会截断）</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;   <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a=<span class="hljs-number">123</span>, b=<span class="hljs-number">1234567</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%5d\n&quot;</span>,a);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%5d\n&quot;</span>,b);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出格式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">  <span class="hljs-number">123</span><br><span class="hljs-number">1234567</span><br></code></pre></td></tr></table></figure><p>在123的前面补了两个空格<br>2. %0md 补上前导0</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;   <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a=<span class="hljs-number">123</span>, b=<span class="hljs-number">1234567</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%05d\n&quot;</span>,a);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%05d\n&quot;</span>,b);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出格式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">00123</span><br><span class="hljs-number">1234567</span><br></code></pre></td></tr></table></figure><ol start="3"><li>%.mf 保留m位小数输出（不等价于四舍五入）</li></ol><h3 id="2-2-3-使用getchar和putchar来输入-输出字符">2.2.3 使用getchar和putchar来输入/输出字符</h3><p>getchar用来输入单个字符，putchar用来输出单个字符，在某些scanf函数使用不便的场合可以使用 getchar 来输入字符。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">char</span> cl，c2，c3;<br>c1 =<span class="hljs-built_in">getchar</span>();<br><span class="hljs-built_in">getchar</span>();<br>c2 =<span class="hljs-built_in">getchar</span>();<br>c3 = <span class="hljs-built_in">getchar</span>();<br><span class="hljs-built_in">putchar</span>(c1);<br><span class="hljs-built_in">putchar</span>(c2);<span class="hljs-built_in">putchar</span>(c3);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure><p>输入数据</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">abcd<br></code></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">acd<br></code></pre></td></tr></table></figure><p>此处第一个字符’a’被c1接收;第二个字符’b’虽然被接收，但是没有将它存储在某个变量中;第三个字符c被 c2 接收;第四个字符’d&quot;被 c3 接收。之后，连续三次 putchar 将把 c1、c2、c3 连续输出。而如果输入&quot;ab&quot;，然后按Enter键，再输入c，再按Enter键，输出结果会是这样:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><br>c<br></code></pre></td></tr></table></figure><p>这是因为 getchar 可以识别换行符，所以 c2实际上储存的是换行符\n，因此在a和c之间会有一个换行出现。</p><h3 id="2-2-4注释">2.2.4注释</h3><h3 id="2-2-5-typedef">2.2.5 typedef</h3><p>可以给复杂的数据类型取一个别名</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br>Ltypedef <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<span class="hljs-comment">//给1ong 1ong起个别名</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>LL a=<span class="hljs-number">123456789012345</span>，b=<span class="hljs-number">234567890123456</span>;<span class="hljs-comment">//直接使用 LL</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;lld\n&quot;</span>，a+b);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-6-常用math函数">2.2.6 常用math函数</h3><ol><li><p>fabs(double x)<br>用于对double型变量取绝对值</p></li><li><p>floor(double x) ceil(double x)</p></li><li><p>pow(double r, double p)<br>返回$r^{p}$</p></li><li><p>sqrt(double x)</p></li><li><p>log(double x)<br>返回lnx<br><strong>C语言中不能指定底数，因此必须通过换底公式来求。</strong></p></li><li><p>sin(double x) cso(double x) tan(double x)<br>要求参数是<strong>弧度制</strong></p></li><li><p>asin(double x) acos(double x) atan(double x)<br>反三角函数</p></li><li><p>round(double x)<br>将double型变量四舍五入，<strong>返回值仍然是double类型</strong></p></li></ol><h2 id="2-3-选择结构">2.3 选择结构</h2><h3 id="2-3-1-if语句">2.3.1 if语句</h3><h3 id="2-3-3-switch语句">2.3.3 switch语句</h3><p>记得什么是break穿透</p><h2 id="2-4-循环结构">2.4 循环结构</h2><h3 id="2-4-1-while语句">2.4.1 while语句</h3><h3 id="2-4-2-do…while语句">2.4.2 do…while语句</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">do</span> &#123;<br>        sum += i;<br>        i++;<br>    &#125; <span class="hljs-keyword">while</span> (i &lt;= <span class="hljs-number">100</span>);<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;The sum of numbers from 1 to 100 is: &quot;</span> &lt;&lt; sum &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>do…while会先执行循环体一次，再去判断循环条件是不是为真</strong></p><h3 id="2-4-3-for语句">2.4.3 for语句</h3><blockquote><p><code>for (int x : s)</code> 是 C++11 引入的一种范围-based for 循环（range-based for loop）语法。它的作用是遍历容器 <code>s</code> 中的每一个元素，并将每个元素赋值给变量 <code>x</code>，然后在循环体中处理 <code>x</code>。</p><hr><h3 id="语法解析"><strong>语法解析</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : s) &#123;<br> <span class="hljs-comment">// 循环体</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>int x</code>：定义一个变量 <code>x</code>，用于存储容器 <code>s</code> 中的每个元素。<code>x</code> 的类型应与容器 <code>s</code> 中元素的类型一致。</li><li><code>s</code>：一个可迭代的容器（如 <code>std::vector</code>、<code>std::set</code>、<code>std::list</code> 等）。</li><li><code>:</code>：表示遍历容器 <code>s</code> 中的每个元素。</li><li><code>&#123;&#125;</code>：循环体，对每个元素 <code>x</code> 执行的操作。</li></ul><hr><h3 id="与传统-for-循环的对比"><strong>与传统 for 循环的对比</strong></h3><h4 id="传统-for-循环">传统 for 循环</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = s.<span class="hljs-built_in">begin</span>(); it != s.<span class="hljs-built_in">end</span>(); ++it) &#123;<br>    <span class="hljs-type">int</span> x = *it;<br>    <span class="hljs-comment">// 循环体</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="范围-based-for-循环">范围-based for 循环</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : s) &#123;<br>    <span class="hljs-comment">// 循环体</span><br>&#125;<br></code></pre></td></tr></table></figure><p>范围-based for 循环的优点是：</p><ol><li><strong>简洁</strong>：不需要手动管理迭代器。</li><li><strong>易读</strong>：直接表达“遍历容器中的每个元素”的意图。</li><li><strong>安全</strong>：避免迭代器越界或错误。</li></ol><h4 id="示例：遍历-std-set">示例：遍历 <code>std::set</code></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::set&lt;<span class="hljs-type">int</span>&gt; s = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>&#125;;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : s) &#123;<br>        std::cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span>; <span class="hljs-comment">// 输出 10 20 30</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="注意事项"><strong>注意事项</strong></h3><ol><li><p><strong>元素类型匹配</strong>：</p><ul><li><p><code>x</code> 的类型必须与容器 <code>s</code> 中元素的类型一致。如果不确定类型，可以使用 <code>auto</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : s) &#123;<br>    <span class="hljs-comment">// 循环体</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>避免拷贝</strong>：</p><ul><li><p>如果容器中的元素是复杂类型（如 <code>std::string</code> 或自定义类），直接使用 <code>for (auto x : s)</code> 会导致元素的拷贝。为了避免拷贝，可以使用引用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; x : s) &#123;<br>    <span class="hljs-comment">// 循环体</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>修改元素</strong>：</p><ul><li><p>如果需要修改容器中的元素，可以使用非 <code>const</code> 引用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; x : s) &#123;<br>    x = x * <span class="hljs-number">2</span>; <span class="hljs-comment">// 修改元素</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ol></blockquote><h3 id="2-4-4-break和continue语句">2.4.4 break和continue语句</h3><h2 id="2-5-数组">2.5 数组</h2><h3 id="2-5-1-一维数组">2.5.1 一维数组</h3><p>记得初赋值，有两种赋值为0的方法：把第一个元素赋为0，或者只用一个大括号表示</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a[<span class="hljs-number">10</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">int</span> a[<span class="hljs-number">10</span>]=&#123;&#125;;<br></code></pre></td></tr></table></figure><p>递推：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs inform7">for(int i=1;i&lt;10;i++)&#123;<br>    a<span class="hljs-comment">[0]</span> =1;<br>    a<span class="hljs-comment">[1]</span> =1;<br>    a<span class="hljs-comment">[i+1]</span>=a<span class="hljs-comment">[i]</span>+a<span class="hljs-comment">[i-1]</span>;<br>&#125; //斐波那契数列<br></code></pre></td></tr></table></figure><h3 id="2-5-2-冒泡排序">2.5.2 冒泡排序</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; len - <span class="hljs-number">1</span>; j++)&#123;      <span class="hljs-comment">//长度为n的数组，只需要执行这样的排序循环n-1次</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span> - j; i++)&#123;<br>            <span class="hljs-type">int</span> temp = arr[i];<br>            <span class="hljs-keyword">if</span> (arr[i] &gt; arr[i + <span class="hljs-number">1</span>])&#123;<br>                arr[i] = arr[i + <span class="hljs-number">1</span>];<br>                arr[i + <span class="hljs-number">1</span>] = temp;<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>别忘记交换两个数的固定写法</strong></p><h3 id="2-5-3-二维数组">2.5.3 二维数组</h3><p>初始化的方式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a[<span class="hljs-number">5</span>][<span class="hljs-number">6</span>] = &#123;&#123;&#125;&#125;; <span class="hljs-comment">//默认全部赋值0</span><br></code></pre></td></tr></table></figure><p><strong>如果数组大小较大（大概$10^{6}$级别），则需要定义在main函数外面</strong></p><h3 id="2-5-4-memset——对数组中每一个元素赋相同的值">2.5.4 memset——对数组中每一个元素赋相同的值</h3><p>格式为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">memset</span>(数组名, 值, <span class="hljs-built_in">sizeof</span>(数组名))；<br></code></pre></td></tr></table></figure><p><strong>只建议使用memset赋值0或者-1，因为memset是对每个字节赋同样的值。如果要赋值其他数字，用fill函数。</strong></p><h3 id="2-5-5-字符数组">2.5.5 字符数组</h3><h4 id="字符数组的初始化">字符数组的初始化</h4><p>除了赋值的时候一个一个赋值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> str[<span class="hljs-number">3</span>] = &#123;<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;\0&#x27;</span>&#125;;<br></code></pre></td></tr></table></figure><p>也可以通过直接赋值字符串来初始化<strong>仅限于初始化，程序其他位置不允许这样直接赋值整个字符串</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> str[<span class="hljs-number">15</span>] = <span class="hljs-string">&quot;Good Day!&quot;</span>;<br></code></pre></td></tr></table></figure><h4 id="字符数组的输入输出">字符数组的输入输出</h4><ol><li>scanf输入 printf输出<br>%s识别空格作为字符串的结尾</li><li>getchar输入，putchar输出</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;   <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">char</span> str[<span class="hljs-number">5</span>][<span class="hljs-number">5</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">3</span>;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">3</span>;j++)&#123;<br>            str[i][j]=<span class="hljs-built_in">getchar</span>();<br>            <span class="hljs-built_in">getchar</span>(); <span class="hljs-comment">//这句是为了把输入中每行末尾的换行符吸收掉</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">3</span>;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">3</span>;j++)&#123;<br>            <span class="hljs-built_in">putchar</span>(str[i][j]);<br>        &#125;<br>        <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;\n&#x27;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码就是一个二维数组的示例，输入什么就输出什么。<br>3. gets输入，puts输出<br><strong>在C11之后被弃用</strong><br>现在想要读取一行字符串可以使用while c!=\n或者getline</p><h4 id="字符数组的存放方式">字符数组的存放方式</h4><p>结尾是一个’\0  <strong>只有char型数组要注意，千万要注意长度要比实际存储字符串的长度至少多1</strong></p><h3 id="2-5-6-string-h头文件">2.5.6 string.h头文件</h3><ol><li><p>strlen()，得到字符数组中第一个\0前字符的个数</p></li><li><p>strcmp(), 返回两个字符串大小的比较结果，比较原则是按照字典序</p><blockquote><p>在 C++ 中，字符串的字典序比较是基于字符的 ASCII 值逐字符进行的。字典序比较的规则类似于英语词典中单词的排序规则。以下是字符串字典序比较的详细说明：</p><hr><h3 id="1-字典序比较规则"><strong>1. 字典序比较规则</strong></h3><ol><li><p><strong>逐字符比较</strong>：</p><ul><li>从字符串的第一个字符开始，逐个比较对应位置的字符。</li><li>如果两个字符的 ASCII 值不同，则 ASCII 值较小的字符所在的字符串较小。</li></ul></li><li><p><strong>长度比较</strong>：</p><ul><li>如果两个字符串的前缀完全相同，但一个字符串比另一个字符串长，则较短的字符串较小。</li></ul></li></ol><hr><h3 id="2-示例说明"><strong>2. 示例说明</strong></h3><h4 id="示例-1"><strong>示例 1</strong></h4><ul><li>字符串 <code>&quot;apple&quot;</code> 和 <code>&quot;banana&quot;</code>：<ul><li>比较第一个字符：<code>'a'</code>（ASCII 97）和 <code>'b'</code>（ASCII 98）。</li><li>因为 <code>'a' &lt; 'b'</code>，所以 <code>&quot;apple&quot; &lt; &quot;banana&quot;</code>。</li></ul></li></ul><h4 id="示例-2"><strong>示例 2</strong></h4><ul><li>字符串 <code>&quot;apple&quot;</code> 和 <code>&quot;apricot&quot;</code>：<ul><li>前两个字符相同（<code>'a'</code> 和 <code>'p'</code>）。</li><li>比较第三个字符：<code>'p'</code>（ASCII 112）和 <code>'r'</code>（ASCII 114）。</li><li>因为 <code>'p' &lt; 'r'</code>，所以 <code>&quot;apple&quot; &lt; &quot;apricot&quot;</code>。</li></ul></li></ul><h4 id="示例-3"><strong>示例 3</strong></h4><ul><li>字符串 <code>&quot;apple&quot;</code> 和 <code>&quot;app&quot;</code>：<ul><li>前三个字符相同（<code>'a'</code>、<code>'p'</code>、<code>'p'</code>）。</li><li><code>&quot;app&quot;</code> 比 <code>&quot;apple&quot;</code> 短，所以 <code>&quot;app&quot; &lt; &quot;apple&quot;</code>。</li></ul></li></ul><hr><h3 id="3-C-中的字符串比较"><strong>3. C++ 中的字符串比较</strong></h3><p>在 C++ 中，字符串的比较可以通过以下方式实现：</p><ol><li><p><strong>使用比较运算符</strong>：</p><ul><li><code>==</code>：判断两个字符串是否相等。</li><li><code>!=</code>：判断两个字符串是否不相等。</li><li><code>&lt;</code>：判断第一个字符串是否小于第二个字符串。</li><li><code>&gt;</code>：判断第一个字符串是否大于第二个字符串。</li><li><code>&lt;=</code>：判断第一个字符串是否小于或等于第二个字符串。</li><li><code>&gt;=</code>：判断第一个字符串是否大于或等于第二个字符串。</li></ul></li><li><p><strong>示例代码</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>                                                                                                                                                      <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    string s1 = <span class="hljs-string">&quot;apple&quot;</span>;<br>    string s2 = <span class="hljs-string">&quot;banana&quot;</span>;<br>                                                                                                                                                      <br>    <span class="hljs-keyword">if</span> (s1 &lt; s2) &#123;<br>        cout &lt;&lt; s1 &lt;&lt; <span class="hljs-string">&quot; is less than &quot;</span> &lt;&lt; s2 &lt;&lt; endl;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s1 &gt; s2) &#123;<br>        cout &lt;&lt; s1 &lt;&lt; <span class="hljs-string">&quot; is greater than &quot;</span> &lt;&lt; s2 &lt;&lt; endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        cout &lt;&lt; s1 &lt;&lt; <span class="hljs-string">&quot; is equal to &quot;</span> &lt;&lt; s2 &lt;&lt; endl;<br>    &#125;<br>                                                                                                                                                      <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="输出"><strong>输出</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">apple is less than banana<br></code></pre></td></tr></table></figure><hr><h3 id="4-字典序的应用"><strong>4. 字典序的应用</strong></h3><p>字典序比较在以下场景中非常有用：</p><ol><li><p><strong>字符串排序</strong>：</p><ul><li>例如，对一组单词按字典序排序。</li><li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;string&gt; words = &#123;<span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;apricot&quot;</span>&#125;;<br><span class="hljs-built_in">sort</span>(words.<span class="hljs-built_in">begin</span>(), words.<span class="hljs-built_in">end</span>());<br><span class="hljs-comment">// 排序后：[&quot;apple&quot;, &quot;apricot&quot;, &quot;banana&quot;]</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>拼数问题</strong>：</p><ul><li>在拼数问题中，通过比较字符串拼接后的字典序，可以找到最大的拼接结果。</li></ul></li><li><p><strong>查找最小或最大字符串</strong>：</p><ul><li>例如，在一组字符串中找到字典序最小或最大的字符串。</li></ul></li></ol><hr><h3 id="5-注意事项"><strong>5. 注意事项</strong></h3><ol><li><p><strong>大小写敏感</strong>：</p><ul><li>字典序比较是大小写敏感的。例如，<code>'A'</code>（ASCII 65）和 <code>'a'</code>（ASCII 97）是不同的字符。</li><li>如果需要忽略大小写，可以先将字符串转换为统一的大小写形式。</li></ul></li><li><p><strong>数字字符串的比较</strong>：</p><ul><li>对于数字字符串（如 <code>&quot;123&quot;</code> 和 <code>&quot;45&quot;</code>），字典序比较可能不符合数值大小的比较结果。</li><li>例如，<code>&quot;123&quot; &lt; &quot;45&quot;</code>（因为 <code>'1' &lt; '4'</code>），但数值上 <code>123 &gt; 45</code>。</li></ul></li></ol><hr><h3 id="6-总结"><strong>6. 总结</strong></h3><ul><li>字符串的字典序比较是基于字符的 ASCII 值逐字符进行的。</li><li>如果两个字符串的前缀相同，较短的字符串较小。</li><li>在 C++ 中，可以直接使用比较运算符（如 <code>&lt;</code>、<code>&gt;</code>）来比较字符串的字典序。</li><li>字典序比较在字符串排序、拼数问题等场景中非常有用。</li></ul><p>如果你有其他问题，欢迎继续提问！</p></blockquote></li><li><p>strcpy()</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">strcpy</span>(字符数组<span class="hljs-number">1</span>， 字符数组<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p><strong>注意：是把字符数组2赋值给字符数组1，这里的复制也包括了\0</strong></p><ol start="4"><li>strcat()</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">strcat</span>(字符数组<span class="hljs-number">1</span>， 字符数组<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p><strong>注意：是把字符数组2接到字符数组1后面去</strong></p><h3 id="2-5-7-sscanf与sprintf">2.5.7 sscanf与sprintf</h3><p>sscanf从单词上可以理解为 string+scanf,sprintf则可以理解为 string+printf,均在 stdio.h 头文件下。<br>先来回顾一下scanf与printf，其实可以写成这种形式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">scanf</span>(screen, <span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br><span class="hljs-built_in">printf</span>(screen, <span class="hljs-string">&quot;%d&quot;</span>, n);<br></code></pre></td></tr></table></figure><p>可以发现，scanf的输入其实是把 screen的内容以&quot;%d&quot;的格式传输到n中(即从左至右)<br>而 printf的输出则是把n以&quot;%d&quot;的格式传输到screen上(即从右至左)。<br>sscanf与sprintf与上面的格式是相同的，只不过把 screen 换成了字符数组<br>(假设定义了一个char 数组 str[100])，如下所示:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">sscanf</span>(str, <span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br><span class="hljs-built_in">sprintf</span>(str, <span class="hljs-string">&quot;%d&quot;</span>, n);<br></code></pre></td></tr></table></figure><p>上面sscanf写法的作用是把字符数组str中的内容以&quot;%d&quot;的格式写到n中(还是从左至右)<br>而sprintf写法的作用是把n以&quot;%d&quot;的格式写到str 字符数组中(还是从右至左)。示例如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;   <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n=<span class="hljs-number">233</span>;<br>    <span class="hljs-type">char</span> str[<span class="hljs-number">100</span>];<br>    <span class="hljs-built_in">sprintf</span>(str,<span class="hljs-string">&quot;%d&quot;</span>, n);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, str);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">233</span><br></code></pre></td></tr></table></figure><p>上面只是一些简单的应用，事实上，可以像使用scanf与printf那样进行复杂的格式输入和输出。例如下面的代码使用sscanf将字符数组str中的内容按&quot;%d:%lf,%s&quot;的格式写到int型变量n、double型变量db、char型数组str2中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;   <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-type">double</span> db;<br>    <span class="hljs-type">char</span> str[<span class="hljs-number">1000</span>] = <span class="hljs-string">&quot;2048:3.14,hello&quot;</span>, str2[<span class="hljs-number">100</span>];<br>    <span class="hljs-built_in">sscanf</span>(str, <span class="hljs-string">&quot;%d:%lf,%s&quot;</span>,&amp;n, &amp;db, str2);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;n=%d,db=%.2f,str2=%s\n&quot;</span>,n,db,str2);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">n=<span class="hljs-number">2048</span>,db=<span class="hljs-number">3.14</span>,str2=hello<br></code></pre></td></tr></table></figure><p>类似的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;   <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n=<span class="hljs-number">12</span>;<br>    <span class="hljs-type">double</span> db=<span class="hljs-number">3.1415</span>;<br>    <span class="hljs-type">char</span> str[<span class="hljs-number">1000</span>], str2[<span class="hljs-number">100</span>]=<span class="hljs-string">&quot;good&quot;</span>;<br>    <span class="hljs-built_in">sprintf</span>(str, <span class="hljs-string">&quot;%d:%.2f,%s&quot;</span>,n, db, str2);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;str=%s\n&quot;</span>,str);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">str=<span class="hljs-number">12</span>:<span class="hljs-number">3.14</span>,good<br></code></pre></td></tr></table></figure><h2 id="2-6-函数">2.6 函数</h2><h3 id="2-6-1-函数的定义">2.6.1 函数的定义</h3><ul><li>全局变量：定义在所有函数之前，对于定义之后的所有程序段之内都有效的变量</li><li>局部变量：定义在函数内部且只在函数内部生效，函数结束之后局部变量销毁</li><li>函数定义内的小括号内的参数被称为<strong>形式参数</strong>简称<strong>形参</strong>，而在实际调用时小括号之内的参数称为<strong>实际参数</strong>或者<strong>实参</strong></li></ul><h3 id="2-6-2-再谈main函数">2.6.2 再谈main函数</h3><p>return 0；是告知系统，程序正常终止</p><h3 id="2-6-3-以数组作为函数参数">2.6.3 以数组作为函数参数</h3><p>数组作为参数时，数组中的第一维不需要填写长度（如果是二维数组，那么第二维需要填写长度），实际调用时也只需要填写数组名。<br><strong>数组作为参数时，在函数中对数组元素的修改就等同是对原数组元素的修改（这与普通的局部变量不同）</strong><br>比如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-type">int</span> b[][<span class="hljs-number">5</span>])</span></span>&#123; <span class="hljs-comment">//第二维要注明长度</span><br><br>&#125; <br></code></pre></td></tr></table></figure><p>数组可以作为参数传入，但是不能作为返回类型。</p><h3 id="2-6-4-函数的嵌套调用">2.6.4 函数的嵌套调用</h3><h3 id="2-6-5-函数的递归调用">2.6.5 函数的递归调用</h3><p>递归是函数自己调用自身的过程，会在第四章详细介绍</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;   <br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">F</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">F</span>(n<span class="hljs-number">-1</span>)*n;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n=<span class="hljs-number">12</span>;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-7-指针">2.7 指针</h2><p><strong>指针是一个unsigned类型的int</strong></p><h3 id="2-7-2-指针变量">2.7.2 指针变量</h3><p><strong>指针变量用来存放指针（或者可以理解成地址）</strong>，意思是把地址当做常量，然后专门定义了一种指针变量来存放它，在某种数据类型后加型号*来表示这是一个指针变量</p><p>如果要同时定义几个指针变量，星号只会结合于第一个变量名</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span>* p1, p2; <span class="hljs-comment">//p1是int*类型的 p2是int类型的</span><br></code></pre></td></tr></table></figure><p>一种给指针变量赋值的方式，<strong>给指针变量赋值的方式一般是把变量的地址取出来(使用取地址运算符&amp;)，然后赋值给对应的指针变量</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a;<br><span class="hljs-type">int</span> *p = &amp;a;<br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a;<br><span class="hljs-type">int</span> *p;<br>p = &amp;a;<br></code></pre></td></tr></table></figure><p><strong>地址&amp;a是赋值给p的而不是赋值给*p的，需要铭记星号是类型的一部分</strong></p><p>对于一个指针变量，它的解引用也是使用星号*，比如如下的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-type">int</span> *p=&amp;a;<br>    a=<span class="hljs-number">233</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,*p); <span class="hljs-comment">//输出233</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码中首先定义int型变量a，但是没有初始化。然后定义指针变量p，并将a的地址赋值给p。这时p存放了a的地址。之后a被赋值为233，也就是说<strong>a所在地址的房间内的内容被改变了，但是这不影响它的地址</strong>。而在后面的输出中使用星号*作为开启房间的钥匙，放在了p的前面，这样*p就能获取到房间里的东西，即储存的数据。</p><p>由此可以延伸到，既然p保存的是地址，*p是这个地址存放的元素，那么直接对*进行赋值也可以起到改变保存的元素的功能</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-type">int</span> *p=&amp;a;<br>    *p=<span class="hljs-number">233</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,a); <span class="hljs-comment">//输出233</span><br>&#125;<br></code></pre></td></tr></table></figure><p>指针变量可以进行加减法，对int*型变量p来说，<strong>p+1是p所指的int变量的下一个int型变量地址</strong></p><h3 id="2-7-3-指针与数组">2.7.3 指针与数组</h3><p><strong>数组名称可以作为数组的首地址使用</strong><br>即定义int arr[], 则有<strong>a==&amp;a[0];</strong><br>且有*<em>a+i==&amp;a[i], <em>(a+i)==a[i];</em></em><br><strong>两个int类型的指针相减，等价于求这两个指针之间相差了几个int</strong>，比如下面这段代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a[<span class="hljs-number">5</span>];<br><span class="hljs-type">int</span> *p=a;<br><span class="hljs-type">int</span> *q=a<span class="hljs-number">+5</span>;<br>cout&lt;&lt;q-p;<br></code></pre></td></tr></table></figure><p>会输出5，这个解释对于其他类型的指针同样适用</p><h3 id="2-7-4-使用指针变量作为函数参数">2.7.4 使用指针变量作为函数参数</h3><p>这时视为把变量的地址传入函数，如果在函数中对这个地址的元素进行改变，那么原先的数据就确实地会被改变。<br>经典例子，使用指针作为参数交换两个数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">void</span> _swap(<span class="hljs-type">int</span> *a, <span class="hljs-type">int</span> *b)&#123;<br>    <span class="hljs-type">int</span> temp=*a; <br>    *a=*b;<br>    *b=temp;<br>&#125;<br></code></pre></td></tr></table></figure><p>经典错误1</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">void</span> _swap(<span class="hljs-type">int</span> *a, <span class="hljs-type">int</span> *b)&#123;<br>    <span class="hljs-type">int</span> *temp; <br>    *temp=*a;<br>    *a=*b;<br>&#125;<br></code></pre></td></tr></table></figure><p>错因：指针temp没有初始化，是野指针，很大可能指向系统工作区间，随机地址出错概率特别大。</p><p>解决方案：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">void</span> _swap(<span class="hljs-type">int</span> *a, <span class="hljs-type">int</span> *b)&#123;<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-type">int</span> *temp=&amp;x; <br>    *temp=*a;<br>    *a=*b;<br>&#125;<br></code></pre></td></tr></table></figure><p>经典错误2</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">void</span> _swap(<span class="hljs-type">int</span> *a, <span class="hljs-type">int</span> *b)&#123;<br>    <span class="hljs-type">int</span> *temp=a;<br>    a=b;<br>    b=temp;<br>&#125;<br></code></pre></td></tr></table></figure><p>错因：回顾前面所说的，函数参数的传送方式是单向一次性的，main函数传给swap函数的“地址”其实只是一个unsigned int，swap对地址本身修改并不能对main函数里面的地址进行修改，<strong>能够使main函数里面的数据发生变化的只能是swap函数中对地址指向的数据进行的修改</strong>。这个函数其实就很类似于为什么不可以写一个这样的函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">void</span> _swap(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)&#123;<br>    <span class="hljs-type">int</span> temp=a; <br>    a=b;<br>    b=temp;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为其实都只是副本罢了。</p><h3 id="2-7-5-引用">2.7.5 引用</h3><h4 id="引用的含义">引用的含义</h4><p>C++中特有的语法，给原变量起一个别名，且对引用变量的操作就是对于原变量的操作   <strong>引用不产生副本</strong><br>方法：在函数的参数类型后面加一个&amp;就可以了<br><strong>注意与取地址运算符的&amp;区分开</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;   <br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp;x)</span></span>&#123;<br>    x=<span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n=<span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">change</span>(n);<br>    cout&lt;&lt;n;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="指针的引用">指针的引用</h4><p>可以运用引用，改造上面的经典错误2</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">void</span> _swap(<span class="hljs-type">int</span>* &amp;p1, <span class="hljs-type">int</span>* &amp;p2)&#123;<br>    <span class="hljs-type">int</span> *temp=p1;<br>    p1=p2;<br>    p2=temp;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里相当于把int*视作一个unsigned int类型，而对这样的两个整型变量进行交换是需要加引用的<br>传入的是指针的别名。<br><em><strong>常量不可以使用引用</strong></em></p><blockquote><p>在C++中，引用（Reference）是一种特殊的变量类型，它为另一个变量提供了一个别名。<br>引用本身并不占用额外的内存空间，它只是指向另一个变量的内存地址。<br>通过引用，你可以直接操作被引用的变量，而不需要通过指针来间接访问。</p><p>引用的声明语法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">类型 &amp;引用名 = 变量名;<br></code></pre></td></tr></table></figure><ul><li><code>类型</code>：被引用变量的类型。</li><li><code>引用名</code>：引用的名称，用于后续操作。</li><li><code>变量名</code>：被引用的变量的名称。</li></ul><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;  <span class="hljs-comment">// 定义一个整型变量a</span><br>    <span class="hljs-type">int</span> &amp;ref = a;  <span class="hljs-comment">// 定义一个引用ref，它指向变量a</span><br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; std::endl;  <span class="hljs-comment">// 输出: a = 10</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;ref = &quot;</span> &lt;&lt; ref &lt;&lt; std::endl;  <span class="hljs-comment">// 输出: ref = 10</span><br><br>    ref = <span class="hljs-number">20</span>;  <span class="hljs-comment">// 通过引用修改a的值</span><br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; std::endl;  <span class="hljs-comment">// 输出: a = 20</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;ref = &quot;</span> &lt;&lt; ref &lt;&lt; std::endl;  <span class="hljs-comment">// 输出: ref = 20</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>关键点：</p><ol><li><p><strong>初始化</strong>：引用必须在声明时进行初始化，并且一旦初始化后，就不能再引用其他变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> &amp;ref = a;  <span class="hljs-comment">// 正确</span><br><span class="hljs-type">int</span> &amp;ref2;  <span class="hljs-comment">// 错误，引用必须初始化</span><br></code></pre></td></tr></table></figure></li><li><p><strong>别名</strong>：引用实际上是变量的别名，对引用的操作就是对原变量的操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> &amp;ref = a;<br>ref = <span class="hljs-number">20</span>;  <span class="hljs-comment">// 等同于 a = 20;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>不能为空</strong>：引用不能为空，它必须始终引用某个有效的对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> &amp;ref = <span class="hljs-literal">nullptr</span>;  <span class="hljs-comment">// 错误，引用不能为空</span><br></code></pre></td></tr></table></figure></li><li><p><strong>常量引用</strong>：你可以声明一个常量引用，这样引用就不能修改被引用的变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;ref = a;  <span class="hljs-comment">// 常量引用</span><br>ref = <span class="hljs-number">20</span>;  <span class="hljs-comment">// 错误，常量引用不能修改被引用的变量</span><br></code></pre></td></tr></table></figure></li><li><p><strong>引用作为函数参数</strong>：引用常用于函数参数传递，以避免拷贝大对象，并且可以直接修改传入的参数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">increment</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;value)</span> </span>&#123;<br>    value++;<br>&#125;<br>                                                                                                                                                                                                                                                <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-built_in">increment</span>(a);<br>    std::cout &lt;&lt; a &lt;&lt; std::endl;  <span class="hljs-comment">// 输出: 11</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>总结：</p><p>引用在C++中是一个非常强大的工具，它允许你以更直观的方式操作变量，避免了指针的复杂性。<br>通过引用，你可以直接修改被引用的变量，而不需要通过指针来间接访问。<br>引用在函数参数传递、返回值等方面都有广泛的应用。</p></blockquote><h2 id="2-8-结构体的使用">2.8 结构体的使用</h2><h3 id="2-8-1-结构体的定义">2.8.1 结构体的定义</h3><p>一个例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span><br>&#123;<br>    <span class="hljs-type">char</span> name;<br>    <span class="hljs-type">int</span> count;<br>&#125;spot;<br></code></pre></td></tr></table></figure><p>定义结构体变量的方式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span><br>&#123;<br>    <span class="hljs-type">char</span> name;<br>    <span class="hljs-type">int</span> count;<br>&#125;spot;<br>spot A;<br>spot B;<br>spot str[<span class="hljs-number">100</span>];<br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">spot</span><br>&#123;<br>    <span class="hljs-type">char</span> name;<br>    <span class="hljs-type">int</span> count;<br>&#125;A, B, str[<span class="hljs-number">100</span>];<br></code></pre></td></tr></table></figure><p><strong>结构体里面不能定义自己本身，但是可以定义自身类型的指针变量</strong><br>一个例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-comment">// 定义一个链表节点结构体</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br> <span class="hljs-type">int</span> data;           <span class="hljs-comment">// 节点数据</span><br> Node* next;         <span class="hljs-comment">// 指向下一个节点的指针</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br> <span class="hljs-comment">// 创建链表节点</span><br> Node* head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>();<br> head-&gt;data = <span class="hljs-number">1</span>;<br> head-&gt;next = <span class="hljs-literal">nullptr</span>;<br><br> Node* second = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>();<br> second-&gt;data = <span class="hljs-number">2</span>;<br> second-&gt;next = <span class="hljs-literal">nullptr</span>;<br><br> Node* third = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>();<br> third-&gt;data = <span class="hljs-number">3</span>;<br> third-&gt;next = <span class="hljs-literal">nullptr</span>;<br><br> <span class="hljs-comment">// 将节点连接起来</span><br> head-&gt;next = second;<br> second-&gt;next = third;<br><br> <span class="hljs-comment">// 遍历链表并输出数据</span><br> Node* current = head;<br> <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">nullptr</span>) &#123;<br>     std::cout &lt;&lt; current-&gt;data &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>     current = current-&gt;next;<br> &#125;<br><br> <span class="hljs-comment">// 释放链表内存</span><br> <span class="hljs-keyword">delete</span> head;<br> <span class="hljs-keyword">delete</span> second;<br> <span class="hljs-keyword">delete</span> third;<br><br> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-8-2-访问结构体内的元素">2.8.2 访问结构体内的元素</h3><p>两种方法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">StudentInfo</span>&#123;<br>    <span class="hljs-type">int</span> id;<br>    <span class="hljs-type">char</span> name[<span class="hljs-number">20</span>];<br>    studentInto *next;<br>&#125;stu, *p;<br></code></pre></td></tr></table></figure><p>访问变量写法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">stu.id<br>stu.name<br>stu.next<br></code></pre></td></tr></table></figure><p>而访问指针变量p</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">(*p).id <span class="hljs-comment">//先解引用为一个struct变量</span><br>(*p).<span class="hljs-built_in">name</span><br>(*p).next <br></code></pre></td></tr></table></figure><p>另一种写法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">p-&gt;id<br>p-&gt;name<br>p-&gt;next<br></code></pre></td></tr></table></figure><p>赋值的写法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">stu.id = <span class="hljs-number">10086</span>;<br><span class="hljs-type">int</span> getID = stu.id;<br></code></pre></td></tr></table></figure><h3 id="2-8-3-结构体的初始化">2.8.3 结构体的初始化</h3><p>使用<strong>构造函数</strong>，一种用来初始化结构体的函数，有如下几个特征</p><ol><li>直接定义在结构体中</li><li>不需要写返回类型</li><li>函数名与结构体名相同</li><li>默认生成，无形参，无函数体，需要自己写</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">StudentInfo</span> &#123;<br>    <span class="hljs-type">int</span> id;<br>    <span class="hljs-type">char</span> gender;<br><br>    <span class="hljs-comment">//用以不初始化就定义结构体变量</span><br>    <span class="hljs-built_in">StudentInfo</span>()&#123;&#125;<br>    <span class="hljs-comment">// 构造函数，用于初始化结构体内部变量</span><br>    <span class="hljs-built_in">StudentInfo</span>(<span class="hljs-type">int</span> _id, <span class="hljs-type">char</span> _gender) &#123;<br>        id = _id;<br>        gender = _gender;<br>    &#125;<br>    <span class="hljs-comment">/* 另一种写法，使用成员初始化列表</span><br><span class="hljs-comment">    StudentInfo(int _id, char _gender) : id(_id), gender(_gender) &#123;&#125;</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-comment">//只初始化gender</span><br>    <span class="hljs-built_in">StudentInfo</span>(<span class="hljs-type">char</span> _gender)&#123;<br>        gender = _gender;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function">StudentInfo <span class="hljs-title">student</span><span class="hljs-params">(<span class="hljs-number">12345</span>, <span class="hljs-string">&#x27;M&#x27;</span>)</span></span>;<br></code></pre></td></tr></table></figure><p><strong>只要参数个数与类型不完全相同，就可以任意定义多个构造函数，以适应不同的初始化场合。</strong><br><strong>注意：正是因为没有自己重新定义的构造函数什么都没有，才能够不经初始化就定义结构体变量（思考不初始化构造函数时候是怎么定义的？），所以如果自己重新定义了构造函数，就不能不经过初始化就定义结构体变量！</strong></p><h2 id="2-9-补充">2.9 补充</h2><h3 id="2-9-1-cin和cout">2.9.1 cin和cout</h3><ol><li>cin的输入不指定格式，也不需要加取地址运算符&amp;，直接写变量名就可以了<br>同时读入多个变量的方法</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cin&gt;&gt;n&gt;&gt;db&gt;&gt;c&gt;&gt;str;<br></code></pre></td></tr></table></figure><p>如果想要读入一整行，使用getline函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> str[<span class="hljs-number">100</span>];<br>cin.<span class="hljs-built_in">getline</span>(str,<span class="hljs-number">100</span>);<br></code></pre></td></tr></table></figure><blockquote><p><code>getline</code> 是 C++ 标准库中的一个函数，用于从输入流（如 <code>cin</code>）中读取一行文本。<br>与 <code>cin</code> 的 <code>&gt;&gt;</code> 操作符不同，<code>getline</code> 可以读取包含空格的整行文本，直到遇到换行符（<code>\n</code>）为止。</p><h3 id="语法">语法</h3><p><code>getline</code> 函数的基本语法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::<span class="hljs-built_in">getline</span>(std::cin, string_variable);<br></code></pre></td></tr></table></figure><ul><li><code>std::cin</code>：输入流对象，通常是标准输入流。</li><li><code>string_variable</code>：一个 <code>std::string</code> 类型的变量，用于存储读取的文本。</li></ul><h3 id="示例">示例</h3><p>以下是一个简单的示例，展示了如何使用 <code>getline</code> 函数搭配 <code>cin</code> 读取用户输入的一行文本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::string name;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;请输入你的名字：&quot;</span>;<br>    std::<span class="hljs-built_in">getline</span>(std::cin, name);<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;你好，&quot;</span> &lt;&lt; name &lt;&lt; <span class="hljs-string">&quot;！&quot;</span> &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="解释">解释</h3><ol><li><p><strong>包含头文件</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br></code></pre></td></tr></table></figure><p>包含必要的头文件，<code>&lt;iostream&gt;</code> 用于输入输出流操作，<code>&lt;string&gt;</code> 用于使用 <code>std::string</code> 类型。</p></li><li><p><strong>定义字符串变量</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::string name;<br></code></pre></td></tr></table></figure><p>定义一个 <code>std::string</code> 类型的变量 <code>name</code>，用于存储用户输入的文本。</p></li><li><p><strong>提示用户输入</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::cout &lt;&lt; <span class="hljs-string">&quot;请输入你的名字：&quot;</span>;<br></code></pre></td></tr></table></figure><p>使用 <code>std::cout</code> 输出提示信息，要求用户输入名字。</p></li><li><p><strong>读取用户输入</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::<span class="hljs-built_in">getline</span>(std::cin, name);<br></code></pre></td></tr></table></figure><p>使用 <code>std::getline</code> 函数从 <code>std::cin</code> 读取一行文本，并将其存储在 <code>name</code> 变量中。</p></li><li><p><strong>输出结果</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::cout &lt;&lt; <span class="hljs-string">&quot;你好，&quot;</span> &lt;&lt; name &lt;&lt; <span class="hljs-string">&quot;！&quot;</span> &lt;&lt; std::endl;<br></code></pre></td></tr></table></figure><p>使用 <code>std::cout</code> 输出欢迎信息，其中包含用户输入的名字。</p></li></ol><h3 id="注意事项-2">注意事项</h3><ul><li><strong>读取整行文本</strong>：<code>getline</code> 函数会读取整行文本，包括空格和制表符，直到遇到换行符（<code>\n</code>）为止。</li><li><strong>处理换行符</strong>：<code>getline</code> 会自动处理换行符，不会将其包含在读取的文本中。</li><li><strong>与 <code>cin &gt;&gt;</code> 的区别</strong>：<code>cin &gt;&gt;</code> 操作符在读取字符串时会忽略空格和换行符，只读取第一个非空白字符到下一个空白字符之间的内容。</li></ul><h3 id="总结">总结</h3><p><code>getline</code> 函数是一个非常有用的工具，特别是在需要读取包含空格的整行文本时。<br>通过搭配 <code>cin</code>，你可以方便地从用户输入中读取一行文本，并进行后续处理。<br>char str[100];<br>cin.getline(str,100);</p></blockquote><ol start="2"><li>cout 控制精度好麻烦，还不如scanf,printf</li></ol><h3 id="2-9-2-浮点数的比较">2.9.2 浮点数的比较</h3><p>引入一个小量eps来对计算机的浮点误差进行修正，再通过一系列的宏定义来实现修正误差的程序<br>一般取</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-8</span>;<br></code></pre></td></tr></table></figure><p>核心部分(画几个数轴来理解)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">double</span> eps=<span class="hljs-number">1e-8</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> PI=<span class="hljs-built_in">acos</span>(<span class="hljs-number">-1.0</span>)<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> Equ(a,b) ((fabs((a)-(b)))&lt;(eps))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> More(a,b) (((a)-(b))&gt;(eps))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> Less(a,b) (((a)-(b))&lt;(-eps))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MoreEqu(a,b) (((a)-(b))&gt;(-eps))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LessEqu(a,b) (((a)-(b))&lt;(eps))</span><br></code></pre></td></tr></table></figure><p><strong>由于精度问题，可能一个0在经过一系列运算之后变为一个很小的负数了，那么这个时候进行一些运算比如sqrt就会报错，那么这个时候就需要用eps保证变量本身在定义域内</strong><br>比如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><br><span class="hljs-type">const</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-9</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">double</span> x = <span class="hljs-number">-1e-15</span>;<br><br>    <span class="hljs-comment">// 确保 x 在定义域内</span><br>    <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span>) &#123;<br>        x = eps;<br>    &#125;<br><br>    <span class="hljs-comment">// 计算平方根</span><br>    <span class="hljs-type">double</span> result = std::<span class="hljs-built_in">sqrt</span>(x);<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;sqrt(&quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;) = &quot;</span> &lt;&lt; result &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-9-3-复杂度">2.9.3 复杂度</h3><h4 id="时间复杂度">时间复杂度</h4><p>定义：算法需要执行基本运算的次数所处的等级<br>基本运算：加减乘除之类可以直接执行的运算</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>    sum+=i;<br>&#125;<br></code></pre></td></tr></table></figure><p>for循环执行了n次，时间复杂度为O(n)，也就是线性增长</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>        sum+=arr[i][j];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>基本运算次数为$n^{2}$次，因此时间复杂度为O($n^{2}$)<br>类似无穷小，高等级的幂次会覆盖低等级的幂次<br>评估时间复杂度：一般OJ系统一秒能承受的运算次数大概是$10^{7}$到$10^{8}$，以此作为判断依据</p><p>####　空间复杂度</p><p>表示算法需要消耗的最大空间，但是一般都是空间够时间不够，所以可以以时间换空间</p><h4 id="编码复杂度">编码复杂度</h4><p>就是看你觉得代码是不是很复杂了，比较泛泛而又定性的一个概念</p><h2 id="2-10-黑盒测试">2.10 黑盒测试</h2><p>建议直接回去看书，不过这里有一点是值得提一下的<br>scanf()函数其实是有返回值的，返回值也就是传入参数的数量，而当没有参数传入时会返回-1，而且可以用EOF来代表-1</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a)!=EOF)&#123;<br>    ......<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-11-lambda表达式">2.11 lambda表达式</h2><p><strong>lambda表达式</strong>是一种可以在代码中<strong>随时声明的匿名函数</strong>。换句话说，lambda表达式允许你直接在需要使用函数的地方声明一个临时的函数，而不需要先定义它。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">[捕获列表](参数列表) -&gt; 返回类型 &#123; 函数体 &#125;;<br></code></pre></td></tr></table></figure><ul><li><strong>捕获列表</strong>：这个让lambda可以访问外部变量。</li><li><strong>参数列表</strong>：就像普通函数的参数列表。</li><li><strong>返回类型</strong>：这个可以省略，编译器会自动推导返回类型。</li><li><strong>函数体</strong>：lambda的真正执行内容，就像一个小型的函数。</li></ul><p>一个例子，假设需要在代码中临时计算两个数字的乘积：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-type">int</span> x,y;<br>  <span class="hljs-keyword">auto</span> multiply=[](<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)-&gt;<span class="hljs-type">int</span>&#123;<br>    <span class="hljs-keyword">return</span> a*b;<br>  &#125;<br>  cout&lt;&lt;<span class="hljs-built_in">multiply</span>(x,y)&lt;&lt;endl;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这段代码中，我们通过 <code>auto multiply = [](int a, int b) -&gt; int &#123; return a * b; &#125;;</code> 创建了一个lambda表达式，这个lambda函数接受两个参数 <code>a</code> 和 <code>b</code>，并返回它们的乘积。然后我们调用 <code>multiply(x, y)</code>，输出结果。</p><p>再来一个例子：判断一个函数是否是偶数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> isEven=[](<span class="hljs-type">int</span> x)-&gt;<span class="hljs-type">bool</span>&#123;<span class="hljs-keyword">return</span> x%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>;&#125;<br></code></pre></td></tr></table></figure><p><strong>关于捕获列表</strong></p><p>捕获列表决定了lambda能够访问哪些外部变量，并且是否以值或引用的方式捕获它们。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-type">int</span> factor=<span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">auto</span> multiplyByFactor=[factor](<span class="hljs-type">int</span> x)-&gt;<span class="hljs-type">int</span>&#123;<span class="hljs-keyword">return</span> x*factor;&#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，lambda表达式 <code>multiplyByFactor</code> 捕获了外部变量 <code>factor</code>，并在它的函数体中使用它。捕获列表 <code>[factor]</code> 让lambda能够“记住”这个变量的值，即使是在函数调用时这个值已经改变了。</p><h3 id="lambda表达式的一些特殊使用">lambda表达式的一些特殊使用</h3><h4 id="存储到变量中并调用">存储到变量中并调用</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 将 lambda 表达式存储在变量中</span><br>    <span class="hljs-keyword">auto</span> printMessage = []() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Hello, World!&quot;</span> &lt;&lt; std::endl;<br>    &#125;;<br><br>    <span class="hljs-comment">// 在后面需要的时候调用它</span><br>    <span class="hljs-built_in">printMessage</span>(); <span class="hljs-comment">// 输出: Hello, World!</span><br>    <span class="hljs-built_in">printMessage</span>(); <span class="hljs-comment">// 可以多次调用</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="返回值为-Lambda-表达式">返回值为 Lambda 表达式</h4><p>可以编写一个函数，返回一个 lambda 表达式供后续调用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">createMultiplier</span><span class="hljs-params">(<span class="hljs-type">int</span> factor)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> [factor](<span class="hljs-type">int</span> x) &#123; <span class="hljs-keyword">return</span> x * factor; &#125;;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> doubleValue = <span class="hljs-built_in">createMultiplier</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// 创建一个将值乘以2的 lambda</span><br>    <span class="hljs-keyword">auto</span> tripleValue = <span class="hljs-built_in">createMultiplier</span>(<span class="hljs-number">3</span>); <span class="hljs-comment">// 创建一个将值乘以3的 lambda</span><br><br>    std::cout &lt;&lt; <span class="hljs-built_in">doubleValue</span>(<span class="hljs-number">5</span>) &lt;&lt; std::endl; <span class="hljs-comment">// 输出: 10</span><br>    std::cout &lt;&lt; <span class="hljs-built_in">tripleValue</span>(<span class="hljs-number">5</span>) &lt;&lt; std::endl; <span class="hljs-comment">// 输出: 15</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>在 C++ 的 lambda 表达式中，<code>[&amp;]</code> 表示<strong>按引用捕获</strong>所有在 lambda 函数体中使用到的外部变量。这意味着：</p><ul><li>如果在 lambda 内部使用了外部变量，那么该变量是以引用的方式捕获的。</li><li>你在 lambda 内对这些变量的修改会直接影响到它们在外部的值。</li></ul><h3 id="示例-2">示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">5</span>, b = <span class="hljs-number">10</span>;<br>    <br>    <span class="hljs-comment">// 定义一个 lambda 表达式，按引用捕获所有外部变量</span><br>    <span class="hljs-keyword">auto</span> func = [&amp;]() &#123;<br>        a += <span class="hljs-number">1</span>;<br>        b += <span class="hljs-number">1</span>;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Inside lambda: a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot;, b = &quot;</span> &lt;&lt; b &lt;&lt; std::endl;<br>    &#125;;<br>    <br>    <span class="hljs-built_in">func</span>();  <span class="hljs-comment">// 调用 lambda 表达式</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Outside lambda: a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot;, b = &quot;</span> &lt;&lt; b &lt;&lt; std::endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="输出：">输出：</h4><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Inside</span> lambda: a = <span class="hljs-number">6</span>, b = <span class="hljs-number">11</span><br><span class="hljs-attribute">Outside</span> lambda: a = <span class="hljs-number">6</span>, b = <span class="hljs-number">11</span><br></code></pre></td></tr></table></figure><p>如上所示，由于 <code>[&amp;]</code> 按引用捕获，所以 lambda 内对 <code>a</code> 和 <code>b</code> 的修改会直接影响外部的变量。</p><h3 id="与其他捕获方式的对比">与其他捕获方式的对比</h3><ul><li><code>[=]</code>：按值捕获所有外部变量，lambda 内对变量的修改不会影响外部变量。</li><li><code>[a, &amp;b]</code>：对变量 <code>a</code> 按值捕获，对变量 <code>b</code> 按引用捕获。这种方式可以混合使用捕获方式。</li></ul><p>总结一下，<code>[&amp;]</code> 是一种便捷的捕获方式，当你需要在 lambda 内使用外部变量并希望能直接修改它们时，这种方式非常有用。</p></blockquote><h1>第4章 入门篇（2）——算法初步</h1><h2 id="4-1-排序">4.1 排序</h2><h3 id="4-1-1-选择排序">4.1.1 选择排序</h3><h3 id="4-1-2-插入排序">4.1.2 插入排序</h3><h3 id="4-1-3-排序题与sort函数的应用">4.1.3 排序题与sort函数的应用</h3><blockquote><p>当然可以！<code>std::sort</code> 中的比较函数用于定义排序的顺序。比较函数需要返回一个布尔值，表示两个元素的相对顺序。具体来说，比较函数应该满足以下条件：</p><ol><li><p><strong>严格弱序（Strict Weak Ordering）</strong>：比较函数必须定义一个严格弱序关系，这意味着它必须满足以下条件：</p><ul><li><strong>反自反性（Irreflexivity）</strong>：对于所有 <code>x</code>，<code>comp(x, x)</code> 必须返回 <code>false</code>。</li><li><strong>反对称性（Antisymmetry）</strong>：如果 <code>comp(x, y)</code> 返回 <code>true</code>，那么 <code>comp(y, x)</code> 必须返回 <code>false</code>。</li><li><strong>传递性（Transitivity）</strong>：如果 <code>comp(x, y)</code> 返回 <code>true</code> 且 <code>comp(y, z)</code> 返回 <code>true</code>，那么 <code>comp(x, z)</code> 必须返回 <code>true</code>。</li></ul></li><li><p><strong>一致性（Consistency）</strong>：如果 <code>comp(x, y)</code> 和 <code>comp(y, x)</code> 都返回 <code>false</code>，那么 <code>x</code> 和 <code>y</code> 被认为是相等的。</p></li></ol><h3 id="示例：比较整数">示例：比较整数</h3><p>假设我们有一个整数数组，我们希望按升序排序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span>  <span class="hljs-comment">// 包含 std::sort</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span>     <span class="hljs-comment">// 包含 std::vector</span></span><br><br><span class="hljs-comment">// 比较函数：按升序排序</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">compareAscending</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a &lt; b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; numbers = &#123;<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;;<br><br>    std::<span class="hljs-built_in">sort</span>(numbers.<span class="hljs-built_in">begin</span>(), numbers.<span class="hljs-built_in">end</span>(), compareAscending);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> number : numbers) &#123;<br>        std::cout &lt;&lt; number &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><h3 id="示例：比较字符串">示例：比较字符串</h3><p>假设我们有一个字符串数组，我们希望按字典序（字母顺序）排序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span>  <span class="hljs-comment">// 包含 std::sort</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span>     <span class="hljs-comment">// 包含 std::vector</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span>     <span class="hljs-comment">// 包含 std::string</span></span><br><br><span class="hljs-comment">// 比较函数：按字典序排序</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">compareLexicographically</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;a, <span class="hljs-type">const</span> std::string &amp;b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a &lt; b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;std::string&gt; names = &#123;<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-string">&quot;Charlie&quot;</span>, <span class="hljs-string">&quot;David&quot;</span>, <span class="hljs-string">&quot;Eve&quot;</span>&#125;;<br><br>    std::<span class="hljs-built_in">sort</span>(names.<span class="hljs-built_in">begin</span>(), names.<span class="hljs-built_in">end</span>(), compareLexicographically);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;name : names) &#123;<br>        std::cout &lt;&lt; name &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">Alice Bob Charlie David Eve</span><br></code></pre></td></tr></table></figure><h3 id="示例：比较结构体">示例：比较结构体</h3><p>假设我们有一个包含学生信息的结构体数组，我们希望按年龄排序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span>  <span class="hljs-comment">// 包含 std::sort</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span>     <span class="hljs-comment">// 包含 std::vector</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span>     <span class="hljs-comment">// 包含 std::string</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Student</span> &#123;<br>    std::string name;<br>    <span class="hljs-type">int</span> age;<br>    <span class="hljs-type">float</span> gpa;<br>&#125;;<br><br><span class="hljs-comment">// 比较函数：按年龄排序</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">compareStudentsByAge</span><span class="hljs-params">(<span class="hljs-type">const</span> Student &amp;a, <span class="hljs-type">const</span> Student &amp;b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a.age &lt; b.age;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;Student&gt; students = &#123;<br>        &#123;<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">20</span>, <span class="hljs-number">3.8</span>&#125;,<br>        &#123;<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">22</span>, <span class="hljs-number">3.5</span>&#125;,<br>        &#123;<span class="hljs-string">&quot;Charlie&quot;</span>, <span class="hljs-number">21</span>, <span class="hljs-number">3.7</span>&#125;,<br>        &#123;<span class="hljs-string">&quot;David&quot;</span>, <span class="hljs-number">19</span>, <span class="hljs-number">3.9</span>&#125;,<br>        &#123;<span class="hljs-string">&quot;Eve&quot;</span>, <span class="hljs-number">23</span>, <span class="hljs-number">3.6</span>&#125;<br>    &#125;;<br><br>    std::<span class="hljs-built_in">sort</span>(students.<span class="hljs-built_in">begin</span>(), students.<span class="hljs-built_in">end</span>(), compareStudentsByAge);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;student : students) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Name: &quot;</span> &lt;&lt; student.name &lt;&lt; <span class="hljs-string">&quot;, Age: &quot;</span> &lt;&lt; student.age &lt;&lt; <span class="hljs-string">&quot;, GPA: &quot;</span> &lt;&lt; student.gpa &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Name: David, Age: <span class="hljs-number">19</span>, GPA: <span class="hljs-number">3.9</span><br>Name: Alice, Age: <span class="hljs-number">20</span>, GPA: <span class="hljs-number">3.8</span><br>Name: Charlie, Age: <span class="hljs-number">21</span>, GPA: <span class="hljs-number">3.7</span><br>Name: Bob, Age: <span class="hljs-number">22</span>, GPA: <span class="hljs-number">3.5</span><br>Name: Eve, Age: <span class="hljs-number">23</span>, GPA: <span class="hljs-number">3.6</span><br></code></pre></td></tr></table></figure><h3 id="示例：多条件比较">示例：多条件比较</h3><p>假设我们希望在年龄相同的情况下，按 GPA 排序，如果 GPA 也相同，则按名字排序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span>  <span class="hljs-comment">// 包含 std::sort</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span>     <span class="hljs-comment">// 包含 std::vector</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span>     <span class="hljs-comment">// 包含 std::string</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Student</span> &#123;<br>    std::string name;<br>    <span class="hljs-type">int</span> age;<br>    <span class="hljs-type">float</span> gpa;<br>&#125;;<br><br><span class="hljs-comment">// 比较函数：按年龄、GPA、名字排序</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">compareStudents</span><span class="hljs-params">(<span class="hljs-type">const</span> Student &amp;a, <span class="hljs-type">const</span> Student &amp;b)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (a.age != b.age) &#123;<br>        <span class="hljs-keyword">return</span> a.age &lt; b.age;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (a.gpa != b.gpa) &#123;<br>        <span class="hljs-keyword">return</span> a.gpa &gt; b.gpa;  <span class="hljs-comment">// 按 GPA 降序排序</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> a.name &lt; b.name;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;Student&gt; students = &#123;<br>        &#123;<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">20</span>, <span class="hljs-number">3.8</span>&#125;,<br>        &#123;<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">22</span>, <span class="hljs-number">3.5</span>&#125;,<br>        &#123;<span class="hljs-string">&quot;Charlie&quot;</span>, <span class="hljs-number">21</span>, <span class="hljs-number">3.7</span>&#125;,<br>        &#123;<span class="hljs-string">&quot;David&quot;</span>, <span class="hljs-number">19</span>, <span class="hljs-number">3.9</span>&#125;,<br>        &#123;<span class="hljs-string">&quot;Eve&quot;</span>, <span class="hljs-number">23</span>, <span class="hljs-number">3.6</span>&#125;<br>    &#125;;<br><br>    std::<span class="hljs-built_in">sort</span>(students.<span class="hljs-built_in">begin</span>(), students.<span class="hljs-built_in">end</span>(), compareStudents);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;student : students) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Name: &quot;</span> &lt;&lt; student.name &lt;&lt; <span class="hljs-string">&quot;, Age: &quot;</span> &lt;&lt; student.age &lt;&lt; <span class="hljs-string">&quot;, GPA: &quot;</span> &lt;&lt; student.gpa &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Name: David, Age: <span class="hljs-number">19</span>, GPA: <span class="hljs-number">3.9</span><br>Name: Alice, Age: <span class="hljs-number">20</span>, GPA: <span class="hljs-number">3.8</span><br>Name: Charlie, Age: <span class="hljs-number">21</span>, GPA: <span class="hljs-number">3.7</span><br>Name: Bob, Age: <span class="hljs-number">22</span>, GPA: <span class="hljs-number">3.5</span><br>Name: Eve, Age: <span class="hljs-number">23</span>, GPA: <span class="hljs-number">3.6</span><br></code></pre></td></tr></table></figure><h3 id="总结-2">总结</h3><p>比较函数是 <code>std::sort</code> 的核心部分，它决定了排序的顺序。比较函数需要返回一个布尔值，表示两个元素的相对顺序。通过编写不同的比较函数，你可以实现各种排序需求。</p></blockquote><h4 id="1-相关结构体的定义">1. 相关结构体的定义</h4><p>排序题一般会给出个体的许多信息，为了方便常常把这些信息统统存在一个结构体中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Student</span>&#123;<br><span class="hljs-type">char</span> name[<span class="hljs-number">10</span>];<br><span class="hljs-type">char</span> id[<span class="hljs-number">10</span>];<br><span class="hljs-type">int</span> score;<br>&#125;stu[<span class="hljs-number">100100</span>];<br></code></pre></td></tr></table></figure><h4 id="2-cmp函数的编写-strcmp函数依据字典序返回两个字符串大小的比较结果">2.cmp函数的编写(strcmp函数依据字典序返回两个字符串大小的比较结果)</h4><p>比如一个排序规则：如果两个学生分数不相同那么分数高的排在前面，否则将姓名字典序小的排在前面<br>就可以写出这样的cmp函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(Student a,Student b)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(a.score!=b.score) <span class="hljs-keyword">return</span> a.score&gt;b.score;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">strcmp</span>(a.name,b.name)&lt;<span class="hljs-number">0</span>;<br>&#125;<span class="hljs-comment">//注意strcmp的返回值不一定是1或者-1，与IDE有关</span><br></code></pre></td></tr></table></figure><h4 id="3-排名的实现">3.排名的实现</h4><p>规则一般是：分数不同的排名不同，分数相同的排名相同但是占用一个排位</p><p>对这种要求一般需要在结构体类型定义的时候就把排名这一项加入结构体中，于是在数序排序完成之后就有两种方法来实现排名的计算</p><ol><li><p>先将数组第一个个体排名记作1（这个个体数组下标为0），然后遍历剩余的个体：</p><ul><li>如果当前个体的分数等于上一个个体的分数，那么当前个体的排名=上一个个体的排名</li><li>否则，当前个体的排名=数组下标+1</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp">stu[<span class="hljs-number">0</span>].r=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>    <span class="hljs-keyword">if</span>(stu[i].score==stu.[i<span class="hljs-number">-1</span>].score)&#123;<br>        stu[i].r=stu[i<span class="hljs-number">-1</span>].r;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        stu[i].r=i<span class="hljs-number">+1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>而有些时候也不一定需要记下来排名，直接输出就好了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> r=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>    <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span>&amp;&amp;stu[i].score!=stu[i<span class="hljs-number">-1</span>].score)&#123;<br>        r=i<span class="hljs-number">+1</span>;<br>    &#125;<br>    <span class="hljs-comment">//输出当前个体信息</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="4-2-散列">4.2 散列</h2><h3 id="4-2-1-散列的定义与整数散列">4.2.1 散列的定义与整数散列</h3><p>散列(hash)是一种常用的算法思想</p><p>比如用hashTable的bool/int数组去判断一个数是否出现过  即:<strong>把输入的数作为数组的下标来对这个数的性质进行统计</strong>,是一个很好的以空间换时间的策略,因为查询的复杂度是O(1)</p><p>下面我们给出hash的定义，可以浓缩成一句话：<strong>将元素通过一个函数转换为整数，使得该整数可以尽量唯一地代表这个元素</strong>，其中这个转换函数被称为<strong>散列函数H</strong></p><p>即：如果元素在转换前为key，那么转换之后就是一个整数H(key),再把转换完的hash值用一个数组去记录</p><p>对于<strong>key为整数</strong>的情况：常用的散列函数有：</p><ul><li><p>直接定址法：H(key)=key 或者 H(key)=a*key+b做一个线性变换</p></li><li><p>平方取中法：取key的平方中间的若干位作为hash值</p></li><li><p>除留余数法：把key除以一个数mod得到的余数作为hash值的方法，即<strong>H(key)=key%mod</strong></p><p>通过这个散列函数可以把很大的数转化为不超过mod的整数，这样就可以把它视为可行的数组下标(需要注意表长&gt;=mod)。显然当mod是一个素数时，H(key)尽可能覆盖[0,mod)范围内的每一个数。因此一般为了方便起见取TSize为一个素数，而mod直接取成与TSize相等</p><p>但是很容易注意到这个方法可能会有两个不同的数key1与key2使得H(key1)==H(key2)，这种情况叫**“冲突”**</p><p>下面有三种方法解决冲突，其中第一种和第二种方法都计算了新的hash值，又称为开放定址法</p><ol><li><p>线性探查法：当得到 key 的 hash 值 H(key),但是表中下标为 H(key)的位置已经被某个其他元素使用了那么就检査下一个位置H(key)+1是否被占，如果没有，就使用这个位置;否则就继续检查下一个位置(也就是将hash值不断加1)。如果检查过程中超过了表长，那么就回到表的首位继续循环，直到找到一个可以使用的位置，或者是发现表中所有位置都已被使用。显然，这个做法容易导致扎堆，即表中连续若于个位置都被使用，这在一定程度上会降低效率。</p></li><li><p>平方探査法：在平方探查法中，为了尽可能避免扎堆现象，当表中下标为H(key)的位置被占时，将按下面的顺序检査表中的位置:H(key)+$1^{2}$、H(key)-$1^{2}$、H(key)+ $2^{2}$、H(key)- $2^{2}$、H(key)+ $3^{2}$…。如果检査过程中 H(key)+$k^{2}$超过了表长 TSize，那么就把 H(key)+$k^{2}$对表长 TSize 取模;</p><p>如果检查过程中出现 H(key)-$k^{2}$&lt;0的情况(假设表的首位为 0),那么将((H(key)-$k^{2}$)% TSize+ TSize)% TSize作为结果(等价于将H(key)-$k^{2}$不断加上 TSize 直到出现第一个非负数)。如果想避免负数的麻烦，可以只进行正向的平方探查。可以证明，如果k在[0,TSize)范围内都无法找到位置，那么当k&gt;TSize时，也一定无法找到位置。</p></li><li><p>链地址法（拉链法）：和上面两种方法不同，链地址法不计算新的 hash 值，而是把所有 H(key)相同的 key 连接成一条单链表(可以在学习完7.3小节后回过头来看)。这样可以设定一个数组Link，范围是Link[0]~ Link[mod]，其中 Link[h]存放 H(key)=h的一条单链表，于是当多个关键字 key 的hash 值都是h时，就可以直接把这些冲突的key直接用单链表连接起来，此时就可以遍历这条单链表来寻找所有H(key)=h的key。<br>当然，一般来说，可以使用标准库模板库中的map(见6.4节)来直接使用hash的功能(C++11 以后可以用unordered map，速度更快)，因此除非必须模拟这些方法或是对算法的效率要求比较高，一般不需要自己实现上面解决冲突的方法。</p></li></ol></li></ul><h3 id="4-2-2-字符串hash初步">4.2.2 字符串hash初步</h3><p>如果key不是整数，该如何设计散列函数？</p><p>一个例子是:如何将一个二维整点P的坐标映射为一个整数，使得整点P可以由该整数唯一地代表。假设一个整点P的坐标是(x,y)，其中 0&lt;x,y&lt;Range，那么可以令 hash 函数为H(P)=x*Range+y，这样对数据范围内的任意两个整点P1与P2,H(P1)都不会等于 H(P2),就可以用 H(P)来唯一地代表该整点P,接着便可以通过整数 hash 的方法来进一步映射到较小的范围。<br>本节的重点在于字符串hash。**字符串hash是指将一个字符串S映射为一个整数，使得该整数可以尽可能唯一地代表字符串S。**本节只讨论将字符串转换为唯一的整数，进阶部分在12.1节。</p><p>为了讨论问题方便，先假设字符串均由大写字母A~Z构成。在这个基础上，不妨把A~Z视为0~25，这样就把 26个大写字母对应到了二十六进制中。接着，按照将二十六进制转换为十进制的思路，由进制转换的结论可知，在进制转换过程中，得到的十进制肯定是唯一的，由此便可实现将字符串映射为整数的需求(注意:转换成的整数最大为是$26^{len}$-1(len为字符串长度)，代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">hashFunc</span><span class="hljs-params">(<span class="hljs-type">char</span> s[],<span class="hljs-type">int</span> len)</span></span>&#123; <span class="hljs-comment">//hash函数，将字符串S转换为整数</span><br>    <span class="hljs-type">int</span> id=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>        id=id*<span class="hljs-number">26</span>+(s[i]-<span class="hljs-string">&#x27;A&#x27;</span>); <span class="hljs-comment">//将26进制转化为10进制</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> id;<br>&#125;<br></code></pre></td></tr></table></figure><p>显然len不能太长了，如果里面还有小写字母可以把26进制变成52进制，也是一样的</p><p>而如果出现了数字，一般有两种处理方法:<br>① 按照小写字母的处理方法，增大进制数至 62。</p><p>②如果保证在字符串的末尾是确定个数的数字,那么就可以把前面英文字母的部分按上面的思路转换成整数，再将末尾的数字直接拼接上去。例如对由三个字符加一位数字组成的字符串“BCD4”来说，就可以先将前面的“BCD”转换为整数731，然后直接拼接上末位的4变为7314即可。下面的代码体现了这个例子:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">hashFunc</span><span class="hljs-params">(<span class="hljs-type">char</span> s[],<span class="hljs-type">int</span> len)</span></span>&#123; <span class="hljs-comment">//hash函数，将字符串S转换为整数</span><br>    <span class="hljs-type">int</span> id=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len<span class="hljs-number">-1</span>;i++)&#123;<br>        id=id*<span class="hljs-number">26</span>+(s[i]-<span class="hljs-string">&#x27;A&#x27;</span>); <span class="hljs-comment">//将26进制转化为10进制</span><br>    &#125;<br>    id=id*<span class="hljs-number">10</span>+(s[len]-<span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-keyword">return</span> id;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-3-递归">4.3 递归</h2><h3 id="4-3-1-分治">4.3.1 分治</h3><p>分治全称：分而治之，也就是<strong>将原问题划分成若干个规模较小而结构与原问题相同或相似的子问题，然后分别解决这些子问题，最后合并子问题的解，即可得到原问题的解</strong>，也就是说分治法可以分为三步</p><ol><li>分解</li><li>解决</li><li>合并</li></ol><p>需要指出的是分治法分解出的子问题应该是相互独立而没有交叉的，如果存在两个子问题有交叉部分，那么就不应该用分治法求解</p><p>特别地，把子问题个数为1的情况称之为减治</p><p>分治作为一种算法思想，<strong>既可以使用递归的手段去实现，也可以同非递归的手段去实现</strong>，不过视情况而定</p><h3 id="4-3-2-递归">4.3.2 递归</h3><p><strong>在编写递归函数的时候，可以当系统库里有一个同名的函数可以实现所需要的功能；当函数编写完成之后，逻辑也就自洽了</strong></p><p>递归，在于反复调用自身函数，但是每次把问题范围缩小，直到范围缩小到可以直接得到边界数据的结果，然后再在返回的路上求出对应的解，这样看来<strong>递归很适合实现分治思想</strong></p><blockquote><p>写递归的时候不要陷入无尽的分析子过程，分析好边界条件，写好本过程要处理什么东西，然后剩下的就是相信子过程能处理好你的求解问题就行了。和数学归纳法一个套路</p></blockquote><ul><li>确定问题</li><li>解决基准问题</li><li>拆解问题</li></ul><p>递归的逻辑中一般有两个重要概念</p><ol><li>递归边界</li><li>递归式（或称递归调用）</li></ol><p>给出一个例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//计算n的阶乘</span><br><span class="hljs-comment">//考虑n!的计算式，不难得出递归式F(n)=nF(n-1)</span><br><span class="hljs-comment">//所以可以把F(n)变成F(n-1),然后一直递归下去...</span><br><span class="hljs-comment">//什么时候是尽头呢?考虑0!=1,不妨以F(0)=1作为递归边界</span><br><span class="hljs-comment">//即:规模减小到n=0的时候开始&quot;回头&quot;</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">F</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">//到达递归边界时返回</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> n*<span class="hljs-built_in">F</span>(n<span class="hljs-number">-1</span>); <span class="hljs-comment">//没有到达边界时使用递归式递归下去</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="C:%5CUsers%5Cendle%5Chexo-blog%5Csource%5Cimg%5C%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%5C175332.png" alt=""></p><p>再给出一个例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//计算Fibonacci数列的第n项</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">F</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>||n==<span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">//到达递归边界时返回</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">F</span>(n<span class="hljs-number">-1</span>)+<span class="hljs-built_in">F</span>(n<span class="hljs-number">-2</span>); <span class="hljs-comment">//没有到达边界时使用递归式递归下去</span><br>&#125;<br><span class="hljs-comment">//其实这就是分治法的一种应用，</span><br><span class="hljs-comment">//对于给定的n把求解F(n)的问题分解成求F(n-1)和F(n-2)这两个子问题,</span><br><span class="hljs-comment">//而F(0)==F(1)==1是n很小的时候问题的直接解决</span><br></code></pre></td></tr></table></figure><p>由上面两个例子可以知道，实现一个递归函数需要两样东西：<strong>递归边界与递归式</strong>，其中递归边界用来返回最简单底层的结果，递归式用来减少数据规模并向下一层递归。</p><p>再给出一个例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">////按照字典序输出全排列</span><br><span class="hljs-comment">//可以分成若干个子问题：输出1开头的全排列，输出2开头的全排列</span><br><span class="hljs-comment">//...输出以n开头的全排列</span><br><span class="hljs-comment">//于是不妨设定一个数组P用以存放当前的排列</span><br><span class="hljs-comment">//再设定一个hashTable，其中hashTable[x]==true表示x在数组P中</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">11</span>;<br><span class="hljs-comment">//P为当前排列，hashTable记录整数x是否已在P中</span><br><span class="hljs-type">int</span> n,P[maxn],hashTable[maxn]=&#123;<span class="hljs-literal">false</span>&#125;;<br><span class="hljs-comment">//当前处理排列的第index号位</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">generateP</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(index==n<span class="hljs-number">+1</span>)&#123;<span class="hljs-comment">//递归边界，已经处理完排列的1~n位</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            cout&lt;&lt;P[i]; <span class="hljs-comment">//输出当前排列</span><br>        &#125;<br>        cout&lt;&lt;endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x=<span class="hljs-number">1</span>;x&lt;=n;x++)&#123;<span class="hljs-comment">//枚举1~n，试图将x填入P[index]中</span><br>        <span class="hljs-keyword">if</span>(hashTable[x]==<span class="hljs-literal">false</span>)&#123;<br>            P[index]=x; <span class="hljs-comment">//令P的第index位为x，即把x加入当前排列</span><br>            hashTable[x]=<span class="hljs-literal">true</span>; <span class="hljs-comment">//记x已在P中</span><br>            <span class="hljs-built_in">generateP</span>(index<span class="hljs-number">+1</span>); <span class="hljs-comment">//处理排列的第index+1号</span><br>            hashTable[x]=<span class="hljs-literal">false</span>; <span class="hljs-comment">//已处理完P[index]为x的子问题，还原状态</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后来看n皇后问题</p><blockquote><p>指的是在一个n*n的棋盘上放置n个皇后使得这n个皇后两两均不在同一行、同一列、同一对角线上，求合法的方案数</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">11</span>;<br><span class="hljs-comment">//每行只能放置一个皇后，每列也只能放置一个</span><br><span class="hljs-comment">//把n列皇后所在的行号依次写出，就会是1~n的一个排列</span><br><span class="hljs-comment">//只需要筛选这每个排列中合法的即可</span><br><span class="hljs-comment">//考虑：递归边界、递归式</span><br><span class="hljs-comment">//由于到达递归边界时表示生成了一个排列，</span><br><span class="hljs-comment">//所以需要在其内部判断是否为合法方案</span><br><span class="hljs-comment">//如何判断？在一个排列中两两遍历两个皇后，</span><br><span class="hljs-comment">//判断他们是否在一条对角线上</span><br><span class="hljs-comment">//如果不是就count++</span><br><span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> n,P[maxn],hashTable[maxn]=&#123;<span class="hljs-literal">false</span>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">A</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(index==n<span class="hljs-number">+1</span>)&#123;<span class="hljs-comment">//递归边界，表示生成了一个排列（类似上一题）</span><br>        <span class="hljs-type">bool</span> flag=<span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i<span class="hljs-number">+1</span>;j&lt;=n;j++)&#123;<br>                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(i-j)==<span class="hljs-built_in">abs</span>(P[i]-P[j]))&#123;<span class="hljs-comment">//如果在一条对角线上，斜率为±1</span><br>                    flag=<span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(flag) count++;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x=<span class="hljs-number">1</span>;x&lt;=n;x++)&#123;<span class="hljs-comment">//就是上一题全排列，因为不能在同一行同一列和全排列的数学本质相同</span><br>        <span class="hljs-keyword">if</span>(!hashTable[x])&#123;<span class="hljs-comment">//这一行还没被占用</span><br>            P[index]=x;<br>            hashTable[x]=<span class="hljs-literal">true</span>;<br>            <span class="hljs-built_in">A</span>(index<span class="hljs-number">+1</span>);<br>            hashTable[x]=<span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是这种解法事实上太暴力了，因为已经生成一部分排列的时候就可以判断这个排列符不符合要求了，如果不符合也就没必要递归了，直接返回上一层，这种做法一般称之为<strong>回溯法</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">11</span>;<br><span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> n,P[maxn],hashTable[maxn]=&#123;<span class="hljs-literal">false</span>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">A</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(index==n<span class="hljs-number">+1</span>)&#123;<br>        count++; <span class="hljs-comment">//能到这里的一定符合要求</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x=<span class="hljs-number">1</span>;x&lt;=n;x++)&#123;<span class="hljs-comment">//第x行</span><br>        <span class="hljs-keyword">if</span>(!hashTable[x])&#123;<span class="hljs-comment">//第x行还没有皇后</span><br>            <span class="hljs-type">bool</span> flag=<span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> pre=<span class="hljs-number">1</span>;pre&lt;index;pre++)&#123;<span class="hljs-comment">//遍历之前的皇后</span><br>                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(index-pre)==<span class="hljs-built_in">abs</span>(P[index]-P[pre]))&#123;<br>                    flag=<span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(flag)&#123;<br>            P[index]=x;<br>            hashTable[x]=<span class="hljs-literal">true</span>;<br>            <span class="hljs-built_in">A</span>(index<span class="hljs-number">+1</span>);<br>            hashTable[x]=<span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-4-贪心">4.4 贪心</h2><h3 id="4-4-1-简单贪心">4.4.1 简单贪心</h3><p>贪心是求解一类最优化问题的方法，它总是考虑在当前状态下**局部最优（或较优）**的策略，来使全局的结果达到最优（或较优）。平常来说，证明贪心法的思路是反证法，即假设策略不能导致最优解，然后通过一系列推导来得到矛盾</p><h4 id="例题-PAT-B1020-月饼">例题 PAT B1020 月饼</h4><blockquote><h5 id="题意">题意</h5><p>现有月饼需求量为D，已知n种月饼各自的库存量和总售价，问如何销售这些月饼，使得可以获得的收益最大，并求最大收益</p></blockquote><h5 id="思路">思路</h5><p>贪心策略：总是选择单价最高的月饼出售，可以获得最大的利润。因此对于每一种月饼都根据其库存量和总售价来计算出该种月饼的单价，之后再把所有单价由低到高排序</p><p>之后从单价高的月饼开始枚举，分两种情况</p><ol><li>如果该种月饼的库存量不足以填补需求量$\Rightarrow$全部卖出，需求量-=该种月饼库存量，收益值+=该种月饼总售价</li><li>如果足够供应，则直接算</li></ol><blockquote><p>[!CAUTION]<br>需要注意的几点</p><ol><li>月饼的库存量和总售价可以是浮点数，虽然题目里只说了D是整数，但是为了计算方便最好也定义成double型</li><li>当库存量&gt;需求量时，不能先令需求量为0再计算收益，否则会使得该步收益为0</li><li>库存&gt;需求时候记得中断循环</li></ol></blockquote><h5 id="代码实现">代码实现</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,d;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">mooncake</span>&#123;<br>    <span class="hljs-type">double</span> storage;<br>    <span class="hljs-type">double</span> price_all;<br>    <span class="hljs-type">double</span> price;<br>&#125;cake[<span class="hljs-number">1010</span>];<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(mooncake a,mooncake b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a.price&gt;b.price;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,n,d);<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,cake[i].storage);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,cake[i].price_all);<br>        cake[i].price=cake[i].price_all/cake[i].storage;<br>    &#125;<br><br>    <span class="hljs-built_in">sort</span>(cake,cake+n,cmp);<br><br>    <span class="hljs-type">double</span> ans=<span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(cake[i].storage&gt;=d)&#123;<br>            ans+=d*cake[i].price;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            ans+=cake[i].price_all;<br>            d-=cake[i].storage;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.2f&quot;</span>,ans);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="例题-PAT-B1023-组个最小数">例题 PAT B1023 组个最小数</h4><blockquote><h5 id="题意-2">题意</h5><p>给定若干个数字0~9，在0不做首位的前提下可以任意排列但必须全部使用，输出可以组成的最小的数</p></blockquote><h5 id="分析">分析</h5><p>先输出最高位：从1-9中选最小的输出</p><p>之后：依次按照0-9的顺序输出数字，输出顺序为其剩余的次数</p><h5 id="代码实现-2">代码实现</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n,cnt[<span class="hljs-number">10</span>],temp;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;temp);<br>        cnt[temp]++;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">9</span>;i++)&#123;<br>        <span class="hljs-keyword">if</span>(cnt[i]!=<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,i);<br>            cnt[i]--;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">9</span>;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;cnt[i];j++)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,i);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>【洛谷 P4447 [AHOI2018初中组] 分组】</strong></p><h2 id="题目描述">题目描述</h2><p>小可可的学校信息组总共有 $n$ 个队员，每个人都有一个实力值 $a_i$。现在，一年一度的编程大赛就要到了，小可可的学校获得了若干个参赛名额，教练决定把学校信息组的 $n$ 个队员分成若干个小组去参加这场比赛。</p><p>但是每个队员都不会愿意与实力跟自己过于悬殊的队员组队，于是要求分成的每个小组的队员实力值连续，同时，一个队不需要两个实力相同的选手。举个例子：$[1, 2, 3, 4, 5]$ 是合法的分组方案，因为实力值连续；$[1, 2, 3, 5]$ 不是合法的分组方案，因为实力值不连续；$[0, 1, 1, 2]$ 同样不是合法的分组方案，因为出现了两个实力值为 $1$ 的选手。</p><p>如果有小组内人数太少，就会因为时间不够而无法获得高分，于是小可可想让你给出一个合法的分组方案，满足所有人都恰好分到一个小组，使得人数最少的组人数最多，输出人数最少的组人数的最大值。</p><p>注意：实力值可能是负数，分组的数量没有限制。</p><h2 id="输入格式">输入格式</h2><p>输入有两行：</p><p>第一行一个正整数 $n$，表示队员数量。<br>第二行有 $n$ 个整数，第 $i$ 个整数 $a_i$ 表示第 $i$ 个队员的实力。</p><h2 id="输出格式">输出格式</h2><p>输出一行，包括一个正整数，表示人数最少的组的人数最大值。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">7</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">5</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> -<span class="hljs-number">4</span> -<span class="hljs-number">3</span> -<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">3<br></code></pre></td></tr></table></figure><h2 id="提示">提示</h2><p>【样例解释】<br>分为 $2$ 组，一组的队员实力值是 ${4, 5, 2, 3}$，一组是 ${-4, -3, -5}$，其中最小的组人数为 $3$，可以发现没有比 $3$ 更优的分法了。</p><p>【数据范围】</p><p>对于 $100%$ 的数据满足：$1\leq n\leq 100000$，$|a_i|\leq10^9$。</p><p>本题共 $10$ 个测试点，编号为 $1\sim10$，每个测试点额外保证如下：</p><table><thead><tr><th style="text-align:center">测试点编号</th><th style="text-align:center">数据限制</th></tr></thead><tbody><tr><td style="text-align:center">$1\sim2$</td><td style="text-align:center">$n\leq 6, 1\leq a_i \leq 100$</td></tr><tr><td style="text-align:center">$3\sim4$</td><td style="text-align:center">$n\leq 1000, 1\leq a_i\leq 10^5$ 且 $a_i$ 互不相同</td></tr><tr><td style="text-align:center">$5\sim6$</td><td style="text-align:center">$n\leq 100000, a_i$ 互不相同</td></tr><tr><td style="text-align:center">$7\sim8$</td><td style="text-align:center">$n\leq 100000, 1\leq a_i \leq10^5$</td></tr><tr><td style="text-align:center">$9\sim 10$</td><td style="text-align:center">$n\leq 100000, -10^9 \leq a_i \leq 10^9$</td></tr></tbody></table></blockquote><p>思路：贪心，//贪心策略：每次加人都加在人数最少的那个队里面，这样可以最大化最小组的人数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> i64=<span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf=<span class="hljs-number">0x3f3f3f3f</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>  <span class="hljs-type">int</span> n;<br>  cin&gt;&gt;n;<br>  <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>    cin&gt;&gt;a[i];<br>  &#125;<br>  <span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>(),a.<span class="hljs-built_in">end</span>());<br>  <span class="hljs-comment">//贪心策略：每次加人都加在人数最少的那个队里面，这样可以最大化最小组的人数</span><br>  <br>  map&lt;<span class="hljs-type">int</span>,priority_queue&lt;<span class="hljs-type">int</span>,vector&lt;<span class="hljs-type">int</span>&gt;,greater&lt;<span class="hljs-type">int</span>&gt;&gt;&gt; group;<br>  <span class="hljs-comment">//map的键是这个组的实力值最大值，值是用来存储已经组建的所有符合该最大实力值的组的人数，队首的是人数最少的</span><br>  <br>  <span class="hljs-comment">//遍历每个队员的实力值，进行分组</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>    <span class="hljs-type">int</span> groupSize=<span class="hljs-number">0</span>; <span class="hljs-comment">// 当前队员加入后的组大小</span><br><br>    <span class="hljs-keyword">auto</span> it=group.<span class="hljs-built_in">find</span>(a[i]<span class="hljs-number">-1</span>); <span class="hljs-comment">//查看当前实力值减去1的分组（前一个实力值的组）</span><br>    <span class="hljs-keyword">if</span>(it!=group.<span class="hljs-built_in">end</span>())&#123;<br>      <span class="hljs-keyword">if</span>(!it-&gt;second.<span class="hljs-built_in">empty</span>())&#123; <span class="hljs-comment">//这个其实是使用队列(优先队列也是队列)的好习惯，先判断非空再访问</span><br>        groupSize=it-&gt;second.<span class="hljs-built_in">top</span>();<br>        it-&gt;second.<span class="hljs-built_in">pop</span>();<br>      &#125;<br>    &#125;<br>    groupSize++;<br>    group[a[i]].<span class="hljs-built_in">push</span>(groupSize);<br>  &#125;<br>  <br>  <span class="hljs-type">int</span> minGroupSize=inf;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; now:group)&#123; <span class="hljs-comment">//区别上一个循环的it是迭代器(指针)，这里的是map类型，所以访问值不需要用-&gt;</span><br>    <span class="hljs-keyword">if</span>(!now.second.<span class="hljs-built_in">empty</span>())&#123;<br>      minGroupSize=<span class="hljs-built_in">min</span>(minGroupSize,now.second.<span class="hljs-built_in">top</span>());<br>    &#125;<br>  &#125;<br>  <br>  cout&lt;&lt;(minGroupSize==inf?<span class="hljs-number">0</span>:minGroupSize)&lt;&lt;endl;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-4-2-区间贪心">4.4.2 区间贪心</h3><p>由一个问题引入：</p><h4 id="区间不相交问题">区间不相交问题</h4><blockquote><p>给出N个开区间(x,y)，从中选择尽可能多的开区间使得这些区间两两没有交集。输出满足条件的区间的个数。</p><p>例如对于开区间(1,3) (2,4) (3,5) (6,7)来说最多可以选出三个区间(1,3) (3,5) (6,7)满足题意</p></blockquote><p>首先考虑最简单的情况，如果开区间$I_1$<strong>被</strong>开区间$I_2$包含，那么选择$I_1$会是更好的选择，因为如果选择$I_1$，就会有更大的空间去容纳别的开区间</p><p>接下来把开区间按左端点x从大到小排序，如果去掉区间包含的情况就必有$y_1&gt;$$y_2 &gt; \cdots$ $y_n $成立，观察图片可以发现$I_1$的右边必然有一段不与其他区间重合，如果把他去掉那么$I_1$的左边剩余部分就会包含于$I_2$，则由上一种情况又可知应当选择$I_1$，因此对于这种情况<strong>总是选择左端点最大的区间</strong></p><p><img src="C:%5CUsers%5Cendle%5Chexo-blog%5Csource%5Cimg%5C%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%5C175333.png" alt=""></p><h4 id="代码实现-3">代码实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> max1=<span class="hljs-number">100</span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">interval</span>&#123;<br>    <span class="hljs-type">int</span> x,y;<br>&#125;iv[max1<span class="hljs-number">+5</span>];<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(interval a,interval b)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(a.x!=b.x) <span class="hljs-keyword">return</span> a.x&gt;b.x;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> a.y&lt;b.y;<br>&#125;<br><span class="hljs-type">int</span> n;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n),n!=<span class="hljs-number">0</span>)&#123; <span class="hljs-comment">//这样可以保证n小于等于0的时候不会进行</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;iv[i].x,&amp;iv[i].y);<br>        &#125;<br>        <span class="hljs-built_in">sort</span>(iv,iv+n,cmp);<br>        <span class="hljs-comment">//ans记录满足条件的区间个数，lastX记录上一次被选中的区间的左端点</span><br>        <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>,lastX=iv[<span class="hljs-number">0</span>].x;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>            <span class="hljs-keyword">if</span>(iv[i].y&lt;=lastX)&#123;<br>                lastX=iv[i].x;<br>                ans++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,ans);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!TIP]</p><p>上面这段代码中while里面的写法，复习一下逗号运算符</p><p>逗号运算符的作用是依次执行其左右两边的表达式，并返回<strong>右边表达式的结果</strong>。</p><p><strong><code>while (scanf(&quot;%d&quot;, &amp;n), n != 0)</code> 的执行过程</strong>：</p><ul><li>先执行 <code>scanf(&quot;%d&quot;, &amp;n)</code>：从输入中读取一个整数并存储到变量 <code>n</code> 中。</li><li>然后计算 <code>n != 0</code>：判断 <code>n</code> 是否不等于 0。</li><li>整个逗号表达式的结果是 <code>n != 0</code> 的值（<code>true</code> 或 <code>false</code>）。</li><li><code>while</code> 循环会根据 <code>n != 0</code> 的结果决定是否继续循环</li></ul></blockquote><p>事实上<strong>总是选择右端点最小的区间</strong>的策略也是可行的</p><p>类似的问题还有<strong>区间选点问题</strong>，即给出N个闭区间，求最少需要确定多少个点使得每个闭区间中都至少存在一个点</p><h2 id="4-5-二分">4.5 二分</h2><h3 id="4-5-1-二分查找">4.5.1 二分查找</h3><p>由于每一步都可以去除当前区间的一半元素，因此时间复杂度是O(logN)</p><p>要求：a[]为严格递增（递减）序列</p><p><strong>代码实现</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">binarysearch</span><span class="hljs-params">(<span class="hljs-type">int</span> a[],<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right,<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-type">int</span> mid;<br>    <span class="hljs-keyword">while</span>(left&lt;=right)&#123; <span class="hljs-comment">//因为left&gt;right就无法形成闭区间了</span><br>        mid=(left+right)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(a[mid]==x) <span class="hljs-keyword">return</span> mid;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a[mid]&lt;x)&#123;<br>            left=mid<span class="hljs-number">+1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            right=mid<span class="hljs-number">-1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">//查找失败，返回-1</span><br>&#125;<br></code></pre></td></tr></table></figure><p>序列严格递减的情况是同理的</p><blockquote><p>[!CAUTION]</p><p>如果二分上界超过INTMAX/2，可能会导致mid=(left+right)/2中的left+right爆掉，所以一般使用等价语句<strong>mid=left+(right-left)/2</strong></p></blockquote><p>讨论一个更进一步的问题，<strong>如果序列并非严格单调，如何求出待查询元素的左闭右开的存在区间[L,R)</strong>，如果序列中没有x，也可以把L和R理解成假设序列中存在x，则x应该在的位置</p><p>可以把这个问题拆解成两个（分治）:</p><p><strong>1.求序列中第一个≥x的元素的位置</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lower_bound</span><span class="hljs-params">(<span class="hljs-type">int</span> a[],<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right,<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-type">int</span> mid;<br>    <span class="hljs-keyword">while</span>(left&lt;right)&#123; <span class="hljs-comment">//当left=right的时候就是所需的下界</span><br>        mid=left+(right-left)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(a[mid]&gt;=x)&#123;<br>            right=mid;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            left=mid<span class="hljs-number">+1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> left;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!CAUTION]</p><ol><li>循环条件为left&lt;right而非left≤right，因为需要的结果就是left=right夹出来的</li><li>二分下界应为0，但是上界是n-1还是n？考虑到x可能不存在，而我们求出来的又是“假设x存在他应该在的位置”（也就是最大的地方），所以开始运行的时候应该取left=0，right=n</li></ol></blockquote><p><strong>2.求序列中第一个大于x的元素的位置</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">upper_bound</span><span class="hljs-params">(<span class="hljs-type">int</span> a[],<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right,<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-type">int</span> mid;<br>    <span class="hljs-keyword">while</span>(left&lt;right)&#123;<br>        mid=left+(right-left)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(a[mid]&gt;x)&#123;<br>            right=mid;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            left=mid<span class="hljs-number">+1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> left;<br>&#125;<br></code></pre></td></tr></table></figure><p>容易注意到这两个函数的唯一区别就是把a[mid]&gt;=x改成了a[mid]&lt;x，其余完全一致</p><p>其实这两个函数都在解决这样一个问题：<strong>寻找有序序列中第一个满足某条件的元素</strong></p><p>对于lower_bound函数而言，寻找的就是第一个满足条件“值大于等于x”的元素的位置，而对于upper_bound函数而言，寻找的就是第一个满足条件“值大于x”的元素的位置，则这样的一个**“条件”<strong>在序列中一定是</strong>从左到右先不满足，然后满足（否则将此条件取反）**</p><p><strong>归纳</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//解决“寻找有序序列中第一个满足某条件的元素的位置”的问题的固定模板</span><br><span class="hljs-comment">//二分区间为左闭右闭的[left,right]，初值必须能够覆盖解的所有可能取值</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right)</span></span>&#123;<br>    <span class="hljs-type">int</span> mid;<br>    <span class="hljs-keyword">while</span>(left&lt;right)&#123;<br>        <span class="hljs-keyword">if</span>(条件成立)&#123; <span class="hljs-comment">//条件成立，第一个满足条件的元素的位置&lt;=mid</span><br>            right=mid;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">//条件不成立，则第一个满足条件的元素的位置&gt;mid</span><br>            left=mid<span class="hljs-number">+1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> left;<br>&#125;<br></code></pre></td></tr></table></figure><p>另外，如果想要寻找最后一个满足“条件C”的元素的位置，则可以先求第一个满足“条件!C”的元素的位置，然后再把该元素的位置-1即可</p><p>另外，就算二分区间不是闭区间，也可以操作</p><p>比如当二分区间为左开右闭区间(left,right]，那么循环条件应当为left+1&lt;right，也即退出循环的时候有left+1=right成立，使得夹逼得到的唯一，而由于变为了左开，left的初值要比解的最小取值要小1，同时语句left=mid+1应该改成left=mid，返回值也应该是right(毕竟闭区间是可以取到的)，代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//解决“寻找有序序列中第一个满足某条件的元素的位置”的问题的固定模板</span><br><span class="hljs-comment">//二分区间为左开右闭区间(left,right]，初值必须能够覆盖解的所有可能取值</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right)</span></span>&#123;<br>    <span class="hljs-type">int</span> mid;<br>    <span class="hljs-keyword">while</span>(left<span class="hljs-number">+1</span>&lt;right)&#123;<br>        <span class="hljs-keyword">if</span>(条件成立)&#123; <span class="hljs-comment">//条件成立，第一个满足条件的元素的位置&lt;=mid</span><br>            right=mid;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">//条件不成立，则第一个满足条件的元素的位置&gt;mid</span><br>            left=mid;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> right;<br>&#125;<br></code></pre></td></tr></table></figure><p>如何判断lower_bound函数和upper_bound函数的查询是否成功？可以判断上界是否为n</p><p>（因为upper_bound函数求的也是满足条件的元素的位置的后面的第一个）</p><h3 id="4-5-2-二分法拓展">4.5.2 二分法拓展</h3><h4 id="如何计算-sqrt-2-的近似值">如何计算$\sqrt 2$的近似值</h4><p>对于$f(x)=x^2$当$x&gt;0$时$f(x)$单调递增，那么我们可以考虑使用二分法来逼近，取精确到$10^{-5}$为例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-5</span>; <span class="hljs-comment">//精度为10^&#123;-5&#125;</span><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span></span>&#123; <span class="hljs-comment">//计算f(x)</span><br>    <span class="hljs-keyword">return</span> x*x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">calsqrt</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">double</span> left=<span class="hljs-number">1</span>,right=<span class="hljs-number">2</span>,mid;<br>    <span class="hljs-keyword">while</span>(right-left&gt;eps)&#123; <span class="hljs-comment">//回顾之前学的高精度判断相等</span><br>        mid=left+(right-left)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">f</span>(mid)&gt;<span class="hljs-number">2</span>) right=mid;<br>        <span class="hljs-keyword">else</span> left=mid;<br>    &#125;<br>    <span class="hljs-keyword">return</span> mid;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="木棒切割问题">木棒切割问题</h4><blockquote><p>给出N根长度已知的木棒，现在希望通过切割他们来得到至少K段长度相等的木棒（长度必须是整数），问这些长度相等的木棒最长能有多长？</p></blockquote><p>容易注意到K越大，则L越小，那么考虑到这个我们可以使用二分法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">F</span><span class="hljs-params">(L)</span></span>&#123;<br>给定长度，计算当前总段数<br>&#125;<br><br><span class="hljs-type">int</span> 二分()&#123;<br>left=<span class="hljs-number">1</span><br>right=杆子最长的长度<br><span class="hljs-keyword">while</span>(left&lt;right)&#123;<br>mid=直接算<br>cnt=<span class="hljs-built_in">F</span>(mid)<br><span class="hljs-keyword">if</span>(cnt&gt;=k) left=mid<br><span class="hljs-keyword">else</span> right=mid<br>&#125;<br><span class="hljs-keyword">return</span> mid;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-5-3-快速幂">4.5.3 快速幂</h3><p>给定一个问题</p><blockquote><p>给定三个正整数a、b、m（a&lt;$10^9$，b&lt;$10^6$，$1$&lt;m&lt;$10^9$），求$a^{b}$%m</p></blockquote><p>可以采用这种代码，时间复杂度为O(b)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">xxxxxxxxxx <span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<span class="hljs-function">LL <span class="hljs-title">LLpow</span><span class="hljs-params">(LL a,LL b,LL m)</span></span>&#123;    LL ans=<span class="hljs-number">1</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;b;i++)&#123;        ans=ans*a%m; <span class="hljs-comment">//考虑模运算的性质(a×b)modm=[(amodm)×(bmodm)]modm    &#125;    return ans;&#125;cpp</span><br></code></pre></td></tr></table></figure><p>代码中使用LL而非int是防止两个int相乘之后溢出</p><p>考虑一个更进一步的问题</p><blockquote><p>给定三个正整数a、b、m（a&lt;$10^9$，b&lt;$10^{18}$，$1$&lt;m&lt;$10^9$），求$a^{b}$%m</p></blockquote><p>对于这个问题，如果还是按上面的做法显然是不行的</p><p>这里要使用<strong>快速幂</strong>的用法，它基于二分的思想，因此也常常被称之为<strong>二分幂</strong>，快速幂基于以下事实</p><ol><li>如果b是奇数，那么有$a^b=a*a^{b-1}$</li><li>如果b是偶数，那么有$a^b=a^{b/2}*a^{b/2}$</li></ol><p>显然，b是奇数的情况总可以在下一步转换为b是偶数的情况，而b是偶数的情况总可以在下一步转换为b/2的情况，这样在log(b)级别的转换后，就可以把b变为0，而任何正整数的0次方都是1</p><p>举个例子，如果需要求$2^{10}$</p><ol><li>对$2^{10}$来说，由于幂次10为偶数，因此需要先求$2^{5}$，然后有$2^{10}=2^{5}*2^{5}$</li><li>对于$2^{5}$来说，由于幂次5为奇数，因此先要求$2^{4}$，然后有$2^5=2*2^4$</li><li>对于$2^4$来说，由于幂次4为偶数，因此先要求$2^2$，然后有$2^4=2^2*2^2$</li><li>对于$2^2$来说，由于幂次2为偶数，因此需要先求$2^1$，然后有$2^2=2^1*2^1$</li><li>对于$2^1$来说，由于幂次1为奇数，因此需要先求$2^0$，然后有$2^1=2*2^0$</li><li>$2^0=1$，然后从下往上依次回退计算即可</li></ol><p>这显然是递归的思想，于是可以得到快速幂的递归写法，时间复杂度为O(logb)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><span class="hljs-function">LL <span class="hljs-title">binaryPow</span><span class="hljs-params">(LL a,LL b,LL m)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(b==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(b%<span class="hljs-number">2</span>==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> a*<span class="hljs-built_in">binaryPow</span>(a,b<span class="hljs-number">-1</span>,m)%m;<br>    <span class="hljs-keyword">else</span>&#123;<br>        LL mul=<span class="hljs-built_in">binaryPow</span>(a,b/<span class="hljs-number">2</span>,m);<br>        <span class="hljs-keyword">return</span> mul*mul%m;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!TIP]</p><p>上面的代码中，条件<code>if(b%2==1)</code>可以用<code>if(b&amp;1)</code>代替，这是因为<code>b&amp;1</code>进行位与操作，判断b的末位是否为1，因此当b为奇数时<code>b&amp;1</code>返回1，if条件成立，这样写执行速度会快一点</p></blockquote><p>还需要注意，当b%2==0时不要直接返回binaryPow(a,b/2,m)*binaryPow(a,b/2,m)，而应计算单个binaryPow(a,b/2,m)之后再乘起来，这是因为前者每次都会调用两个binaryPow函数，导致复杂度变为O($2^{log(b)}$)=O(b)。例如求binaryPow(8)时，会变成binaryPow(4)*binaryPow(4)，而这两个binaryPow(4)又会各自变成binaryPow(2)*binaryPow(2)，而每个binaryPow(2)又会变成binaryPow(1)*binaryPow(1)，因此最后需要求8次binaryPow(1)</p><p>另外，针对不同的题目可能有<strong>两个细节</strong>需要注意</p><ol><li>如果初始时a可能大于m，那么需要在进入函数前就让a对m取模</li><li>如果m为1，可以直接在函数外部特判为0，不需要进入函数来计算（因为任何正整数对1取模一定等于0）</li></ol><p>接下来研究一下快速幂的迭代写法（填坑）</p><h2 id="4-6-two-pointers">4.6 two pointers</h2><h3 id="4-6-1-什么是two-pointers">4.6.1 什么是two pointers</h3><p>two pointers是算法编程中一种非常重要的思想，以一个例子来引入</p><blockquote><p>给定一个递增的正整数序列和一个正整数M，求序列中两个不同位置的数a和b，使得他们的和恰好为M，输出所有满足条件的方案。</p><p>例如给定序列{1,2,3,4,5,6}和正整数M=8，就存在$2+6=8$和$3+5=8$成立</p></blockquote><p>本题最直观的一个想法是使用二重循环枚举序列中的a和b，判断他们的和是否为M，代码实现如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i;j&lt;=n;j++)&#123;<br>        <span class="hljs-keyword">if</span>(a[i]+a[j]==M)&#123;<br>            cout&lt;&lt;i&lt;&lt;j&lt;&lt;endl;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样的时间复杂度是O($n^2$)，太高了，来看看高复杂度的原因是什么：</p><ol><li>对于一个确定的a[i]来说，如果当前的a[j]满足a[i]+a[j]&gt;M，显然也会有a[i]+a[j+1]&gt;M（这是由于序列是递增的），因此就不需要对a[j]之后的数进行枚举。如果无视这个性质，就会导致对j进行了大量的无效枚举</li><li>对某一个a[i]来说，如果找到一个a[j]，使得a[i]+a[j]&gt;M恰好成立，那么对于a[i+1]来说也一定有a[i+1]+a[j]&gt;M成立，因此在a[i]之后的元素也不必再去枚举</li></ol><p>由上面两点可见：i和j的枚举是互相牵制的，事实上本题中two pointers将利用有序序列的枚举特性来有效降低复杂度，算法过程如下：</p><p>令下标i的初值为0，下标j的初值为n-1</p><table><thead><tr><th>a[0]</th><th>···</th><th>a[i]</th><th>a[i+1]</th><th>···</th><th>a[j-1]</th><th>a[j]</th><th>···</th><th>a[n-1]</th></tr></thead></table><p>然后我们就可以设想，只让i往右走（即i++），只让j往左走（即j–），然后根据a[i]+a[j]情况的不同来让i和j恰当地移动，就可以做到遍历所有情况</p><ol><li>若a[i]+a[j]=M，则<strong>不可能</strong>在固定i或者固定j的情况下使另外一个下标移动，二者的和仍为M，那么只能让i++，j–</li><li>若a[i]+a[j]&gt;M，那么要让其中一个后退，又只能是j后退，所以i不变，j–</li><li>若i]+a[j]&lt;M，同理有i++，j不变</li></ol><p>反复执行上面三个判断直到i&gt;=j成立（这样可以遍历所有的情况）</p><p>代码实现如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=n<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">while</span>(i&lt;j)&#123;<br>    <span class="hljs-keyword">if</span>(a[i]+a[j]==M)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,i,j);<br>        i++;<br>        j--;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a[i]+a[j]&gt;M) j--;<br>    <span class="hljs-keyword">else</span> i++;<br>&#125;<br></code></pre></td></tr></table></figure><p>显然时间复杂度为O(n)</p><p>再给一个例子</p><blockquote><p>序列合并问题：给定两个递增序列a和b，合并成同一个递增序列c</p></blockquote><p>同样可以设置两个下标i和j，利用类似的思路完成问题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> a[],<span class="hljs-type">int</span> b[], <span class="hljs-type">int</span> c[], <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> m)</span></span>&#123;<br>    <span class="hljs-comment">//n和m分别是数组a和b的长度</span><br>    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>,index=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;n&amp;&amp;j&lt;m)&#123;<br>        <span class="hljs-keyword">if</span>(a[i]&lt;=b[j]) c[index++]=a[i++]; <span class="hljs-comment">//相等的情况放a和b都一样</span><br>        <span class="hljs-keyword">else</span> c[index++]=b[j++]; <span class="hljs-comment">//把b[j]放入序列中</span><br>    &#125;<br>    <span class="hljs-keyword">while</span>(i&lt;n) c[index++]=a[i++]; <span class="hljs-comment">//把a的剩余元素放入c中</span><br>    <span class="hljs-keyword">while</span>(j&lt;m) c[index++]=b[j++]; <span class="hljs-comment">//把b的剩余元素放入c中</span><br>    <span class="hljs-keyword">return</span> index; <span class="hljs-comment">//返回序列c的长度</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>归纳</strong></p><p>two pointers是利用问题本身和序列的特性，使用两个下标对序列进行扫描（可以同向也可以反向），以较低的复杂度解决问题</p><h3 id="4-6-2-归并排序">4.6.2 归并排序</h3><p>归并排序是一种基于“归并”的排序方法，这里主要介绍最基本的2-路归并排序</p><p>思路：将序列两两分组，将序列归并为$\lceil \frac{n}{2} \rceil$个组，组内单独排序，然后再把这些组两两归并，生成$\lceil \frac{n}{4} \rceil$个组，组内再单独排序，以此类推，直到只剩下一个组位置，时间复杂度为O(nlogn)</p><p>代码实现：</p><ol><li><p>递归实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">100</span>;<br><span class="hljs-comment">//将数组a的[l1,r1]与[l2,r2]区间合并为有序区间（此处l2即r1+1）</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> a[],<span class="hljs-type">int</span> l1,<span class="hljs-type">int</span> r1,<span class="hljs-type">int</span> l2,<span class="hljs-type">int</span> r2)</span></span>&#123;<br>    <span class="hljs-type">int</span> i=l1,j=l2;<br>    <span class="hljs-type">int</span> temp[maxn],index=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;=r1&amp;&amp;j&lt;=r2)&#123;<br>        <span class="hljs-keyword">if</span>(a[i]&lt;=a[j]) temp[index++]=a[i++];<br>        <span class="hljs-keyword">else</span> temp[index++]=a[j++];<br>    &#125;<br>    <span class="hljs-keyword">while</span>(i&lt;=r1) temp[index++]=a[i++];<br>    <span class="hljs-keyword">while</span>(j&lt;=r2) temp[index++]=a[j++];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;index;i++)&#123;<br>        a[l1+i]=temp[i]; <span class="hljs-comment">//将合并之后的序列赋回给a</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//将a数组当前区间[left,right]进行归并排序</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span> a[],<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(left&lt;right)&#123;<br>        <span class="hljs-type">int</span> mid=left+(right-left)/<span class="hljs-number">2</span>;<br>        <span class="hljs-built_in">mergeSort</span>(a,left,mid); <span class="hljs-comment">//递归，将左区间归并排序</span><br>        <span class="hljs-built_in">mergeSort</span>(a,mid<span class="hljs-number">+1</span>,right);  <span class="hljs-comment">//递归，将右区间归并排序</span><br>        <span class="hljs-built_in">merge</span>(a,left,mid,mid<span class="hljs-number">+1</span>,right); <span class="hljs-comment">//将左右子区间合并</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>非递归实现</p><p>主要要考虑到每次分组的时候组内元素个数上限都是2的幂次，令步长step的初值为2，然后将数组中每step个元素作为一组，对其内部排序（即在长度为step的子组中，将左step/2和右step/2个元素合并，若元素个数不超过step/2则不操作），再令step*2，反复操作直到step/2&gt;n，代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span> a[])</span></span>&#123;<br>    <span class="hljs-comment">//step为组内元素个数，step/2为左子区间元素个数，注意等号可以不取</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> step=<span class="hljs-number">2</span>;step/<span class="hljs-number">2</span>&lt;n;step*=<span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-comment">//每step个元素一组</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i+=step)&#123; <span class="hljs-comment">//对于每一组</span><br>            <span class="hljs-type">int</span> mid=i+step/<span class="hljs-number">2</span><span class="hljs-number">-1</span>; <span class="hljs-comment">//元素个数为step/2</span><br>            <span class="hljs-keyword">if</span>(mid<span class="hljs-number">+1</span>&lt;=n)&#123;<br>                <span class="hljs-built_in">merge</span>(a,i,mid,mid<span class="hljs-number">+1</span>,<span class="hljs-built_in">min</span>(n,i+step<span class="hljs-number">-1</span>));<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="4-6-3-快速排序">4.6.3 快速排序</h3><p>快速排序时间复杂度为O(nlogn)，其实现需要先解决一个问题：对于一个序列a[]，调整序列中元素的位置，使得a[0]（原序列中的a[0]，下同）左侧的所有元素都小于等于a[0]，右侧的所有元素都大于a[0]。</p><p>由于显然存在很多方案，下面给出一种使用two pointers实现的做法，也是最快的方法</p><ol><li>先将a[0]存入temp，定义left=0，right=len-1</li><li>right一直左移，直到a[right]≤a[0]，就将a[right]指向的元素挪到left处（比如考虑第一次，第一次的时候a[1]被挪走了，可以认为那个地方是空的，那么就可以直接把a[right]指向的元素赋给left处）；之后left一直右移，直到a[left]&gt;a[0]，再把a[left]处的元素赋给right处（因为可以认为之前的right处赋给了之前的left处，那个地方已经空了）；如此交替进行</li><li>直到right=left，再把temp赋给这个地方，则完成</li></ol><p>一般化考虑left的初值就是划分区间的点，将划分区间的元素a[left]称之为<strong>主元</strong></p><p>代码实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Partition</span><span class="hljs-params">(<span class="hljs-type">int</span> a[],<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right)</span></span>&#123;<br>    <span class="hljs-type">int</span> temp=a[left];<br>    <span class="hljs-keyword">while</span>(left&lt;right)&#123;<br>        <span class="hljs-keyword">while</span>(left&lt;right&amp;&amp;a[right]&gt;=temp) right--; <span class="hljs-comment">//注意这里还要同时满足left&lt;right，这样才能保证外层循环结束时一定有left=right</span><br>        a[left]=a[right];<br>        <span class="hljs-keyword">while</span>(left&lt;right&amp;&amp;a[left]&lt;temp) left++;<br>        a[right]=a[left];<br>    &#125;<br>    a[left]=temp;<br>    <span class="hljs-keyword">return</span> left; <span class="hljs-comment">//返回相遇的下标</span><br>&#125;<br></code></pre></td></tr></table></figure><p>接下来就可以实现快速排序算法了，其思路是：</p><ol><li>调整序列中的元素，使当前序列最左端的元素在调整后满足左侧所有元素均不超过该元素、右侧所有元素均大于该元素</li><li>对该元素的左侧和右侧分别递归进行1.的调整，直到当前调整区间的长度不超过1</li></ol><p>递归实现如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//快速排序，left与right初值为序列首尾下标</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span> a[],<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(left&lt;right)&#123; <span class="hljs-comment">//当前区间的长度超过1</span><br>        <span class="hljs-comment">//将区间[left,right]按照a[left]一分为二</span><br>        <span class="hljs-type">int</span> pos=<span class="hljs-built_in">Partition</span>(a,left,right);<br>        <span class="hljs-built_in">quickSort</span>(a,left,pos<span class="hljs-number">-1</span>);<br>        <span class="hljs-built_in">quickSort</span>(a,pos,right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是会有一个缺陷：只有序列中的元素排列比较随机的时候效率最高。当序列中元素接近有序的时候会达到最坏时间复杂度O($\mathrm{n}^2$)，产生这种情况的主要原因在于主元没有把当前区间划分为两个长度接近的子区间。解决这个问题的方法之一是随机选择主元，即从[left,right]中随机选择一个数作为主元，这样能保证对于任意输入数据的期望时间复杂度都能达到O(nlogn)</p><p>下面来看看如何生成随机数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;time.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">random</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">srand</span>((<span class="hljs-type">unsigned</span>)<span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>));<br>    <span class="hljs-keyword">return</span> ((<span class="hljs-built_in">rand</span>() % (b-a<span class="hljs-number">+1</span>)) + a);<br>&#125;<br></code></pre></td></tr></table></figure><p>当b-a&gt;RAND_MAX时，可以这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">random</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>    <span class="hljs-built_in">srand</span>((<span class="hljs-type">unsigned</span>)<span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>));<br>    <span class="hljs-comment">//用rand()生成一个在[0,RAND_MAX]范围内的随机数，除以RAND_MAX得到一个[0,1]之间的浮点数再乘以b-a再+a即可</span><br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)(<span class="hljs-built_in">round</span>(<span class="hljs-number">1.0</span>*<span class="hljs-built_in">rand</span>()/RAND_MAX*(b-a)+a));<br>&#125;<br></code></pre></td></tr></table></figure><p>在此基础上继续讨论随机快速排序的写法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">randPartition</span><span class="hljs-params">(<span class="hljs-type">int</span> a[],<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right)</span></span>&#123;<br>    <span class="hljs-type">int</span> p=(<span class="hljs-type">int</span>)(<span class="hljs-built_in">round</span>(<span class="hljs-number">1.0</span>*<span class="hljs-built_in">rand</span>()/RAND_MAX*(right-left))+left);<br>    <span class="hljs-built_in">swap</span>(a[p],a[left]); <span class="hljs-comment">//交换主元</span><br>    <span class="hljs-comment">//之后一模一样</span><br>    <span class="hljs-type">int</span> temp=a[left];<br>    <span class="hljs-keyword">while</span>(left&lt;right)&#123;<br>        <span class="hljs-keyword">while</span>(left&lt;right&amp;&amp;a[right]&gt;=temp) right--; <span class="hljs-comment">//注意这里还要同时满足left&lt;right，这样才能保证外层循环结束时一定有left=right</span><br>        a[left]=a[right];<br>        <span class="hljs-keyword">while</span>(left&lt;right&amp;&amp;a[left]&lt;temp) left++;<br>        a[right]=a[left];<br>    &#125;<br>    a[left]=temp;<br>    <span class="hljs-keyword">return</span> left; <span class="hljs-comment">//返回相遇的下标</span><br>&#125;<br><br><span class="hljs-comment">//quickSort函数无需做出任何改变</span><br></code></pre></td></tr></table></figure><h2 id="4-7-其他高效技巧与算法">4.7 其他高效技巧与算法</h2><h3 id="4-7-1-打表">4.7.1 打表</h3><p>打表：以空间换时间。一般是指把所有可能需要用到的结果事先计算出来，这样后面用到时就可以直接查表获得。打表的方式有以下几种：</p><ol><li><p><strong>在程序中一次性计算出所有可能需要用到的结果事先计算出来，之后的查询直接取这些结果</strong></p><p>这个最常用。比如一个问题里面需要大量查询斐波那契数F(n)，每查询一次时间复杂度就是O(n)，查询Q次时间复杂度就是O(Qn)，而如果预先先把给定范围内的斐波那契数全部计算出来，那么每次查询就是O(1)的复杂度，Q次查询就是O(Q+n)，n为预处理时间</p></li><li><p><strong>在另一个程序中分一次或者多次计算出来需要用到的结果，手工把结果打到需要用程序的数组中，然后在这个程序里直接使用</strong></p></li><li><p><strong>对于一些感觉不会的题目，先用暴力程序计算小范围数据的结果，然后找规律</strong></p></li></ol><h3 id="4-7-2-活用递推">4.7.2 活用递推</h3><p>细心考虑题目中是否存在递推关系。例如就一类涉及序列的问题而言，假如序列的每一位所需要计算的值都可以通过该位左右两侧的结果来计算得到，那么就可以考虑所谓的“左右两侧的结果”是否可以通过递推进行预处理来得到，这样在后面的使用中就可以不必反复求解</p><blockquote><p><strong>【PAT A1093/B1040】 有几个PAT</strong></p><p>字符串APPAPT包含了两个&quot;PAT&quot;，位数：2+4+6和3+4+6，现在给定一个字符串，问一共可以形成多少个PAT？</p><p>输入格式：</p><p>一行包含一个字符串，长度不超过$10^5$</p><p>输出格式：</p><p>输入包含多少个PAT，结果可能比较大，输出对1000000007取余的结果</p></blockquote><p>思路：<br>直接暴力会超时，可以这样分析：</p><p>对于每一个确定的A，可以形成的PAT的数量=A左边的P的数量*A右边的T的数量，那么问题转化成求每个A左侧P和右侧T的数量</p><p>一个比较快的获得每一位左边P的个数的方法：设定一个数组leftNumP，先memset为0，然后如果下标i处为P，那么就有leftNumP[i]=leftNumP[i]+1，如果不是那么就有leftNumP[i]=leftNumP[i]，由此可以在时间复杂度为O(len)内求出</p><p>求每一位右边的T也是同理的，但是可以在求出T的同时把ans也求出来，定义int rightNumT，表示遍历到当前的位置的时候这个位置右边的T的数量。如果当前位置是T那么rightNumT++，如果当前位置是A那么ans=(ans+leftNumP[i]*rightNumT)%MOD</p><h3 id="4-7-3-随机选择算法">4.7.3 随机选择算法</h3><p>本节主要讨论这个问题：如何从一个无序的数组中求出第K小的数（假设数组中的数两两不同）</p><p>如果直接快排，时间复杂度是O(nlogn)，但是存在更优的随机选择算法，对于任何输入都可以达到O(n)的期望时间复杂度。</p><p>其原理比较类似于随机快速排序中的randPartition函数，分析这个函数：</p><p>当这个函数执行完一遍之后，假设被选择到的主元为a[p]，那么主元左右两侧的元素个数就是确定的（设p为已知），即a[p]是[left,right]中第p-left+1小的数。</p><p>不妨设p-left+1=M，则当K==M时，第K小的数就是a[p]，</p><p>当K&lt;M时，第K小的数在主元左侧，即第K小的数是[left,p-1]中的第K大，往左侧递归即可</p><p>当K&gt;M时，第K小的数在主元右侧，即第K小的数是[p+1,right]中的第K-M大，往右侧递归即可</p><p>分析：算法可以以left=right为递归边界，返回a[left]，代码实现如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//随机选择算法，返回[left,right]中第k小的数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">randSelect</span><span class="hljs-params">(<span class="hljs-type">int</span> a[],<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right,<span class="hljs-type">int</span> k)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(left==right) <span class="hljs-keyword">return</span> a[left]; <span class="hljs-comment">//递归边界</span><br>    <span class="hljs-type">int</span> p=<span class="hljs-built_in">randPartition</span>(a,left,right);<br>    <span class="hljs-type">int</span> m=p-left<span class="hljs-number">+1</span>;<br>    <span class="hljs-keyword">if</span>(left&lt;right&amp;&amp;k==m) <span class="hljs-keyword">return</span> a[p];<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(left&lt;right&amp;&amp;k&lt;m) <span class="hljs-keyword">return</span> <span class="hljs-built_in">randSelect</span>(a,left,p<span class="hljs-number">-1</span>,k);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(left&lt;right&amp;&amp;k&gt;m) <span class="hljs-keyword">return</span> <span class="hljs-built_in">randSelect</span>(a,p<span class="hljs-number">+1</span>,right,k-m); <br>&#125;<br></code></pre></td></tr></table></figure><p>这个算法对于任意输入的期望时间复杂度均为O(n)</p><p>下面给出一个应用的例题</p><blockquote><p>给定一个由整数组成的集合，集合中的整数两两不同，现在需要将它分为两个子集合，使得这两个子集合的并为原集合，交为空集。同时在两个子集合元素个数之差的绝对值$|n_1-n_2|$的绝对值尽可能小的情况下，要求它们各自的元素之和的差的绝对值$|S_1-S_2|$尽可能大，求这个$|S_1-S_2|$等于多少</p></blockquote><p>可以分成两类：当n为偶数时，显然有$n_1=n_2=\frac{n}{2}$；n为奇数时，不妨取$n_1=\frac{n}{2}+1,n_2=\frac{n}{2}$（均为向下取整）</p><p>为了使得$|S_1-S_2|$尽可能大，显然应当把原集合从小到大排，前$n_1$个的和为$S_1$，后$n_2$的和为$S_2$</p><p>但是如果要把整个序列排序时间复杂度是O(nlogn)，我们可以优化成O(n)。这里我们可以考虑使用随机选择算法</p><p>只需要使用randSelect函数求出第$\frac{n}{2}$大的数即可，函数会自动切分好两个集合，然后让i从0遍历到n/2求和即可。</p><h3 id="4-7-4-前缀和">4.7.4 前缀和</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preFix</span><span class="hljs-params">(n)</span></span>;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;++i)&#123;<br>    <span class="hljs-keyword">if</span>(i==<span class="hljs-number">0</span>) preFix[i]+=a[i];<br>    preFix[i]=preFix[i<span class="hljs-number">-1</span>]+a[i];<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>c++系统库中也有一个库函数<code>partial_sum</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;numeric&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(arr.size())</span></span>;  <span class="hljs-comment">// 存储部分和的容器</span><br><br>    <span class="hljs-comment">// 计算部分和并存储到 result</span><br>    std::<span class="hljs-built_in">partial_sum</span>(arr.<span class="hljs-built_in">begin</span>(), arr.<span class="hljs-built_in">end</span>(), result.<span class="hljs-built_in">begin</span>());<br><br>    <span class="hljs-comment">// 输出结果</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : result) &#123;<br>        std::cout &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1>第5章 入门篇（3）——数学问题</h1><h2 id="5-1-简单数学">5.1 简单数学</h2><blockquote><p><strong>【PAT B119/A1069 数字黑洞】</strong></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">to_array</span><span class="hljs-params">(<span class="hljs-type">int</span> a[],<span class="hljs-type">int</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;<br>        a[i]=b%<span class="hljs-number">10</span>;<br>        b/=<span class="hljs-number">10</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">to_number</span><span class="hljs-params">(<span class="hljs-type">int</span> a[])</span></span>&#123;<br>    <span class="hljs-type">int</span> b=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;<br>        b=b*<span class="hljs-number">10</span>+a[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a&gt;b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-type">int</span> ans,a1,a2;<br>    <span class="hljs-type">int</span> t[<span class="hljs-number">5</span>];<br>    <span class="hljs-keyword">while</span>(ans!=<span class="hljs-number">6174</span>)&#123;<br>        <span class="hljs-built_in">to_array</span>(t,n);<br>        <span class="hljs-built_in">sort</span>(t,t<span class="hljs-number">+4</span>);<br>        a1=<span class="hljs-built_in">to_number</span>(t);<br>        <span class="hljs-built_in">sort</span>(t,t<span class="hljs-number">+4</span>,cmp);<br>        a2=<span class="hljs-built_in">to_number</span>(t);<br>        ans=a2-a1;<br>        n=ans;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%04d-%04d=%04d\n&quot;</span>,a2,a1,ans);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-2-最大公约数和最小公倍数">5.2 最大公约数和最小公倍数</h2><h3 id="5-2-1-最大公约数">5.2.1 最大公约数</h3><p>基于欧几里得算法（辗转相除法）</p><p><strong>gcd(a,b)=gcd(b,a%b)</strong></p><p>上式可以看成递归式</p><p>又有递归边界<strong>gcd(a,0)=a</strong></p><p>代码实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(b==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> a;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">gcd</span>(b,a%b);<br>&#125;<br>或者<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> !b?a:<span class="hljs-built_in">gcd</span>(b,a%b);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-2-2-最小公倍数">5.2.2 最小公倍数</h3><p>先求最大公约数d=gcd(a,b)，则有最小公倍数为$\frac{a}{d}*b$</p><h2 id="5-3-分数的四则运算">5.3 分数的四则运算</h2><h3 id="5-3-1-分数的表示和化简">5.3.1 分数的表示和化简</h3><h4 id="1-分数的表示">1.分数的表示</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Fraction</span>&#123;<br>    <span class="hljs-type">int</span> up,down;<br>&#125;;<br></code></pre></td></tr></table></figure><p>其中需要对这种表示指定三项规则：</p><ol><li>使down为非负数，如果分数为负则令up为负数</li><li>如果分数为0则令up=0,down=1</li><li>分子和分母互素</li></ol><h4 id="2-分数的化简">2.分数的化简</h4><p>主要用来使Fraction变量满足分数的三项规定</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Fraction <span class="hljs-title">reduction</span><span class="hljs-params">(Fraction result)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(result.down&lt;<span class="hljs-number">0</span>)&#123; <span class="hljs-comment">//满足第一条规定</span><br>        result.up=-result.up;<br>        result.down=-result.down;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(result.up==<span class="hljs-number">0</span>) result.down=<span class="hljs-number">1</span>; <span class="hljs-comment">//满足第二条规定</span><br>    <span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">//满足第三条规定</span><br>        <span class="hljs-type">int</span> d=<span class="hljs-built_in">gcd</span>(<span class="hljs-built_in">abs</span>(result.up),<span class="hljs-built_in">abs</span>(result.down));<br>        result.up/=d;<br>        result.down/=d;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-3-2-分数的四则运算">5.3.2 分数的四则运算</h3><h4 id="1-2-3-4-加减乘除">1.2.3.4 加减乘除</h4><p>大同小异。就通分死算，记得最后返回return reduction(result)</p><h3 id="5-3-3-分数的输出">5.3.3 分数的输出</h3><ol><li>先化简</li><li>如果f.down=1，直接输出up</li><li>带分数的输出：整数部分为r.up/r.down，分子部分为abs(r.up)%r.down，分母为r.down</li></ol><p><strong>由于分数的乘法和除法的过程中可能使分子或分母超过int型表示范围，因此一般情况下分子和分母使用long long来存储</strong></p><h2 id="5-4-素数">5.4 素数</h2><h3 id="5-4-1-素数的判断">5.4.1 素数的判断</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPrime</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(n&lt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">int</span> sqr=(<span class="hljs-type">int</span>)<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">1.0</span>*n); <span class="hljs-comment">//在n前面乘上1.0使之变为浮点型</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=sqr;i++)&#123;<br>        <span class="hljs-keyword">if</span>(n%i==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果n比较小（i^2没有解决int类型上线）也可以这样写</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPrime</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(n&lt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i*i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(n%i==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-4-2-素数表的获取">5.4.2 素数表的获取</h3><p>暴力法复杂度为O($n \sqrt n$)，下面介绍效率更高的两种筛法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//埃氏筛法：从2开始，将每个质数的倍数都标记成合数，以达到筛选素数的目的</span><br><span class="hljs-type">int</span> visit[maxn];  <span class="hljs-comment">//maxn是需要打的素数表（布尔数组）</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Prime</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">memset</span>(visit,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(visit)); <span class="hljs-comment">//初始化都是素数，如果是素数的话就是1，不是素数才是0</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; maxn; i++) &#123; <span class="hljs-comment">//注意不能写成i&lt;=maxn</span><br>        <span class="hljs-keyword">if</span> (!visit[i]) &#123;         <span class="hljs-comment">//如果i是素数，让i的所有倍数都不是素数</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i+i; j &lt; maxn; j += i) &#123; <br>                visit[j] = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度为O(nloglogn)</p><p>原理：从小到大到达某数a时，假如a还没有被前面的步骤筛去，那么a一定是素数。因为假设a不是素数，那么a必有小于a的因子，那么a一定会在之前的步骤中被筛掉</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//欧拉筛法：在埃氏筛法的基础上，让每个合数只被它的最小质因子筛选一次，以达到不重复的目的。</span><br><span class="hljs-type">bool</span> visit[maxn<span class="hljs-number">+5</span>]; <span class="hljs-comment">//1表示是素数，0表示不是素数</span><br><span class="hljs-type">int</span> prime[maxn<span class="hljs-number">+5</span>]; <span class="hljs-comment">//需要打的素数表</span><br><span class="hljs-type">int</span> cnt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">findPrime</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">memset</span>(visit,<span class="hljs-number">1</span>,<span class="hljs-built_in">sizeof</span>(visit));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;maxn;i++)&#123;<br>        <span class="hljs-keyword">if</span>(visit[i])&#123;<br>            prime[cnt++]=i;<br>        &#125;<br>        <span class="hljs-comment">//遍历已知的素数来标记合数</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;cnt&amp;&amp;i*prime[j]&lt;maxn;j++)&#123;<br>            <span class="hljs-comment">//循环条件保证遍历的是已知的素数，以及标记的合数不超过maxn</span><br>            visit[i*prime[j]]=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span>(i%prime[j]==<span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>; <span class="hljs-comment">//看下文</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>当 <code>i % prime[j] == 0</code> 时，说明 i可以被 <code>prime[j]</code> 整除，即 i=k×prime[j]。</li><li>此时，<code>i</code> 乘上更大的素数的结果（如 <code>i * prime[j+1]</code>）一定会被 <code>prime[j]</code> 的倍数筛掉。（这里break之后，之后i增大总会到达一个程度使得i是原来时候的i的倍数）</li><li>例如，当 i=4时：<ul><li><code>prime[j] = 2</code>，<code>i * prime[j] = 8</code>。</li><li>因为 <code>4 % 2 == 0</code>，所以 <code>4 * 3 = 12</code> 会被 <code>2</code> 的倍数筛掉（即 <code>6 * 2 = 12</code>，i=6的时候就可以筛掉了）。</li><li>因此，不需要继续标记 <code>4 * 3 = 12</code>，直接跳出循环。</li></ul></li></ul><h2 id="5-5-质因子分解">5.5 质因子分解</h2><p>最后都要归结到若干不同质数的乘积，所以不妨先打个素数表，而打素数表的方法见上文。</p><p>由于每个质因子可能不止出现一次，可以定义一个结构体来存放一个数的质因子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Factor</span>&#123;<br>    <span class="hljs-type">int</span> x,cnt;<br>    <span class="hljs-comment">//x为质因子，cnt为其数目</span><br>&#125;fac[<span class="hljs-number">10</span>];<br></code></pre></td></tr></table></figure><p>这里fac[]数组是存放给定的正整数n的所有质因子，比如对于n=20=2*2*5</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">fac[<span class="hljs-number">0</span>].x=<span class="hljs-number">2</span><br>fac[<span class="hljs-number">0</span>].cnt=<span class="hljs-number">2</span><br>fac[<span class="hljs-number">1</span>].x=<span class="hljs-number">5</span><br>fac[<span class="hljs-number">1</span>].cnt=<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>由于$2<em>3</em>5<em>7</em>11<em>13</em>17<em>19</em>23*29&gt;\mathrm{INT_MAX}$，fac[]开到10就足够了</p><p>我们不难注意到这样一个性质：对于一个合数n，它的质因子要么全部小于等于$\sqrt n$，要么只有一个质因子大于$\sqrt n$，其余的质因子全部小于等于$\sqrt n$</p><p>利用这样的性质我们可以对一个合数n进行质因数分解</p><ol><li><p>首先在素数表中，枚举2~$\sqrt n$的所有素数，试是不是n的质因子</p><p>如果是的话就在fac数组中加入这个因子，然后反复除，每除一次cnt++</p></li><li><p>如果在上面的操作之后n仍然大于1，说明n有且仅有一个大于$\sqrt n$的质因子，而且就是就是现在的n</p></li></ol><p>至此质因数分解完成，时间复杂度为O($\sqrt n$)</p><p>代码实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Factor</span>&#123;<br>    <span class="hljs-type">int</span> x,cnt=<span class="hljs-number">0</span>;<br>&#125;fac[<span class="hljs-number">10</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> prime[<span class="hljs-number">100</span>];<br>    <span class="hljs-type">int</span> temp=n; <span class="hljs-comment">//要在外部用n</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>; prime[i]&lt;=<span class="hljs-built_in">sqrt</span>(temp);i++)&#123;<br>        <span class="hljs-keyword">if</span>(n%prime[i]==<span class="hljs-number">0</span>)&#123;<br>            fac[cnt].x=prime[i];<br>            <span class="hljs-keyword">while</span>(n%prime[i]==<span class="hljs-number">0</span>)&#123;<br>                fac[cnt].cnt++;<br>                n/=prime[i]; <span class="hljs-comment">//注意这两个语句的顺序</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(n&gt;<span class="hljs-number">1</span>)&#123;<br>        fac[cnt++].x=n;<br>        fac[cnt].cnt=<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面来看一道例题</p><blockquote><p><strong>【PAT A1059】 Prime Factors</strong></p><p>给出一个int范围的整数，按照从小到大的顺序输出其分解为质因数的乘法形式</p><p>输入样例</p><p>97532468</p><p>输出样例</p><p>97532468=2^2*11*17*101*1291</p></blockquote><p>代码实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">100005</span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Factor</span>&#123;<br>    <span class="hljs-type">int</span> x,cnt=<span class="hljs-number">0</span>;<br>&#125;fac[<span class="hljs-number">10</span>];<br><br><br><span class="hljs-type">int</span> prime[maxn],cnt;<br><span class="hljs-type">int</span> t[maxn]=&#123;<span class="hljs-number">0</span>&#125;; <span class="hljs-comment">//0表示是素数，1表示不是素数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">findPrime</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;maxn;i++)&#123;<br>        <span class="hljs-keyword">if</span>(!t[i])&#123;<br>            prime[cnt]=i;<br>            cnt++;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+i;j&lt;maxn;j+=i)&#123;<br>                t[j]=<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123; <br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>)&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;1=1&quot;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-built_in">findPrime</span>();<br>    <span class="hljs-type">int</span> temp=n;<br>    <span class="hljs-type">int</span> num=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;prime[i]&lt;=<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">1.0</span>*temp);i++)&#123;<br>        <span class="hljs-keyword">if</span>(n%prime[i]==<span class="hljs-number">0</span>)&#123;<br>            fac[num].x=prime[i];<br>            <span class="hljs-keyword">while</span>(n%prime[i]==<span class="hljs-number">0</span>)&#123;<br>                fac[num].cnt++;<br>                n/=prime[i];<br>            &#125;<br>            num++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(n&gt;<span class="hljs-number">1</span>)&#123;<br>        fac[num].x=n;<br>        fac[num].cnt++;<br>        num++;<br>    &#125;<br>    cout&lt;&lt;temp&lt;&lt;<span class="hljs-string">&#x27;=&#x27;</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;num;i++)&#123;<br>        <span class="hljs-keyword">if</span>(i!=<span class="hljs-number">0</span>) cout&lt;&lt;<span class="hljs-string">&#x27;*&#x27;</span>;<br>        <span class="hljs-keyword">if</span>(fac[i].cnt==<span class="hljs-number">1</span>) cout&lt;&lt;fac[i].x;<br>        <span class="hljs-keyword">else</span> cout&lt;&lt;fac[i].x&lt;&lt;<span class="hljs-string">&#x27;^&#x27;</span>&lt;&lt;fac[i].cnt; <br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>易错点总结：</p><ul><li>在INT_MAX范围内分解，素数表开到10^5就够了</li><li>n==1特判</li><li>main函数开头调用findPrime()</li><li>findPrime函数中<strong>不要写成i&lt;=maxn</strong>是<strong>i&lt;maxn</strong></li><li>要在循环外定义变量储存sqrt(n)</li></ul><h2 id="5-6-大整数运算（高精度）">5.6 大整数运算（高精度）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//大整数的存储：使用数组</span><br><span class="hljs-comment">//整数的高位存储在数组的高位，整数的低位存储在数组的低位</span><br><span class="hljs-comment">//将整数按字符串%s读入的时候实际上是逆位存储的，因此在读入之后需要在另存至d[]数组的时候反转一下</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">bign</span>&#123;<br>    <span class="hljs-type">int</span> d[<span class="hljs-number">1000</span>];<br>    <span class="hljs-type">int</span> len;<br>    <span class="hljs-built_in">bign</span>()&#123; <span class="hljs-comment">//构造函数</span><br>        <span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(d));<br>        len=<span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">//这样在每次定义结构体变量的时候都会自动对此变量进行初始化</span><br><span class="hljs-comment">//而在读入大整数时一般都是先用字符串读入然后再把字符串另存到bign结构体 由于使用char数组进行读入时，与我们想要的顺序是相反的，因此为了让整数在bign中是顺位存储，需要让字符串倒着赋给d[]数组</span><br><span class="hljs-function">bign <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-type">char</span> str[])</span></span>&#123; <span class="hljs-comment">//将整数转换为bign</span><br>    bign a;<br>    a.len=<span class="hljs-built_in">strlen</span>(str);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;a.len;i++)&#123;<br>        a.d[i]=str[a.len-i<span class="hljs-number">-1</span>]-<span class="hljs-string">&#x27;0&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> a;<br>&#125;<br><span class="hljs-comment">//比较两个bign变量的大小：先比len再从高位到低位比较</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(bign a,bign b)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(a.len&gt;b.len) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">//a大</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a.len&lt;b.len) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">//b大</span><br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=a.len<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>            <span class="hljs-keyword">if</span>(a.d[i]&gt;b.d[i]) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a.d[i]&lt;b.d[i]) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">//两数相等</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//高精度加法 必须都得是正数</span><br><span class="hljs-function">bign <span class="hljs-title">add</span><span class="hljs-params">(bign a,bign b)</span></span>&#123;<br>    bign c;<br>    <span class="hljs-type">int</span> carry=<span class="hljs-number">0</span>; <span class="hljs-comment">//carry是进位</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;a.len||i&lt;b.len;i++)&#123; <span class="hljs-comment">//以较长的为界限（想象竖式加法）</span><br>        <span class="hljs-type">int</span> temp=a.d[i]+b.d[i]+carry; <span class="hljs-comment">//两个对应位与进位相加</span><br>        c.d[c.len++]=temp%<span class="hljs-number">10</span>; <span class="hljs-comment">//个位数为该位的结果</span><br>        carry=temp/<span class="hljs-number">10</span>; <span class="hljs-comment">//十位数为新的进位</span><br>    &#125;<br>    <span class="hljs-keyword">if</span>(carry!=<span class="hljs-number">0</span>) &#123;<br>        c.d[c.len++]=carry; <span class="hljs-comment">//如果最后进位不为0，那么直接赋给结果的最高位</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> c;<br>&#125;<br><br><span class="hljs-comment">//高精度减法</span><br><span class="hljs-function">bign <span class="hljs-title">sub</span><span class="hljs-params">(bign a,bign b)</span></span>&#123;<br>    bign c;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;a.len||i&lt;b.len;i++)&#123;<br>        <span class="hljs-keyword">if</span>(a.d[i]&lt;b.d[i])&#123; <span class="hljs-comment">//如果不够减</span><br>            a.d[i<span class="hljs-number">+1</span>]--;<br>            a.d[i]+=<span class="hljs-number">10</span>;<br>        &#125;<br>        c.d[c.len++]=a.d[i]-b.d[i]; <span class="hljs-comment">//减法结果为当前位数结果</span><br>    &#125;<br>    <span class="hljs-keyword">while</span>(c.len<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">1</span>&amp;&amp;c.d[c.len<span class="hljs-number">-1</span>]==<span class="hljs-number">0</span>)&#123; <span class="hljs-comment">//最后一步需要注意减法后高位可能有多余的0，要忽视他们，但是也要保证结果（去掉可能存在的高位0之后）至少有1位数</span><br>        c.len--; <span class="hljs-comment">//忽视高位0</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> c;<br>&#125;<br><span class="hljs-comment">//最后需要指出使用sub函数之前需要比较两个数的大小，如果被减数小于减数，则需要交换两个变量，然后输出负号，再使用sub函数</span><br><br><span class="hljs-comment">//高精度与低精度的乘法</span><br><span class="hljs-function">bign <span class="hljs-title">multi</span><span class="hljs-params">(bign a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>    bign c;<br>    <span class="hljs-type">int</span> carry=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;a.len;i++)&#123;<br>        <span class="hljs-type">int</span> temp=a.d[i]*b+carry;<br>        c.d[c.len++]=temp%<span class="hljs-number">10</span>;<br>        carry=temp/<span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(carry!=<span class="hljs-number">0</span>)&#123; <span class="hljs-comment">//因为乘法的进位可能不止一位所以用while</span><br>        c.d[c.len++]=carry%<span class="hljs-number">10</span>;<br>        carry/=<span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> c;<br>&#125;<br><br><span class="hljs-comment">//高精度与低精度的除法</span><br><span class="hljs-function">bign <span class="hljs-title">divide</span><span class="hljs-params">(bign a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span>&amp; r)</span></span>&#123; <span class="hljs-comment">//r 为余数</span><br>    bign c;<br>    c.len=a.len; <span class="hljs-comment">//被除数的每一位和商的每一位是一一对应的，因此可以先令长度相等 </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=a.len<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i++)&#123; <span class="hljs-comment">//除法从高位开始</span><br>        r=r*<span class="hljs-number">10</span>+a.d[i];<br>        <span class="hljs-keyword">if</span>(r&lt;b) c.d[i]=<span class="hljs-number">0</span>; <span class="hljs-comment">//不够除则这位为0</span><br>        <span class="hljs-keyword">else</span>&#123;<br>            c.d[i]=r/b;<br>            r=r%b;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(c.len<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">1</span>&amp;&amp;c.d[c.len<span class="hljs-number">-1</span>]==<span class="hljs-number">0</span>)&#123;<br>        c.len--;<br>    &#125;<br>    <span class="hljs-keyword">return</span> c;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-7-扩展欧几里得算法">5.7 扩展欧几里得算法</h2><p>待填坑</p><h2 id="5-8-组合数">5.8 组合数</h2><p>待填坑</p><h1>第6章 C++标准模板库(STL)介绍</h1><h2 id="6-1-vector的常见用法详解">6.1 vector的常见用法详解</h2><h3 id="定义方式举例">定义方式举例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; name;<br>vector&lt;<span class="hljs-type">char</span>&gt; name;<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; name; <span class="hljs-comment">//两个&gt;&gt;之间加上空格以防止被识别成移位操作</span><br><span class="hljs-comment">//这个可以理解成两个维度都可以变成的二维数组</span><br></code></pre></td></tr></table></figure><p>定义vector数组的方式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; arr[<span class="hljs-number">100</span>]; <span class="hljs-comment">//这种定义方式就是一维的长度被固定成100了</span><br></code></pre></td></tr></table></figure><h3 id="vector容器内元素的访问">vector容器内元素的访问</h3><h4 id="通过下标访问">通过下标访问</h4><p>就类似普通的数组</p><h4 id="通过迭代器访问">通过迭代器访问</h4><p>迭代器(iterator)可以理解成一种类似指针的东西</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-keyword">typename</span>&gt;::iterator it; <span class="hljs-comment">//it是一个vector&lt;typename&gt;::iterator型的变量</span><br></code></pre></td></tr></table></figure><p>这样就得到了迭代器it，并且可以通过*it来访问vector中的元素，举例如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; vi;<br><span class="hljs-keyword">for</span>(inti=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">5</span>;i++)&#123;<br>    vi.<span class="hljs-built_in">push_back</span>(i); <span class="hljs-comment">//push_back(i)在vi的末尾添加元素i，即依次添加1 2 3 4 5</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以使用类似下标和指针访问数组的方式来访问容器中的元素</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; vi;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">5</span>;i++)&#123;<br>        vi.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br>    <span class="hljs-comment">//vi.begin()为取vi的首元素地址，而it指向这个地址</span><br>    vector&lt;<span class="hljs-type">int</span>&gt;::iterator it=vi.<span class="hljs-built_in">begin</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,*(it+i));<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里可以看出vi[i]==*(vi.begin()+i)<br>再提一下end()函数：取尾元素地址的下一个地址，end()作为迭代器末尾标志不存储任何元素。（美国人思维习惯左闭右开）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; vi;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">5</span>;i++)&#123;<br>        vi.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br>    <span class="hljs-comment">//vector的迭代器不支持it&lt;vi.end()的元素，循环条件只能用it!=vi.end()</span><br>    <span class="hljs-keyword">for</span>(vector&lt;<span class="hljs-type">int</span>&gt;::iterator it=vi.<span class="hljs-built_in">begin</span>();it!=vi.<span class="hljs-built_in">end</span>();it++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,*it);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>强调一下，STL容器中只有在vector和string中才允许vi.begin()+3这种迭代器带上整数的写法</strong></p><h3 id="vector常用函数实例解析">vector常用函数实例解析</h3><h4 id="push-back">push_back()</h4><p>在vector后面增加一个元素(x),时间复杂度O(1),实例见上文</p><h4 id="pop-back">pop_back()</h4><p>直接使用不需要传参,用以删除vector的尾元素,时间复杂度O(1)</p><h4 id="size">size()</h4><p>用以获取vector中元素的个数,返回值unsigned不过一般用%d就可以了，时间复杂度O(1)</p><h4 id="clear">clear()</h4><p>清空vector中的所有元素，时间复杂度O(N),N为vector中元素个数</p><h4 id="insert">insert()</h4><p>insert(it,x)用以向vector的任意迭代器it处插入一个元素x，时间复杂度O(N)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; vi;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">5</span>;i++)&#123;<br>        vi.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br>    vi.<span class="hljs-built_in">insert</span>(vi.<span class="hljs-built_in">begin</span>()<span class="hljs-number">+2</span>,<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;vi.<span class="hljs-built_in">size</span>();i++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,vi[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>是的，对于 <code>std::vector&lt;int&gt; vi</code> 而言，<code>vi + i == vi[i]</code> 并不成立。</p><h3 id="原因分析"><strong>原因分析</strong></h3><ol><li><p><strong><code>vi[i]</code> 的含义：</strong></p><ul><li><code>vi[i]</code> 是 <code>std::vector</code> 提供的操作符重载，用于访问向量中索引为 <code>i</code> 的元素。其底层实现相当于：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">*(vi.<span class="hljs-built_in">begin</span>() + i)<br></code></pre></td></tr></table></figure>其中 <code>vi.begin()</code> 是一个指向 <code>vi</code> 开头元素的迭代器，而迭代器支持偏移。</li></ul></li><li><p><strong><code>vi + i</code> 的含义：</strong></p><ul><li><code>vi</code> 是 <code>std::vector</code> 类型的对象，不是指针或迭代器。C++ 中不允许直接对对象使用加法运算，因此 <code>vi + i</code> 是非法的，会导致编译错误。</li></ul></li></ol><hr><h3 id="正确用法"><strong>正确用法</strong></h3><p>如果想通过指针或迭代器实现类似 <code>vi[i]</code> 的效果，应该使用 <code>vi.begin()</code> 或指针加偏移量。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; vi = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>&#125;;<br>    <br>    <span class="hljs-comment">// 使用下标访问</span><br>    cout &lt;&lt; vi[<span class="hljs-number">2</span>] &lt;&lt; endl;  <span class="hljs-comment">// 输出：30</span><br><br>    <span class="hljs-comment">// 使用迭代器</span><br>    <span class="hljs-keyword">auto</span> it = vi.<span class="hljs-built_in">begin</span>();<br>    cout &lt;&lt; *(it + <span class="hljs-number">2</span>) &lt;&lt; endl;  <span class="hljs-comment">// 输出：30</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="对比：普通数组中的-arr-i-arr-i"><strong>对比：普通数组中的 <code>arr + i == arr[i]</code></strong></h3><p>对于普通数组（如 <code>int arr[5]</code>），<code>arr</code> 是指向数组首元素的指针，因此 <code>arr + i</code> 是合法的，指向数组第 <code>i</code> 个元素的地址。而 <code>arr[i]</code> 其实是通过指针偏移访问到值的语法糖，其本质是 <code>*(arr + i)</code>。</p><hr><h3 id="结论"><strong>结论</strong></h3><p>在 <code>std::vector</code> 中：</p><ul><li><code>vi[i]</code> 是通过索引访问元素的合法操作。</li><li><code>vi + i</code> 是非法的，因为 <code>vi</code> 是一个对象而不是指针。<br>如果需要实现类似 <code>vi[i]</code> 的操作，应使用迭代器或下标索引。</li></ul></blockquote><h4 id="erase">erase()</h4><p>有两种用法：删除单个元素，删除一个区间内的所有元素，时间复杂度均为O(N)</p><ol><li>删除单个元素<br>erase(it)即删除迭代器处的元素</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; vi;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">5</span>;i++)&#123;<br>        vi.<span class="hljs-built_in">push_back</span>(i); <span class="hljs-comment">//1 2 3 4 5</span><br>    &#125;<br>    vi.<span class="hljs-built_in">erase</span>(vi.<span class="hljs-built_in">begin</span>()<span class="hljs-number">+1</span>); <span class="hljs-comment">//删除2 不是vi.begin()+1因为*(vi.begin())==vi[0]</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;vi.<span class="hljs-built_in">size</span>();i++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,vi[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>删除一个区间之内的所有元素<br>erase(first,last)即删除[first,last)内的所有元素<br>由此可见vi.clear()等价于vi.erase(vi.begin(),vi.end())</li></ol><h2 id="6-2-set的常见用法详解">6.2 set的常见用法详解</h2><p>set，也就是集合，是一个<strong>内部自动有序</strong>而且<strong>不含重复元素</strong>的容器</p><h3 id="set的定义">set的定义</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">set&lt;<span class="hljs-keyword">typename</span>&gt; name;<br></code></pre></td></tr></table></figure><p>类似vector,或者说绝大部分STL的定义方式都是这样的</p><h3 id="set容器内元素的访问">set容器内元素的访问</h3><p>set只能通过迭代器访问</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">set&lt;<span class="hljs-type">int</span>&gt;::iterator it;<br></code></pre></td></tr></table></figure><p><strong>除vector和string以外的STL容器都不支持*(it+i)的访问方式</strong>所以只能这样枚举</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    set&lt;<span class="hljs-type">int</span>&gt; st;<br>    st.<span class="hljs-built_in">insert</span>(<span class="hljs-number">2</span>);<br>    st.<span class="hljs-built_in">insert</span>(<span class="hljs-number">1</span>);<br>    st.<span class="hljs-built_in">insert</span>(<span class="hljs-number">3</span>);<br>    st.<span class="hljs-built_in">insert</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-comment">//不支持it&lt;st.end()</span><br>    <span class="hljs-keyword">for</span>(set&lt;<span class="hljs-type">int</span>&gt;::iterator it=st.<span class="hljs-built_in">begin</span>();it!=st.<span class="hljs-built_in">end</span>();it++)&#123;<br>        cout&lt;&lt;*it;<br>    &#125; <span class="hljs-comment">//要理解迭代器，不是针对一个对象，而是这个类中的一种数据类型</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>由此可见set内的元素<strong>自动升序排序</strong>而且自动<strong>去除重复元素</strong></p><h3 id="set常用函数实例解析">set常用函数实例解析</h3><h4 id="insert-2">insert()</h4><p>会有自动递增排序和去重，时间复杂度O(logN)</p><h4 id="find">find()</h4><p>find(value)返回set中对应值为value的迭代器，时间复杂度O(logN)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    set&lt;<span class="hljs-type">int</span>&gt; st;<br>    st.<span class="hljs-built_in">insert</span>(<span class="hljs-number">2</span>);<br>    st.<span class="hljs-built_in">insert</span>(<span class="hljs-number">1</span>);<br>    st.<span class="hljs-built_in">insert</span>(<span class="hljs-number">3</span>);<br>    st.<span class="hljs-built_in">insert</span>(<span class="hljs-number">1</span>);<br>    set&lt;<span class="hljs-type">int</span>&gt;::iterator it=st.<span class="hljs-built_in">find</span>(<span class="hljs-number">2</span>);<br>    cout&lt;&lt;*it&lt;&lt;endl; <span class="hljs-comment">//输出2</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果查找不到就会返回st.end()，可以用这个功能搭配set<string>实现复杂的hash</p><h4 id="erase-2">erase()</h4><ol><li><ul><li>st.erase(it) 删除单个元素(对应迭代器处的)，可以结合find函数来使用 时间复杂度为O(1)</li><li>st.erase(value) 删除单个元素(值为value的) 时间复杂度为O(logN)</li><li>为什么可以这样？因为value的类型是typename，而it的类型是set<typename>::iterator</li></ul></li><li>删除一个区间之内的所有元素 st.erase(first,last)，其中first和last都是迭代器，时间复杂度为O(last-first)</li></ol><h4 id="size-2">size()</h4><p>略了，O(1)</p><h4 id="clear-2">clear()</h4><p>O(N)</p><h2 id="6-3-string的常见用法详解">6.3 string的常见用法详解</h2><h3 id="string的定义">string的定义</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">string str;<br>string str1=<span class="hljs-string">&quot;abcd&quot;</span>;<br></code></pre></td></tr></table></figure><h3 id="string中内容的访问">string中内容的访问</h3><h4 id="通过下标访问-2">通过下标访问</h4><p>就像访问字符数组那样去访问string</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    string str=<span class="hljs-string">&quot;abcd&quot;</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;str.<span class="hljs-built_in">length</span>();i++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, str[i]); <span class="hljs-comment">//输出abcd</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果要读入和输出整个字符串那就<strong>只能用cin和cout</strong></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    string str;<br>    cin&gt;&gt;str;<br>    cout&lt;&lt;str;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>不过真的要使用printf也可以使用c_str()强转</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    string str=<span class="hljs-string">&quot;abcd&quot;</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, str.<span class="hljs-built_in">c_str</span>());<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="通过迭代器访问-2">通过迭代器访问</h4><p>主要是有些函数比如insert()和erase()要求迭代器为参数<br>由于定义string的时候并没有&lt;typename&gt;这一项，因此可以直接这样定义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">string::iterator it;<br></code></pre></td></tr></table></figure><p>那么就可以使用迭代器来对string进行遍历了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    string str=<span class="hljs-string">&quot;abcd&quot;</span>;<br>    <span class="hljs-keyword">for</span>(string::iterator it=str.<span class="hljs-built_in">begin</span>();it!=<span class="hljs-built_in">end</span>();it++)&#123;<br>        cout&lt;&lt;*it;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里循环条件也可以写成it&lt;str.end()，<strong>因为只有vector和string支持这样的对迭代器比如str.begin()+3直接加减某个数字的操作</strong></p><h3 id="string常用函数实例解析">string常用函数实例解析</h3><h4 id="operator">operator+=</h4><p>可以把两个string直接拼接起来</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    string str1=<span class="hljs-string">&quot;abc&quot;</span>,str2=<span class="hljs-string">&quot;xyz&quot;</span>,str3;<br>    str3=str1+str2;<br>    cout&lt;&lt;str3; <span class="hljs-comment">//abcxyz</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="compare-operator">compare operator</h4><p>两个string类型直接用比较运算符比较大小，依据是字典序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">if</span>(str1&gt;str2)&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="length-或-size">length() 或 size()</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs CPP">str.<span class="hljs-built_in">length</span>();<br>str.<span class="hljs-built_in">size</span>();<br></code></pre></td></tr></table></figure><p>均返回string的长度且基本相同，时间复杂度O(1)</p><h4 id="insert-3">insert()</h4><p>string的insert()函数有多种写法，时间复杂度均为O(N)</p><ol><li>insert(pos,string),在pos号位置插入字符串string<br><strong>这个pos号位可以是0</strong></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs CPP">string str1=<span class="hljs-string">&quot;abc&quot;</span>,str2=<span class="hljs-string">&quot;opq&quot;</span>;<br>str<span class="hljs-number">1.</span><span class="hljs-built_in">insert</span>(<span class="hljs-number">3</span>,str2); <span class="hljs-comment">//往str[3]处插入opq，这里也可以直接写&quot;opq&quot;</span><br>cout&lt;&lt;str1&lt;&lt;endl; <span class="hljs-comment">//abcopq</span><br></code></pre></td></tr></table></figure><ol start="2"><li>insert(it,it2,it3), it为原字符串的欲插入位置，it2和it3为待插入字符串的首尾迭代器，用以表示[it2,it3)将被插入it的位置上</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs CPP">string str1=<span class="hljs-string">&quot;abc&quot;</span>,str2=<span class="hljs-string">&quot;opq&quot;</span>;<br>str.<span class="hljs-built_in">insert</span>(str.<span class="hljs-built_in">begin</span>(),str<span class="hljs-number">2.</span>begin,str<span class="hljs-number">2.</span><span class="hljs-built_in">end</span>());<br>cout&lt;&lt;str1&lt;&lt;endl; <span class="hljs-comment">//abcopq</span><br></code></pre></td></tr></table></figure><h4 id="erase-3">erase()</h4><p>时间复杂度均为O(N)</p><ol><li>删除单个元素</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CPP">str.<span class="hljs-built_in">erase</span>(it);<br></code></pre></td></tr></table></figure><ol><li>删除一个区间内的所有元素 两种方法<ul><li>str.erase(first,last) <strong>均为迭代器</strong></li><li>str.erase(pos,length) pos为起始位置(<strong>不是迭代器</strong>),length为删除的字符个数</li></ul> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs CPP">string str=<span class="hljs-string">&quot;abcdefg&quot;</span>;<br>str.<span class="hljs-built_in">erase</span>(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>); <span class="hljs-comment">//删除c和d，从第三位开始的两个(包括第三位)</span><br></code></pre></td></tr></table></figure><strong>这个pos号位可以是0</strong></li></ol><h4 id="clear-3">clear()</h4><p>O(1)</p><h4 id="substr">substr()</h4><p>substr(pos,len)返回从pos号位开始、长度为len的子串，时间复杂度为O(len)，示例如下、</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    string str=<span class="hljs-string">&quot;Thank you for your smile.&quot;</span>;<br>    cout&lt;&lt;str.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>,<span class="hljs-number">5</span>)&lt;&lt;endl; <span class="hljs-comment">//Thank</span><br>    cout&lt;&lt;str.<span class="hljs-built_in">substr</span>(<span class="hljs-number">14</span>,<span class="hljs-number">4</span>)&lt;&lt;endl; <span class="hljs-comment">//Your</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>这个pos号位可以是0</strong></p><h4 id="string-npos">string::npos</h4><p>string::npos是一个常数其本身的值为-1，但是由于其本身是unsigned_int类型，也可以认为是unsigned_int类型的最大值。string::npos作为find函数失配时候的返回值，可以认为string::npos=-1或4294967295</p><h4 id="find-2">find()</h4><ul><li>str.find(str2),当str2是str的子串的时候，返回其在str中第一次出现的位置（不是迭代器）；如果str2不是str的子串，返回string::npos</li><li>str.find(str2,pos)从pos位开始匹配str2，返回值与上面的相同<br>时间复杂度O(mn)，m和n分别是两个数组的长度</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> main&#123;<br>string str =<span class="hljs-string">&quot;Thank you for your smile.&quot;</span><br>string str2 <span class="hljs-string">&quot;you&quot;</span>;<br>string str3 <span class="hljs-string">&quot;me&quot;</span>;<br><span class="hljs-keyword">if</span> (str.<span class="hljs-built_in">find</span> (str2) string!=npos)<br>cout &lt;&lt; str.få<span class="hljs-built_in">nd</span> (str2) &lt;&lt; endl;<br><span class="hljs-keyword">if</span> (str.<span class="hljs-built_in">find</span>(str2, <span class="hljs-number">7</span>) String:!=npos) (<br>cout str.<span class="hljs-built_in">find</span> (str2, <span class="hljs-number">7</span>) endl;<br><span class="hljs-keyword">if</span> (str. <span class="hljs-built_in">find</span> (str3) String:!=npos)<br>cout &lt;&lt; Str. <span class="hljs-built_in">find</span>(str3) endl;<br>) <span class="hljs-keyword">else</span> &#123;<br>cout <span class="hljs-string">&quot;I know there is no position for me.&quot;</span> &lt;&lt; endl;&#125;<br><span class="hljs-keyword">return</span> O;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-number">6</span><br><span class="hljs-number">14</span><br>I know there is no position <span class="hljs-keyword">for</span> me.<br></code></pre></td></tr></table></figure><h4 id="replace">replace()</h4><ul><li>str.replace(pos,len,str2)将str从pos号位开始、长度为len的子串替换为str2</li><li>str.replace(it1,it2,str2)把str的迭代器[it1,it2)范围内的子串替换为st2</li><li>时间复杂度为O(str.length())</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    string str=<span class="hljs-string">&quot;Maybe you will turn around&quot;</span>;<br>    string str2=<span class="hljs-string">&quot;will not&quot;</span>;<br>    string str3=<span class="hljs-string">&quot;surely&quot;</span>;<br>    cout&lt;&lt;str.<span class="hljs-built_in">replace</span>(<span class="hljs-number">10</span>,<span class="hljs-number">4</span>,str2)&lt;&lt;endl;<br>    cout&lt;&lt;str.<span class="hljs-built_in">replace</span>(str.<span class="hljs-built_in">begin</span>(),str.<span class="hljs-built_in">begin</span>()<span class="hljs-number">+5</span>,str3);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs CPP">Maybe you will <span class="hljs-keyword">not</span> turn around<br>surely you will <span class="hljs-keyword">not</span> turn around<br></code></pre></td></tr></table></figure><h4 id="c-str">c.str()</h4><p>可以将string转换成char []，之后就可以使用sprintf和sscanf函数了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">sscanf</span>(login_date.<span class="hljs-built_in">c_str</span>(),<span class="hljs-string">&quot;%d-%d&quot;</span>,&amp;year,&amp;month);<br></code></pre></td></tr></table></figure><h3 id="PAT-A1060-ARE-THEY-EQUAL">PAT A1060 ARE THEY EQUAL</h3><h2 id="6-4-map的常用用法详解">6.4 map的常用用法详解</h2><p>map翻译为映射(<strong>其实这里只能是一个单射</strong>),比如数组 typename arr[]就是int类型向其他类型的一个映射，但是map可以将任何基本类型（包括STL容器）映射到任何基本类型（包括STL容器）,比如string到int的映射</p><h3 id="map的定义">map的定义</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CPP">map&lt;typename1,typename2&gt; mp;<br></code></pre></td></tr></table></figure><p>前一个是映射前类型(键key)，后一个是映射后类型(value)<br>如果是字符串到整型的映射，<strong>必须使用string而不能使用char数组</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CPP">map&lt;string,<span class="hljs-type">int</span>&gt; mp;<br></code></pre></td></tr></table></figure><p>这是因为char作为数组是不能作为键值的，所以只能使用string<br>也有这样的map</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CPP">map&lt;set&lt;<span class="hljs-type">int</span>&gt;,string&gt; mp;<br></code></pre></td></tr></table></figure><h3 id="map容器内元素的访问">map容器内元素的访问</h3><p>map有两种访问方式</p><h4 id="通过下标访问-3">通过下标访问</h4><p>和访问普通的数组的方式一样，比如对于一个定义为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CPP">map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">int</span>&gt; mp;<br></code></pre></td></tr></table></figure><p>的map来说，就可以使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CPP">mp[<span class="hljs-string">&#x27;c&#x27;</span>]<br></code></pre></td></tr></table></figure><p>的方式来访问它的对应的int<br>但是需要注意，和函数一样，map中的键是唯一的，比如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs CPP">map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">int</span>&gt; mp;<br>mp[<span class="hljs-string">&#x27;c&#x27;</span>]=<span class="hljs-number">20</span>;<br>mp[<span class="hljs-string">&#x27;c&#x27;</span>]=<span class="hljs-number">30</span>; <span class="hljs-comment">//20被覆盖</span><br>cout&lt;&lt;mp[<span class="hljs-string">&#x27;c&#x27;</span>]; <span class="hljs-comment">//输出30</span><br></code></pre></td></tr></table></figure><h4 id="通过迭代器访问-3">通过迭代器访问</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CPP">map&lt;typename1,typename2&gt;::iterator it;<br></code></pre></td></tr></table></figure><p>由于map的每一对映射都有两个typename，因此一个it必须可以同时访问键和值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs CPP">it-&gt;first <span class="hljs-comment">//访问键</span><br>it-&gt;second <span class="hljs-comment">//访问值</span><br></code></pre></td></tr></table></figure><p>比如下面这个例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">int</span>&gt; mp;<br>    mp[<span class="hljs-string">&#x27;m&#x27;</span>]=<span class="hljs-number">20</span>;<br>    mp[<span class="hljs-string">&#x27;r&#x27;</span>]=<span class="hljs-number">30</span>;<br>    mp[<span class="hljs-string">&#x27;a&#x27;</span>]=<span class="hljs-number">40</span>;<br>    <span class="hljs-keyword">for</span>(map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">int</span>&gt;::iterator it=mp.<span class="hljs-built_in">begin</span>();it!=mp.<span class="hljs-built_in">end</span>();it++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c %d\n&quot;</span>,it-&gt;first,it-&gt;second);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs CPP">a <span class="hljs-number">40</span><br>m <span class="hljs-number">20</span><br>r <span class="hljs-number">30</span><br></code></pre></td></tr></table></figure><p>其实由此可见，map会按照键从小到大的顺序自动排序（因为a&lt;m&lt;r）,这个就是类似set的（因为他的底层原理和set一样都是红黑树）</p><h3 id="map常用函数实例解析">map常用函数实例解析</h3><h4 id="find-3">find()</h4><p>find(key)返回键为key的映射的迭代器,时间复杂度O(logN),N为map中映射的个数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs CPP">map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">int</span>&gt; mp;<br>mp[<span class="hljs-string">&#x27;a&#x27;</span>]=<span class="hljs-number">1</span>;<br>mp[<span class="hljs-string">&#x27;b&#x27;</span>]=<span class="hljs-number">2</span>;<br>map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">int</span>&gt;::iterator it=mp.<span class="hljs-built_in">find</span>(<span class="hljs-string">&#x27;b&#x27;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c %d&quot;</span>, it-&gt;first,it-&gt;second);<br></code></pre></td></tr></table></figure><p>输出结果为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CPP">b <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h4 id="erase-可以类比set的学习">erase() 可以类比set的学习</h4><ol><li>删除单个元素<ul><li>mp.erase(it),it为需要删除的元素的迭代器，时间复杂度O(1)，可以搭配find()函数使用</li></ul> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs CPP">map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">int</span>&gt; mp;<br>mp[<span class="hljs-string">&#x27;a&#x27;</span>]=<span class="hljs-number">1</span>;<br>mp[<span class="hljs-string">&#x27;b&#x27;</span>]=<span class="hljs-number">2</span>;<br>map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">int</span>&gt;::iterator it=mp.<span class="hljs-built_in">find</span>(<span class="hljs-string">&#x27;b&#x27;</span>);<br>mp.<span class="hljs-built_in">erase</span>(it); <span class="hljs-comment">//删除b 2</span><br></code></pre></td></tr></table></figure><ul><li>mp.erase(key),key为欲删除的映射的键,时间复杂度O(logN)</li></ul> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs CPP">map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">int</span>&gt; mp;<br>mp[<span class="hljs-string">&#x27;a&#x27;</span>]=<span class="hljs-number">1</span>;<br>mp[<span class="hljs-string">&#x27;b&#x27;</span>]=<span class="hljs-number">2</span>;<br>mp.<span class="hljs-built_in">erase</span>(<span class="hljs-string">&#x27;b&#x27;</span>); <span class="hljs-comment">//删除b 2</span><br></code></pre></td></tr></table></figure></li><li>删除一个区间之内的所有元素<br>mp.erase(first,last),传入的都是迭代器,删除[first,last)内的元素,时间复杂度O(last-first)</li></ol><h4 id="size-3">size()</h4><p>O(1)，获得映射的对数</p><h4 id="clear-4">clear()</h4><p>O(N)</p><h3 id="常见用途">常见用途</h3><ol><li>建立char或者string与int之间的映射</li><li>把map当bool数组使用</li></ol><h2 id="6-5-queue的常见用法详解">6.5 queue的常见用法详解</h2><h3 id="queue的定义">queue的定义</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">queue &lt;<span class="hljs-keyword">typename</span>&gt; name;<br></code></pre></td></tr></table></figure><h3 id="queue容器内元素的访问">queue容器内元素的访问</h3><p>由于queue是先进先出的，因此在STL中只能通过front()来访问队首元素或者使用back()来访问队尾元素</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">5</span>;i++)&#123;<br>        q.<span class="hljs-built_in">push</span>(i);<br>    &#125;<br>    cout&lt;&lt;q.<span class="hljs-built_in">front</span>()&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>&lt;&lt;q.<span class="hljs-built_in">back</span>(); <span class="hljs-comment">//输出1 5</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="queue常用函数实例解析">queue常用函数实例解析</h3><h4 id="push">push()</h4><p>把x推入queue</p><h4 id="front-back">front() back()</h4><p>获得队首元素和队尾元素</p><h4 id="pop">pop()</h4><p>令队首元素出队</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">5</span>;i++)&#123;<br>        q.<span class="hljs-built_in">push</span>(i);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">3</span>;i++)&#123;<br>        q.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">//弹出1 2 3</span><br>    &#125;<br>    cout&lt;&lt;q.<span class="hljs-built_in">front</span>()&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>&lt;&lt;q.<span class="hljs-built_in">back</span>(); <span class="hljs-comment">//输出4 5</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="empty">empty()</h4><p>返回true则为空，返回false则为非空</p><h4 id="size-4">size()</h4><p>返回queue内元素的个数</p><h3 id="queue的常见用途">queue的常见用途</h3><p>广度优先搜索</p><p><strong>需要注意的是使用front()和pop()之前需要使用empty()判断是否为空</strong></p><h2 id="6-5-deque的常见用法详解">6.5+ deque的常见用法详解</h2><h3 id="deque的定义">deque的定义</h3><p>类似queue</p><h3 id="deque容器内元素的访问">deque容器内元素的访问</h3><p>类似queue</p><h3 id="deque常用函数">deque常用函数</h3><h4 id="push-back-2">push_back()</h4><p>在末尾添加元素</p><h4 id="push-front">push_front()</h4><p>在前端添加元素</p><h4 id="pop-front-和pop-back">pop_front()和pop_back()</h4><h4 id="front-和back">front()和back()</h4><h4 id="size-和clear">size()和clear()</h4><h2 id="6-6-priority-queue的常见用法详解">6.6 priority_queue的常见用法详解</h2><p>priority_queue又称优先队列，底层使用<strong>堆</strong>来实现。在优先队列中队首元素一定是当前队列中优先级最大的那一个</p><p>例如在队列中有以下元素且指定好了优先级</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">桃子（优先级<span class="hljs-number">3</span>）<br>梨子（优先级<span class="hljs-number">4</span>）<br>苹果（优先级<span class="hljs-number">1</span>）<br></code></pre></td></tr></table></figure><p>那么出队的顺序为梨子（优先级4）→桃子（优先级3）→苹果（优先级1）</p><p>当然，可以在任何时候往优先队列里push元素，而优先队列底层的数据结构堆(heap)会随时调整结构，使得<strong>每次出来的队首元素都是优先级最大的</strong></p><p>关于这里的优先级，则是规定出来的，在上面的例子中也可以规定数字越小的优先级越大</p><h3 id="priority-queue的定义">priority_queue的定义</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">priority_queue&lt;<span class="hljs-keyword">typename</span>&gt; name;<br></code></pre></td></tr></table></figure><h3 id="priority-queue容器内元素的访问">priority_queue容器内元素的访问</h3><p>与queue不一样的是priority_queue没有front()和back()函数，<strong>只能通过top()函数来访问队首元素</strong>，也就是优先级最高的元素</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    priority_queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>    q.<span class="hljs-built_in">push</span>(<span class="hljs-number">3</span>);<br>    q.<span class="hljs-built_in">push</span>(<span class="hljs-number">2</span>);<br>    cout&lt;&lt;q.<span class="hljs-built_in">top</span>(); <span class="hljs-comment">//输出3</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="priority-queue常见函数实例解析">priority_queue常见函数实例解析</h3><h3 id="push-2">push()</h3><p>O(logN)，N为当前元素个数</p><h4 id="top">top()</h4><p>O(1)</p><p>访问堆顶元素</p><h4 id="pop-2">pop()</h4><p>令队首元素出队</p><p>O(logN)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    priority_queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>    q.<span class="hljs-built_in">push</span>(<span class="hljs-number">3</span>);<br>    q.<span class="hljs-built_in">push</span>(<span class="hljs-number">2</span>);<br>    cout&lt;&lt;q.<span class="hljs-built_in">top</span>(); <span class="hljs-comment">//输出3</span><br>    q.<span class="hljs-built_in">pop</span>();<br>    cout&lt;&lt;q.<span class="hljs-built_in">top</span>(); <span class="hljs-comment">//输出2</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="empty-2">empty()</h4><p>返回true则空，返回false则非空</p><p>O(1)</p><h4 id="size-5">size()</h4><p>返回优先队列内的元素个数</p><p>O(1)</p><h3 id="priority-queue内元素优先级的设置">priority_queue内元素优先级的设置</h3><h4 id="基本数据类型的优先级设置">基本数据类型的优先级设置</h4><p>指的是int double char等可以直接使用的数据类型，优先队列对它们的优先级设置一般是数字大的优先级最高，因此队首元素就是优先队列中元素最大的那个（如果是char类型就是字典序最大的）。</p><p>对于基本数据类型来说下面两种优先队列的定义是等价的（以int类型为例）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">priority_queue&lt;<span class="hljs-type">int</span>&gt; q;<br>priority_queue&lt;<span class="hljs-type">int</span>,vector&lt;<span class="hljs-type">int</span>&gt;,less&lt;<span class="hljs-type">int</span>&gt; &gt; q; <span class="hljs-comment">//注意最后两个&gt;之间有空格</span><br></code></pre></td></tr></table></figure><ul><li><code>vector&lt;int&gt;</code>填写的是用来承载底层数据结构堆(heap)的容器，<code>vector&lt;typename&gt;</code>与之前的typename保持一致</li><li><code>less&lt;int&gt;</code>是对第一个参数的比较类，<strong><code>less&lt;int&gt;</code>表示数字大的优先级越大，而<code>greater&lt;int&gt;</code>表示数字小的优先级越大</strong></li></ul><p>因此如果想要优先队列总是把最小的元素放在队首，只需进行如下定义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">priority_queue&lt;<span class="hljs-type">int</span>,vector&lt;<span class="hljs-type">int</span>&gt;,greater&lt;<span class="hljs-type">int</span>&gt; &gt; q; <span class="hljs-comment">//注意最后两个&gt;之间有空格</span><br></code></pre></td></tr></table></figure><p>事实上即使是基本数据类型也可以使用下面讲解的结构体的优先级设置方法，不过三个参数的写法不太一样了。</p><h4 id="结构体的优先级设置">结构体的优先级设置</h4><p>以本节开头的水果为例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Fruit</span>&#123;<br>string name;<br><span class="hljs-type">int</span> price;<br>&#125;;<br></code></pre></td></tr></table></figure><p>现在希望按水果价格高的为优先级高，就需要重载小于号&quot;&lt;&quot;。<strong>重载是指对已有的运算符进行重新定义</strong>，也就是说，可以改变小于号的功能，写法示例如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Fruit</span> &#123;<br>    string name;<br>    <span class="hljs-type">int</span> price;<br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt; (fruit f1,fruit f2) &#123;<br>        <span class="hljs-keyword">return</span> f<span class="hljs-number">1.</span>price&lt;f<span class="hljs-number">2.</span>price;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>可见Fruit结构体中增加了一个函数，</p><p>其中&quot;friend&quot;为友元，具体含义此处不赘述</p><p>后面的<code>bool operator &lt; (fruit f1,fruit f2)</code>对fruit类型的操作符’&lt;'进行了重载</p><p><strong>重载运算符的本质是对这一种特定的类型而言，运算符的效果不同了！所以可以定义int double set也是可以的</strong></p><p><strong>（重载大于号会造成编译错误，因为从数学上来说只需要重载小于号，即f1&gt;f2等价于判断f2&lt;f1，而f1=f2等价于判断<code>!(f1&lt;f2)&amp;&amp;!(f2&lt;f1)</code>）</strong></p><p>函数内部为<code>return f1.price&lt;f2.price</code>，因此重载之后小于号还是小于号的作用，此时就可以直接定义Fruit类型的优先队列，其内部就是以价格高的水果为优先级高，如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">priority_queue&lt;fruit&gt; q;<br></code></pre></td></tr></table></figure><p>同理如果想要价格低的水果优先级高，那么就只需要把return中的小于号改为大于号</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Fruit</span> &#123;<br>    string name;<br>    <span class="hljs-type">int</span> price;<br>    <span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt; (fruit f1,fruit f2) &#123;<br>        <span class="hljs-keyword">return</span> f<span class="hljs-number">1.</span>price&gt;f<span class="hljs-number">2.</span>price;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>不难注意到此处对于小于号的重载类似于sort中的cmp函数，的确有点相似。参数都是两个变量，返回值都是bool型，但是效果看上去是“相反”的。在排序中若是<code>return f1.price&gt;f2.price</code>，那么则是从高到低排序，但是在优先队列中却是价格低的优先级高</p><p><strong>优先队列的这个函数与sort中的cmp函数的效果是相反的</strong></p><p>也可以像sort的cmp函数一样写在结构体外面，只需要把friend去掉，小于号改成一对小括号，然后把重载的函数写在结构体外面，同时将其拿struct包装起来</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">cmp</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span> <span class="hljs-params">()</span> <span class="hljs-params">(fruit f1,fruit f2)</span></span>&#123;<br><span class="hljs-keyword">return</span> f<span class="hljs-number">1.</span>price&gt;f<span class="hljs-number">2.</span>price; <span class="hljs-comment">//价格小的优先级大，仍然与sort的相反</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种情况下使用之前说的第二种定义方式来定义优先队列</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">priority_queue&lt;fruit,vector&lt;fruit&gt;,cmp&gt; q;<br></code></pre></td></tr></table></figure><p><strong>应当注意到即使是基本数据类型或者其他STL容器（比如set）也可以这样定义优先级</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 使用greater定义降序排序的 set</span><br>    set&lt;<span class="hljs-type">int</span>, greater&lt;<span class="hljs-type">int</span>&gt;&gt; s;<br>    s.<span class="hljs-built_in">insert</span>(<span class="hljs-number">10</span>);<br>    s.<span class="hljs-built_in">insert</span>(<span class="hljs-number">5</span>);<br>    s.<span class="hljs-built_in">insert</span>(<span class="hljs-number">20</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : s) &#123;<br>        cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span>; <span class="hljs-comment">// 输出 20 10 5</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>或者是</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Fruit</span> &#123;<br>    string name;<br>    <span class="hljs-type">int</span> price;<br>&#125;;<br><br><span class="hljs-comment">// 自定义比较函数对象</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">cmp</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> Fruit&amp; f1, <span class="hljs-type">const</span> Fruit&amp; f2)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> f<span class="hljs-number">1.</span>price &gt; f<span class="hljs-number">2.</span>price; <span class="hljs-comment">// 按价格从大到小排序</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 创建一个 set，使用自定义比较函数对象</span><br>    set&lt;Fruit, cmp&gt; fruitSet;<br><br>    <span class="hljs-comment">// 添加元素</span><br>    fruitSet.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-string">&quot;Apple&quot;</span>, <span class="hljs-number">5</span>&#125;);<br>    fruitSet.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-string">&quot;Banana&quot;</span>, <span class="hljs-number">3</span>&#125;);<br>    fruitSet.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-string">&quot;Orange&quot;</span>, <span class="hljs-number">8</span>&#125;);<br><br>    <span class="hljs-comment">// 遍历并输出</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> Fruit&amp; fruit : fruitSet) &#123;<br>        cout &lt;&lt; fruit.name &lt;&lt; <span class="hljs-string">&quot; (&quot;</span> &lt;&lt; fruit.price &lt;&lt; <span class="hljs-string">&quot;)\n&quot;</span>;<br>        <span class="hljs-comment">// 输出 Orange (8)</span><br>        <span class="hljs-comment">//      Apple (5)</span><br>        <span class="hljs-comment">//      Banana (3)</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后指出，如果结构体内的数据较为庞大（例如出现了字符串和数组），<strong>建议使用引用来提高效率</strong>，此时比较类的参数中需要加上<code>const</code>和<code>&amp;</code>，如下所示</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">friend</span> <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-type">const</span> fruit &amp;f1, <span class="hljs-type">const</span> fruie &amp;f2)&#123;<br>    <span class="hljs-keyword">return</span> f<span class="hljs-number">1.</span>price&gt;f<span class="hljs-number">2.</span>price;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">opreator</span> <span class="hljs-params">()</span> <span class="hljs-params">(<span class="hljs-type">const</span> fruit &amp;f1, <span class="hljs-type">const</span> fruie &amp;f2)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> f<span class="hljs-number">1.</span>price&gt;f<span class="hljs-number">2.</span>price;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="priority-queue的常见用途">priority_queue的常见用途</h3><p>可以解决一些贪心问题</p><p><strong>在使用top()函数之前必须判断优先队列是否为空</strong></p><h2 id="6-7-stack的常见用法详解">6.7 stack的常见用法详解</h2><h3 id="stack的定义">stack的定义</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stack&gt;</span></span><br>stack&lt;<span class="hljs-keyword">typename</span>&gt; name;<br></code></pre></td></tr></table></figure><p>typename可以是任何基本数据类型或容器</p><h3 id="stack容器内元素的访问">stack容器内元素的访问</h3><p>由于stack本身就是一种后进先出的数据结构，<strong>在STL中的stack只能通过top()来访问栈顶元素</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    stack&lt;<span class="hljs-type">int</span>&gt; st;<br>    st.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>    st.<span class="hljs-built_in">push</span>(<span class="hljs-number">2</span>);<br>    cout&lt;&lt;st.<span class="hljs-built_in">top</span>(); <span class="hljs-comment">//输出2</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="stack常用函数实例解析">stack常用函数实例解析</h3><h4 id="push-3">push()</h4><p>O(1) push(x)将x推入栈</p><h4 id="top-2">top()</h4><p>O(1) 获得栈顶元素</p><h4 id="pop-3">pop()</h4><p>O(1) 弹出栈顶元素，示例如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    stack&lt;<span class="hljs-type">int</span>&gt; st;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">5</span>;i++)&#123;<br>        st.<span class="hljs-built_in">push</span>(i); <span class="hljs-comment">//分别把1 2 3 4 5推入栈中</span><br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">3</span>;i++)&#123;<br>        st.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">//相当于推出5 4 3</span><br>    &#125;<br>    cout&lt;&lt;st.<span class="hljs-built_in">top</span>(); <span class="hljs-comment">//输出2</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="empty-3">empty()</h4><p>检测stack是否为空，返回true为空，返回false为非空</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">st.<span class="hljs-built_in">empty</span>()<br></code></pre></td></tr></table></figure><h4 id="size-6">size()</h4><p>返回stack中元素的个数 O(1)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">st.<span class="hljs-built_in">size</span>()<br></code></pre></td></tr></table></figure><h4 id="如何清空栈">如何清空栈</h4><p>没有自带的函数，可以这样写</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>())&#123;<br>st.<span class="hljs-built_in">pop</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>但是更常用的做法是重新定义一个栈来变相实现栈的清空。</p><h3 id="stack的常见用途">stack的常见用途</h3><p>用来模拟实现一些递归，防止程序对栈内存的限制导致程序运行出错</p><h2 id="6-8-pair的常见用法详解">6.8 pair的常见用法详解</h2><p>当想要将两个元素绑在一起作为一个合成元素、又不想因此定义结构体的时候，使用pair可以很方便地作为一个替代品。也就是说pair实际上可以看成一个内部有两个元素的结构体，而且这两个元素的类型是可以指定的。</p><p><strong>有时候运行的速度会比结构体快</strong></p><h3 id="pair的定义">pair的定义</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">pair &lt;typename1,typename2&gt; name;<br></code></pre></td></tr></table></figure><p>等价于</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">pair</span> &#123;<br>    tyoename1 first;<br>    typename2 first;<br>&#125;<br></code></pre></td></tr></table></figure><p>初始化的方式如下(举例)，在后面加一对小括号</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">pair&lt;string,<span class="hljs-type">int</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-string">&quot;haha&quot;</span>,<span class="hljs-number">5</span>)</span></span>;<br></code></pre></td></tr></table></figure><p>而如果想要在代码中临时构建一个pair，有如下两种方法</p><ol><li><p>将类型定义写在前面，后面用小括号内两个元素的方式</p></li><li><p>使用自带的make_pair函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">make_pair</span>(<span class="hljs-string">&quot;haha&quot;</span>,<span class="hljs-number">5</span>);<br></code></pre></td></tr></table></figure></li></ol><h3 id="pair中元素的访问">pair中元素的访问</h3><p>pair中只有两个元素first和second，按照正常结构体的方式去访问即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">pair&lt;string,<span class="hljs-type">int</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-string">&quot;haha&quot;</span>,<span class="hljs-number">5</span>)</span></span>;<br>cout&lt;&lt;p.first; <span class="hljs-comment">//输出haha</span><br>cout&lt;&lt;p.second; <span class="hljs-comment">//输出5</span><br></code></pre></td></tr></table></figure><h3 id="pair常用函数实例解析">pair常用函数实例解析</h3><p><strong>比较操作数</strong></p><p>两个pair型可以直接比较大小，比较规则是<strong>先以first的大小作为标准，只有当first相等时才去判别second的大小</strong></p><h3 id="pair的常见用途">pair的常见用途</h3><ol><li><p>用来代替二元结构体及其构造函数，可以节省编码时间</p></li><li><p>作为map的键值对来进行插入，比如下面的例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    map&lt;string,<span class="hljs-type">int</span>&gt; mp;<br>    mp.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-string">&quot;abc&quot;</span>,<span class="hljs-number">123</span>));<br>    mp.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-string">&quot;efg&quot;</span>,<span class="hljs-number">456</span>));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:mp)&#123;<br>        cout&lt;&lt;x.first&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>&lt;&lt;x.second&lt;&lt;endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">abc <span class="hljs-number">123</span><br>efg <span class="hljs-number">456</span><br></code></pre></td></tr></table></figure><p>这是因为map的内部实现中涉及到了pair</p></li></ol><h2 id="6-9-常用算法函数">6.9 常用算法函数</h2><h3 id="6-9-1-max-、min-和abs">6.9.1 max()、min()和abs()</h3><p>含义显然。</p><p><code>max()</code>和<code>min()</code>的参数可以是int也可以是浮点数；想求三个数的最大值的时候可以这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">max</span>(x,<span class="hljs-built_in">max</span>(y,z));<br></code></pre></td></tr></table></figure><p>也可以这样</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">max</span>(&#123;x,y,z&#125;);<br></code></pre></td></tr></table></figure><p><code>abs()</code><strong>的形参只能是整数</strong></p><h3 id="6-9-2-swap">6.9.2 swap()</h3><p><code>swap(x,y)</code>用来交换x,y的值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> x=<span class="hljs-number">1</span>,y=<span class="hljs-number">2</span>;<br><span class="hljs-built_in">swap</span>(x,y);<br>cout&lt;&lt;x&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>&lt;&lt;y; <span class="hljs-comment">//输出2 1</span><br></code></pre></td></tr></table></figure><h3 id="6-9-3-reverse">6.9.3 reverse()</h3><p><code>reverse(it1,it2)</code>可以将<strong>数组指针</strong>在[it1，it2)之间的元素或容器的<strong>迭代器</strong>在[it1，it2)范围内的元素进行反转</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//对数组进行反转</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">5</span>]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-built_in">reverse</span>(a,a<span class="hljs-number">+5</span>); <span class="hljs-comment">//将a[0]~a[4]反转</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>        cout&lt;&lt;a[i]&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>; <span class="hljs-comment">//输出5 4 3 2 1</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>容器也可以 <strong>一定得是迭代器</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    string str=<span class="hljs-string">&quot;abcdefg&quot;</span>;<br>    <span class="hljs-built_in">reverse</span>(str.<span class="hljs-built_in">begin</span>(),str.<span class="hljs-built_in">begin</span>()<span class="hljs-number">+3</span>); <span class="hljs-comment">//对str[0]~str[2]进行反转</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;str.<span class="hljs-built_in">length</span>();i++)&#123;<br>        cout&lt;&lt;str[i]&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>; <span class="hljs-comment">//输出cbadefg</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-9-4-next-permutation">6.9.4 next_permutation()</h3><p><code>next_permutation()</code>给出一个序列在全排列中的下一个序列</p><p>比如当n==3时的全排列为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">123</span><br><span class="hljs-number">132</span><br><span class="hljs-number">213</span><br><span class="hljs-number">231</span><br><span class="hljs-number">312</span><br><span class="hljs-number">321</span><br></code></pre></td></tr></table></figure><p>这样231的下一个序列就是312</p><p>示例如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">10</span>]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br>    <span class="hljs-comment">//a[0]~a[2]之间的序列需要求解next_permutation</span><br>    <span class="hljs-keyword">do</span>&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d%d%d\n&quot;</span>,a[<span class="hljs-number">0</span>],a[<span class="hljs-number">1</span>],a[<span class="hljs-number">2</span>]);<br>    &#125;<span class="hljs-keyword">while</span>(<span class="hljs-built_in">next_permutation</span>(a,a<span class="hljs-number">+3</span>));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">123</span><br><span class="hljs-number">132</span><br><span class="hljs-number">213</span><br><span class="hljs-number">231</span><br><span class="hljs-number">312</span><br><span class="hljs-number">321</span><br></code></pre></td></tr></table></figure><p>在上述代码中使用循环是因为<code>next_permutation</code>在已经到达全排列的最后一个时会返回<code>false</code>，这样方便退出循环。而使用<code>do...while</code>语句而不使用<code>while</code>是因为序列1 2 3本身也需要输出</p><h3 id="6-9-5-fill">6.9.5 fill()</h3><p><code>fill()</code>可以把数组或容器内某一段区间赋为某个相同的值。不同于<code>memset</code>只能赋0或-1，这里随便赋</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> a[<span class="hljs-number">5</span>];<br><span class="hljs-built_in">fill</span>(a,a<span class="hljs-number">+5</span>,<span class="hljs-number">233</span>);<br><span class="hljs-comment">//a[5]=&#123;233,233,233,233,233&#125;;</span><br></code></pre></td></tr></table></figure><h3 id="6-9-6-sort">6.9.6 sort()</h3><h4 id="如何使用sort函数">如何使用sort函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">sort</span>(首元素地址（必填），尾元素地址的下一个地址，比较函数（非必填）);<br></code></pre></td></tr></table></figure><p>不写比较函数则默认递增排序</p><h4 id="如何实现比较函数cmp">如何实现比较函数cmp</h4><h5 id="基本数据类型数组的排序">基本数据类型数组的排序</h5><p>比如要对一个数组实现降序排序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a&gt;b; <span class="hljs-comment">//可以理解成当a&gt;b的时候把a放在b前面</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>记忆方法</strong>：如果要升序，就用’&lt;‘，因为&quot;a&lt;b&quot;就是左小右大；如果要降序，就用’&gt;'，因为&quot;a&gt;b&quot;就是左大右小</p><h5 id="结构体数组的排序">结构体数组的排序</h5><p>比如如下的结构体</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>    <span class="hljs-type">int</span> x,y;<br>&#125;ssd[<span class="hljs-number">10</span>];<br></code></pre></td></tr></table></figure><p>如果进行按照x的一级排序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(node a,node b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a.x&gt;b.x;<br>&#125;<br></code></pre></td></tr></table></figure><p>二级排序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(node a,node b)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(a.x!=b.x) <span class="hljs-keyword">return</span> a.x&lt;b.x;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> a.y&lt;b.y;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然也可以使用重载运算符</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-type">int</span> b;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-type">const</span> node &amp;other) <span class="hljs-type">const</span>&#123;<br>        <span class="hljs-keyword">return</span> x&lt;other.x;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="容器的排序">容器的排序</h5><p>在STL标准容器中只有**<code>vector</code>,<code>string</code>,<code>deque</code>**可以使用sort</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//以vector为例</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a&gt;b; <span class="hljs-comment">//降序</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; vi;<br>    vi.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2</span>);<br>    vi.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">3</span>);<br>    vi.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>;<br>   <span class="hljs-built_in">sort</span>(vi.<span class="hljs-built_in">begin</span>(),vi.<span class="hljs-built_in">end</span>(),cmp); <span class="hljs-comment">//3 2 1</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//以string为例</span><br>string str[<span class="hljs-number">3</span>]=&#123;<span class="hljs-string">&quot;aa&quot;</span>,<span class="hljs-string">&quot;bbbb&quot;</span>,<span class="hljs-string">&quot;ccc&quot;</span>&#125;;<br><span class="hljs-built_in">sort</span>(str,str<span class="hljs-number">+3</span>); <span class="hljs-comment">//按照字典序</span><br><span class="hljs-comment">//或者按照长度排序</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(string s1,string s2)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> s<span class="hljs-number">1.l</span>ength()&lt;s<span class="hljs-number">2.l</span>ength(); <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-9-7-lower-bound-和upper-bound">6.9.7 lower_bound()和upper_bound()</h3><p>这两个函数需要用在一个<strong>有序</strong>数组或容器中，在4.5.1节已经讨论过了它们的实现</p><p><code>lower_bound(first,last,val)</code>用来寻找在数组或容器的[first,last)范围内<strong>第一个值大于等于val的元素的位置</strong>，如果是数组则返回该位置的指针；如果是容器则返回该位置的迭代器</p><p><code>upper_bound(first,last,val)</code>用来寻找在数组或容器的[first,last)范围内<strong>第一个值大于val的元素的位置</strong>，如果是数组则返回该位置的指针；如果是容器则返回该位置的迭代器</p><p>如果数组或容器中没有需要寻找的元素，则这两个函数均返回可以插入该元素位置的指针或迭代器（即假设存在该元素时，该元素应该在的位置）</p><p>时间复杂度O(log(last-first))</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">10</span>]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-type">int</span>* lowerPos;<br>    <span class="hljs-type">int</span>* upperPos;<br>    <span class="hljs-comment">//寻找3</span><br>    lowerPos=<span class="hljs-built_in">lower_bound</span>(a,a<span class="hljs-number">+10</span>,<span class="hljs-number">3</span>);<br>    upperPos=<span class="hljs-built_in">upper_bound</span>(a,a<span class="hljs-number">+10</span>,<span class="hljs-number">3</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,lowerPos-a,upperPos-a); <span class="hljs-comment">//输出3 6</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可见如果只是想获得欲查元素的下标，就可以不使用临时指针，<strong>直接令返回值减去数组首地址即可</strong></p><h4 id="二分函数的第四个参数：比较函数">二分函数的第四个参数：比较函数</h4><p>当比较体没有明确的比较类型的时候：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ore</span>&#123;<br>  <span class="hljs-type">int</span> w,v;<br>  <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> ore&amp;other)<span class="hljs-type">const</span>&#123;<br>    <span class="hljs-keyword">return</span> w&lt;other.w;<br>  &#125; <span class="hljs-comment">//一定要有重载运算符</span><br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="方法一：构造一个临时对象">方法一：构造一个临时对象</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 假设 Ore 已经按 w 升序排序了</span><br>    vector&lt;ore&gt; Ore = &#123; &#123;<span class="hljs-number">1</span>, <span class="hljs-number">10</span>&#125;, &#123;<span class="hljs-number">3</span>, <span class="hljs-number">20</span>&#125;, &#123;<span class="hljs-number">5</span>, <span class="hljs-number">30</span>&#125;, &#123;<span class="hljs-number">7</span>, <span class="hljs-number">40</span>&#125;, &#123;<span class="hljs-number">9</span>, <span class="hljs-number">50</span>&#125; &#125;;<br>    <br>    <span class="hljs-type">int</span> mid = <span class="hljs-number">6</span>;<br>    <span class="hljs-comment">// 构造一个临时的 ore 对象，w 为 mid，v 可以为任意值</span><br>    ore tmp&#123;mid, <span class="hljs-number">0</span>&#125;;<br>    <br>    <span class="hljs-keyword">auto</span> it = <span class="hljs-built_in">lower_bound</span>(Ore.<span class="hljs-built_in">begin</span>(), Ore.<span class="hljs-built_in">end</span>(), tmp);<br></code></pre></td></tr></table></figure><h5 id="方法二：使用自定义比较器-Lambda">方法二：使用自定义比较器 Lambda</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 假设 Ore 已经按 w 升序排序了</span><br>    vector&lt;ore&gt; Ore = &#123; &#123;<span class="hljs-number">1</span>, <span class="hljs-number">10</span>&#125;, &#123;<span class="hljs-number">3</span>, <span class="hljs-number">20</span>&#125;, &#123;<span class="hljs-number">5</span>, <span class="hljs-number">30</span>&#125;, &#123;<span class="hljs-number">7</span>, <span class="hljs-number">40</span>&#125;, &#123;<span class="hljs-number">9</span>, <span class="hljs-number">50</span>&#125; &#125;;<br>    <br>    <span class="hljs-type">int</span> mid = <span class="hljs-number">6</span>;<br>    <span class="hljs-keyword">auto</span> it = <span class="hljs-built_in">lower_bound</span>(Ore.<span class="hljs-built_in">begin</span>(), Ore.<span class="hljs-built_in">end</span>(), mid, [](<span class="hljs-type">const</span> ore &amp;o, <span class="hljs-type">int</span> value) &#123;<br>        <span class="hljs-keyword">return</span> o.w &lt; value;<br>    &#125;);<br></code></pre></td></tr></table></figure><p>这里传入了一个 lambda 作为比较器，lambda 定义为：给定一个 <code>ore o</code> 和一个 <code>int value</code>，如果 <code>o.w &lt; value</code> 返回 <code>true</code>。</p><p>这样 <code>lower_bound()</code> 会查找第一个满足 <code>!(o.w &lt; mid)</code>（即 <code>o.w &gt;= mid</code>）的元素。</p><h3 id="6-9-8-accumulate">6.9.8 accumulate()</h3><p>这个函数可以帮你计算一个范围内所有元素的累积和，还可以指定初始值和自定义操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;numeric&gt;</span>  <span class="hljs-comment">// 别忘了包含这个头文件</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; nums = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-built_in">accumulate</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;累积和是：&quot;</span> &lt;&lt; sum &lt;&lt; endl; <span class="hljs-comment">//15</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，我们用 <code>accumulate</code> 计算了一个整型向量 <code>nums</code> 中所有元素的和。第三个参数 <code>0</code> 是累积的初始值，也就是从0开始加。最终，<code>sum</code> 变量中保存了所有元素的累积和。</p><h3 id="6-9-10-unique">6.9.10 unique()</h3><p>它能帮助我们去除相邻的重复元素，并返回一个新的范围结束位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; nums = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-keyword">auto</span> it = <span class="hljs-built_in">unique</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>    nums.<span class="hljs-built_in">erase</span>(it, nums.<span class="hljs-built_in">end</span>());<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;去重后的元素是：&quot;</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num : nums) &#123;<br>        cout &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br><span class="hljs-comment">//去重后的元素是：1 2 3 4 5 </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>unique</code> 会将相邻的重复元素移到向量的末尾，然后返回一个新的迭代器 <code>it</code>。接着，我们用 <code>erase</code> 将这些重复的元素移除，最终得到了一个没有相邻重复元素的向量。</p><h3 id="6-10-11-find">6.10.11 find()</h3><p><code>find</code> 函数可以帮你在一个范围内找到第一个等于指定值的元素，并返回指向该元素的迭代器。下面是它的用法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; nums = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>&#125;;<br>    <span class="hljs-keyword">auto</span> it = <span class="hljs-built_in">find</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>(), <span class="hljs-number">30</span>);<br><br>    <span class="hljs-keyword">if</span>(it != nums.<span class="hljs-built_in">end</span>()) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;找到目标元素：&quot;</span> &lt;&lt; *it &lt;&lt; endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;未找到目标元素。&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>find</code> 函数找到了向量 <code>nums</code> 中的元素 <code>30</code>，并返回了指向它的迭代器。如果找不到目标元素，<code>find</code> 会返回 <code>end</code> 迭代器。</p><h3 id="6-10-12-count">6.10.12 count()</h3><p><code>count</code> 函数能帮你数数指定值在一个范围内出现了多少次。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; nums = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-type">int</span> count_of_2 = <span class="hljs-built_in">count</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>(), <span class="hljs-number">2</span>);<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;数字2出现的次数是：&quot;</span> &lt;&lt; count_of_2 &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子里，<code>count</code> 函数计算了数字 <code>2</code> 在向量 <code>nums</code> 中出现的次数，并将结果保存到 <code>count_of_2</code> 变量中。</p><h3 id="6-10-13-partition">6.10.13 partition()</h3><p><code>partition</code> 函数根据指定的条件将范围内的元素分为两部分，使得符合条件的元素位于前半部分。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; nums = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>&#125;;<br>    <span class="hljs-built_in">partition</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">int</span> x)&#123; <span class="hljs-keyword">return</span> x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>; &#125;);<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;分区后的结果是：&quot;</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num : nums) &#123;<br>        cout &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br><span class="hljs-comment">//分区后的结果是：8 2 6 4 5 3 7 1 9 </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里，我们用 <code>partition</code> 将向量 <code>nums</code> 中所有的偶数放在前面，奇数放在后面。这个分区操作利用了一个Lambda表达式来判断元素是否符合条件。</p><h3 id="6-10-14-nth-element">6.10.14 nth_element()</h3><p><code>nth_element()</code> 是 C++ 标准库中的一个算法函数，位于 <code>&lt;algorithm&gt;</code> 头文件中。其主要作用是对容器中的元素进行部分排序，使得第 <code>n</code> 小的元素位于容器的第 <code>n</code> 个位置（从零开始计数）。除此之外，函数保证该位置之前的所有元素都不大于该元素，之后的元素都不小于该元素，但它并不对整个容器进行排序。</p><p>用法如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">nth_element</span>(RandomAccessIterator first, RandomAccessIterator nth, RandomAccessIterator last);<br></code></pre></td></tr></table></figure><ul><li><strong>first</strong>：容器的起始迭代器，指向要处理的第一个元素。</li><li><strong>nth</strong>：一个迭代器，指向所需的 “n” 小元素的位置（即，想要排到第 <code>n</code> 小的位置）。</li><li><strong>last</strong>：容器的末尾迭代器。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 示例数据</span><br>    std::vector&lt;<span class="hljs-type">int</span>&gt; vec = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">8</span>,<span class="hljs-number">6</span>,<span class="hljs-number">10</span>&#125;;<br><br>    <span class="hljs-comment">// 求第 4 小的元素 (index 3)，即在排序后的数组中的第 4 个位置</span><br>    std::<span class="hljs-built_in">nth_element</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">3</span>, vec.<span class="hljs-built_in">end</span>());<br><br>    <span class="hljs-comment">// 输出第 4 小的元素和数组</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;The 4th smallest element: &quot;</span> &lt;&lt; vec[<span class="hljs-number">3</span>] &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 输出部分排序后的数组</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Array after nth_element: &quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : vec) &#123;<br>        std::cout &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">The <span class="hljs-number">4</span>th smallest element: <span class="hljs-number">4</span><br>Array after nth_element: <span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">9</span> <span class="hljs-number">5</span> <span class="hljs-number">8</span> <span class="hljs-number">6</span> <span class="hljs-number">10</span> <br></code></pre></td></tr></table></figure><p>注意，<code>nth_element</code> 并不会对数组做完整的排序。</p><h3 id="6-10-15-is-sorted">6.10.15 is_sorted()</h3><p>检查一个范围内的元素是否已经有序，<strong>默认是</strong>如果是升序或者降序排列就返回true否则返回false，当然也可以自己传入比较函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_sorted</span><span class="hljs-params">(InputIterator first, InputIterator last, Compare comp)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="6-10-16-merge">6.10.16 merge()</h3><p>用于将两个已经排序的范围合并成一个新的排序范围。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>&gt; v1 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>&#125;;<br>std::vector&lt;<span class="hljs-type">int</span>&gt; v2 = &#123;<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>&#125;;<br><span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(<span class="hljs-number">6</span>)</span></span>;<br>    <br>std::<span class="hljs-built_in">merge</span>(v<span class="hljs-number">1.</span><span class="hljs-built_in">begin</span>(), v<span class="hljs-number">1.</span><span class="hljs-built_in">end</span>(), v<span class="hljs-number">2.</span><span class="hljs-built_in">begin</span>(), v<span class="hljs-number">2.</span><span class="hljs-built_in">end</span>(), result.<span class="hljs-built_in">begin</span>());<br></code></pre></td></tr></table></figure><p>其实就是这一段函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> a[],<span class="hljs-type">int</span> b[], <span class="hljs-type">int</span> c[], <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> m)</span></span>&#123;<br>    <span class="hljs-comment">//n和m分别是数组a和b的长度</span><br>    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>,index=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;n&amp;&amp;j&lt;m)&#123;<br>        <span class="hljs-keyword">if</span>(a[i]&lt;=b[j]) c[index++]=a[i++]; <span class="hljs-comment">//相等的情况放a和b都一样</span><br>        <span class="hljs-keyword">else</span> c[index++]=b[j++]; <span class="hljs-comment">//把b[j]放入序列中</span><br>    &#125;<br>    <span class="hljs-keyword">while</span>(i&lt;n) c[index++]=a[i++]; <span class="hljs-comment">//把a的剩余元素放入c中</span><br>    <span class="hljs-keyword">while</span>(j&lt;m) c[index++]=b[j++]; <span class="hljs-comment">//把b的剩余元素放入c中</span><br>    <span class="hljs-keyword">return</span> index; <span class="hljs-comment">//返回序列c的长度</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-10-unordered-set的使用">6.10 unordered_set的使用</h2><p>非常接近于set 只是内部不有序</p><blockquote><h3 id="哈希集合的用法"><strong>哈希集合的用法</strong></h3><p>哈希集合（Hash Set）是一个无序集合，主要用于快速查找、插入和删除操作。它的核心特点是：</p><ul><li>元素<strong>唯一</strong>：集合中不能有重复的元素。</li><li>操作的时间复杂度为 O(1)O(1)（平均情况）。</li><li>哈希集合在C++中由 <code>std::unordered_set</code> 实现。</li></ul><hr><h3 id="常用函数"><strong>常用函数</strong></h3><p>以下是 <code>std::unordered_set</code> 的常用操作：</p><h4 id="1-插入元素"><strong>1. 插入元素</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">unordered_set&lt;<span class="hljs-type">int</span>&gt; s;<br>s.<span class="hljs-built_in">insert</span>(<span class="hljs-number">10</span>);  <span class="hljs-comment">// 插入元素10</span><br>s.<span class="hljs-built_in">insert</span>(<span class="hljs-number">20</span>);  <span class="hljs-comment">// 插入元素20</span><br></code></pre></td></tr></table></figure><h4 id="2-查找元素"><strong>2. 查找元素</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">find</span>(<span class="hljs-number">10</span>) != s.<span class="hljs-built_in">end</span>()) &#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;10在集合中&quot;</span> &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-删除元素"><strong>3. 删除元素</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">s.<span class="hljs-built_in">erase</span>(<span class="hljs-number">10</span>);  <span class="hljs-comment">// 删除元素10</span><br></code></pre></td></tr></table></figure><h4 id="4-清空集合"><strong>4. 清空集合</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">s.<span class="hljs-built_in">clear</span>();  <span class="hljs-comment">// 清空集合</span><br></code></pre></td></tr></table></figure><h4 id="5-获取集合大小"><strong>5. 获取集合大小</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cout &lt;&lt; <span class="hljs-string">&quot;集合大小：&quot;</span> &lt;&lt; s.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br></code></pre></td></tr></table></figure><h4 id="6-判断集合是否为空"><strong>6. 判断集合是否为空</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">empty</span>()) &#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;集合为空&quot;</span> &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="7-遍历集合"><strong>7. 遍历集合</strong></h4><p>由于 <code>unordered_set</code> 是无序的，遍历时的顺序可能和插入顺序不同。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : s) &#123;<br>    cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="8-判断元素是否存在"><strong>8. 判断元素是否存在</strong></h4><p>使用 <code>count</code> 函数，返回值为 <code>0</code> 或 <code>1</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">count</span>(<span class="hljs-number">10</span>)) &#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;10在集合中&quot;</span> &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="实例解析"><strong>实例解析</strong></h3><h4 id="实例1：判断数组中是否有重复元素"><strong>实例1：判断数组中是否有重复元素</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_set&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cout &lt;&lt; <span class="hljs-string">&quot;请输入数组长度：&quot;</span>;<br>    cin &gt;&gt; n;<br><br>    unordered_set&lt;<span class="hljs-type">int</span>&gt; s;<br>    <span class="hljs-type">bool</span> hasDuplicate = <span class="hljs-literal">false</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;请输入数组元素：&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-type">int</span> x;<br>        cin &gt;&gt; x;<br><br>        <span class="hljs-comment">// 如果集合中已经有该元素，则有重复</span><br>        <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">find</span>(x) != s.<span class="hljs-built_in">end</span>()) &#123;<br>            hasDuplicate = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        s.<span class="hljs-built_in">insert</span>(x);  <span class="hljs-comment">// 否则插入集合</span><br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (hasDuplicate) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;数组中有重复的元素！&quot;</span> &lt;&lt; endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;数组中没有重复的元素。&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行示例：</strong></p><p>输入1：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">请输入数组长度：5<br>请输入数组元素：<br>1<span class="hljs-number"> 2 </span>3<span class="hljs-number"> 4 </span>5<br></code></pre></td></tr></table></figure><p>输出1：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">数组中没有重复的元素。<br></code></pre></td></tr></table></figure><p>输入2：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">请输入数组长度：5<br>请输入数组元素：<br>1<span class="hljs-number"> 2 </span>3<span class="hljs-number"> 2 </span>5<br></code></pre></td></tr></table></figure><p>输出2：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">数组中有重复的元素！<br></code></pre></td></tr></table></figure><hr><h4 id="实例2：统计字符串中不重复字符的个数"><strong>实例2：统计字符串中不重复字符的个数</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_set&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    string str;<br>    cout &lt;&lt; <span class="hljs-string">&quot;请输入一个字符串：&quot;</span>;<br>    cin &gt;&gt; str;<br><br>    unordered_set&lt;<span class="hljs-type">char</span>&gt; s;  <span class="hljs-comment">// 使用哈希集合存储字符</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : str) &#123;<br>        s.<span class="hljs-built_in">insert</span>(c);  <span class="hljs-comment">// 每个字符插入集合</span><br>    &#125;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;不重复字符的个数：&quot;</span> &lt;&lt; s.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行示例：</strong></p><p>输入：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">请输入一个字符串：hello<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">不重复字符的个数：4<br></code></pre></td></tr></table></figure><hr><h4 id="实例3：快速查找目标和对"><strong>实例3：快速查找目标和对</strong></h4><p>给定一个数组，判断是否存在两个数的和等于目标值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_set&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasPairWithSum</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>    unordered_set&lt;<span class="hljs-type">int</span>&gt; s;  <span class="hljs-comment">// 哈希集合存储访问过的元素</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-type">int</span> complement = target - arr[i];<br>        <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">find</span>(complement) != s.<span class="hljs-built_in">end</span>()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 找到和为目标值的两个数</span><br>        &#125;<br>        s.<span class="hljs-built_in">insert</span>(arr[i]);  <span class="hljs-comment">// 否则插入集合</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> arr[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>&#125;;<br>    <span class="hljs-type">int</span> target = <span class="hljs-number">14</span>;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">hasPairWithSum</span>(arr, <span class="hljs-number">5</span>, target)) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;存在和为 &quot;</span> &lt;&lt; target &lt;&lt; <span class="hljs-string">&quot; 的两个数！&quot;</span> &lt;&lt; endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;不存在和为 &quot;</span> &lt;&lt; target &lt;&lt; <span class="hljs-string">&quot; 的两个数！&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行示例：</strong></p><p>输入数组：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-string">[1, 4, 6, 8, 10]</span>, target = <span class="hljs-number">14</span><br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tap">存在和为<span class="hljs-number"> 14 </span>的两个数！<br></code></pre></td></tr></table></figure><hr><h3 id="总结-3"><strong>总结</strong></h3><ul><li><strong>优点</strong>：<code>unordered_set</code> 适合用于查找和去重，操作效率高（平均 O(1)O(1)）。</li><li><strong>缺点</strong>：由于其无序性，无法直接获得有序结果。如果需要有序集合，可以使用 <code>std::set</code>（基于红黑树实现，操作复杂度为 O(log⁡n)O(\log n)）。</li></ul></blockquote><h2 id="6-11-list的使用">6.11 list的使用</h2><blockquote><p><code>std::list</code> 是 C++ 标准模板库（STL）中的一个容器，它实现了一个双向链表（doubly linked list）。与向量（<code>std::vector</code>）不同，<code>std::list</code> 在以下场景中非常有用：</p><ul><li><strong>高效的插入与删除</strong>：在链表中，你可以在任意位置进行常数时间复杂度（O(1)）的插入和删除操作，而不需要像 <code>std::vector</code> 那样可能涉及大量数据的移动。</li><li><strong>不支持随机访问</strong>：由于底层是链表，<code>std::list</code> 不支持下标访问（例如 <code>list[i]</code>），只能通过迭代器进行顺序遍历。</li></ul><p>下面介绍一些常用的 <code>std::list</code> 操作，并附上示例代码：</p><hr><h3 id="1-创建与初始化">1. 创建与初始化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 创建一个空的 list，元素类型为 int</span><br>    list&lt;<span class="hljs-type">int</span>&gt; myList;<br><br>    <span class="hljs-comment">// 使用初始化列表创建 list</span><br>    list&lt;<span class="hljs-type">int</span>&gt; numbers = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>&#125;;<br><br>    <span class="hljs-comment">// 输出 numbers 中的元素</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : numbers) &#123;<br>        cout &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="2-插入元素">2. 插入元素</h3><ul><li><strong>在末尾插入</strong>：使用 <code>push_back()</code></li><li><strong>在开头插入</strong>：使用 <code>push_front()</code></li><li><strong>在任意位置插入</strong>：使用 <code>insert()</code>，insert(it, val)成员函数用于在链表中插入元素。it为该链表的一个迭代器，val为待插入的值，插入后val位于it所指位置的<strong>前一位</strong>。返回值为一个迭代器，表示val插入到了哪个位置。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    list&lt;<span class="hljs-type">int</span>&gt; myList;<br><br>    <span class="hljs-comment">// 在末尾插入元素</span><br>    myList.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>);<br>    myList.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br><br>    <span class="hljs-comment">// 在开头插入元素</span><br>    myList.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">5</span>);<br><br>    <span class="hljs-comment">// 通过迭代器在第二个位置插入元素 15</span><br>    <span class="hljs-keyword">auto</span> it = myList.<span class="hljs-built_in">begin</span>();<br>    ++it; <span class="hljs-comment">// 指向原来的第一个元素后面的位置</span><br>    myList.<span class="hljs-built_in">insert</span>(it, <span class="hljs-number">15</span>);<br><br>    <span class="hljs-comment">// 输出 list 中的元素</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : myList) &#123;<br>        cout &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="3-删除元素-2">3. 删除元素</h3><ul><li><strong>删除开头元素</strong>：使用 <code>pop_front()</code></li><li><strong>删除末尾元素</strong>：使用 <code>pop_back()</code></li><li><strong>删除指定位置的元素</strong>：使用 <code>erase()</code>，传入对应的迭代器</li><li><strong>remove(it)成员函数用于删除某个迭代器所指的节点</strong>。注意在删除之后it就失效了，除非给it重新赋值，否则对它的任何操作都会导致错误！</li><li><strong>清空所有元素</strong>：使用 <code>clear()</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    list&lt;<span class="hljs-type">int</span>&gt; myList = &#123;<span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">15</span>, <span class="hljs-number">20</span>&#125;;<br><br>    <span class="hljs-comment">// 删除第一个元素</span><br>    myList.<span class="hljs-built_in">pop_front</span>();<br><br>    <span class="hljs-comment">// 删除最后一个元素</span><br>    myList.<span class="hljs-built_in">pop_back</span>();<br><br>    <span class="hljs-comment">// 删除中间的元素（例如，删除当前 list 中的第一个元素）</span><br>    <span class="hljs-keyword">auto</span> it = myList.<span class="hljs-built_in">begin</span>();<br>    myList.<span class="hljs-built_in">erase</span>(it);<br><br>    <span class="hljs-comment">// 此时 list 为空，或者可以再次添加元素</span><br>    myList.<span class="hljs-built_in">clear</span>(); <span class="hljs-comment">// 清空所有元素</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="4-遍历与访问">4. 遍历与访问</h3><p>由于 <code>std::list</code> 不支持随机访问（不能用下标访问），所以必须使用迭代器或范围 for 循环来遍历：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    list&lt;<span class="hljs-type">int</span>&gt; myList = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>&#125;;<br><br>    <span class="hljs-comment">// 使用范围 for 循环遍历</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : myList) &#123;<br>        cout &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br><br>    <span class="hljs-comment">// 使用迭代器遍历</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = myList.<span class="hljs-built_in">begin</span>(); it != myList.<span class="hljs-built_in">end</span>(); ++it) &#123;<br>        cout &lt;&lt; *it &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="5-常用算法成员函数">5. 常用算法成员函数</h3><ul><li><strong>sort()</strong>：对链表排序</li><li><strong>reverse()</strong>：将链表中的元素反转</li><li><strong>unique()</strong>：移除连续重复的元素</li><li><strong>merge()</strong>：合并两个已排序的 <code>std::list</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    list&lt;<span class="hljs-type">int</span>&gt; myList = &#123;<span class="hljs-number">30</span>, <span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">20</span>, <span class="hljs-number">40</span>&#125;;<br><br>    <span class="hljs-comment">// 排序</span><br>    myList.<span class="hljs-built_in">sort</span>();  <span class="hljs-comment">// 排序后：10, 20, 20, 30, 40</span><br><br>    <span class="hljs-comment">// 移除连续重复的元素</span><br>    myList.<span class="hljs-built_in">unique</span>(); <span class="hljs-comment">// 结果：10, 20, 30, 40</span><br><br>    <span class="hljs-comment">// 反转链表</span><br>    myList.<span class="hljs-built_in">reverse</span>(); <span class="hljs-comment">// 结果：40, 30, 20, 10</span><br><br>    <span class="hljs-comment">// 输出结果</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : myList) &#123;<br>        cout &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br><br>    <span class="hljs-comment">// 合并两个已排序的 list</span><br>    list&lt;<span class="hljs-type">int</span>&gt; list1 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>&#125;;<br>    list&lt;<span class="hljs-type">int</span>&gt; list2 = &#123;<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>&#125;;<br><br>    <span class="hljs-comment">// 确保两个 list 都已经排序</span><br>    list<span class="hljs-number">1.</span><span class="hljs-built_in">sort</span>();<br>    list<span class="hljs-number">2.</span><span class="hljs-built_in">sort</span>();<br>    list<span class="hljs-number">1.</span><span class="hljs-built_in">merge</span>(list2);  <span class="hljs-comment">// list1 合并了 list2，且 list2 变为空</span><br><br>    <span class="hljs-comment">// 输出合并后的 list1</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : list1) &#123;<br>        cout &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="6-注意事项">6. 注意事项</h3><ul><li><strong>迭代器失效</strong>：在对 <code>std::list</code> 进行插入或删除操作时，其他迭代器通常不会失效（与 <code>std::vector</code> 不同），但被删除元素对应的迭代器将无效。</li><li><strong>内存使用</strong>：由于链表的每个节点都需要额外的指针存储前后节点的信息，因此在内存使用上可能比连续存储的容器（如 <code>std::vector</code>）稍高。</li><li><strong>不支持随机访问</strong>：如果需要频繁地进行随机访问（例如，直接访问第 n 个元素），建议使用 <code>std::vector</code> 或 <code>std::deque</code>。</li></ul><hr><p>总的来说，<code>std::list</code> 提供了在任意位置快速插入和删除的能力，适用于对数据进行频繁修改的场景，但在需要随机访问和高空间效率</p><p>时，应考虑其他容器。</p></blockquote><h2 id="6-12-multiset的使用">6.12 multiset的使用</h2><h3 id="multiset的定义">multiset的定义</h3><p><code>multiset</code> 是一个集合容器，它可以存储多个相同的元素。换句话说，如果你有一堆重复的数，比如 3、5、5、5、7，你可以用<code>multiset</code>来妥善管理它们。与<code>set</code>不同的是，<code>set</code>不会允许重复的元素，而<code>multiset</code>非常欢迎重复元素的加入。</p><p>可以使用统一初始化的元素来创建</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    multiset&lt;<span class="hljs-type">int</span>&gt; numbers = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">9</span>&#125;;<br><br>    <span class="hljs-comment">// 基于范围的for循环遍历multiset</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : numbers) &#123;<br>        cout &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意，<code>multiset</code>会自动按升序排列元素。</strong></p><p><strong>如果是自定义类型，需要重载小于号</strong></p><h3 id="multiset内元素的访问">multiset内元素的访问</h3><p>使用迭代器</p><h3 id="multiset常用函数实例解析">multiset常用函数实例解析</h3><h4 id="insert-4">insert()</h4><p>略了</p><h4 id="erase-4">erase()</h4><p><code>erase</code>方法用来删除元素。但是要注意！如果你直接传入一个值，所有与这个值相同的元素都会被删除。如果你只想删除一个特定的元素，最好先找到它的迭代器，然后用这个迭代器来删除。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    multiset&lt;<span class="hljs-type">int</span>&gt; numbers = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>&#125;;<br><br>    <span class="hljs-comment">// 删除所有的5</span><br>    numbers.<span class="hljs-built_in">erase</span>(<span class="hljs-number">5</span>);<br><br>    <span class="hljs-comment">// 打印当前的multiset</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : numbers) &#123;<br>        cout &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果只想删除第一个5</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> it = numbers.<span class="hljs-built_in">find</span>(<span class="hljs-number">5</span>);  <span class="hljs-comment">// 找到第一个5</span><br><span class="hljs-keyword">if</span> (it != numbers.<span class="hljs-built_in">end</span>()) &#123;<br>    numbers.<span class="hljs-built_in">erase</span>(it);  <span class="hljs-comment">// 只删除找到的第一个5</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="size-7">size()</h4><p>略了</p><h4 id="clear-5">clear()</h4><p>略了</p><h4 id="empty-4">empty()</h4><p>略</p><h4 id="lower-bound">lower_bound()</h4><p>略 <strong>和algorithm</strong>中的不一样</p><h4 id="upper-bound">upper_bound()</h4><p>略 <strong>和algorithm</strong>中的不一样</p><h1>第7章 提高篇（1）——数据结构专题（1）</h1><h2 id="7-1-栈的应用">7.1 栈的应用</h2><p>栈(stack)是一种后进先出的数据结构。</p><p>可以把栈理解成一个箱子，箱子的长宽仅够一本书放入或拿出。<strong>每次可以把一本书放在箱子的最上方，也可以把箱子最上方的书拿出。</strong></p><p><strong>栈顶指针：始终指向栈的最上方元素的一个标记</strong>，当使用数组实现栈时，栈顶指针是一个int型的变量（数组下标从0开始），通常记作TOP；而当使用链表实现栈时，则是一个int*的指针。<strong>栈中没有元素（即栈空）时令TOP=-1</strong></p><p>下面使用数组st[]来实现栈，int型变量TOP表示栈顶元素的下标，对常用的几个操作进行示范实现</p><p><strong>清空 clear</strong></p><p>栈的清空操作指令TOP=-1表示栈中没有元素</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span>&#123;<br>TOP=<span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>获取栈内元素个数 size</strong></p><p>由于数组下标从0开始，元素个数为TOP+1</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> TOP<span class="hljs-number">+1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>判空 empty</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(TOP==<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>进栈 push</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>st[++TOP]=x; <span class="hljs-comment">//先把TOP+1，再把x存入TOP指向的位置</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>出栈 pop</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>&#123;<br>TOP--;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>取栈顶元素 top</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">return</span> st[TOP];<br>&#125;<br></code></pre></td></tr></table></figure><p>需要特别注意的是pop和top操作必须在栈非空的情况下才能使用，<strong>因此在这之前必须使用empty()函数判断</strong></p><p>事实上使用STL的stack容器更简单。</p><p>需要注意的是STL中清空栈没有自带的函数，可以这样写</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span>(!st.<span class="hljs-built_in">empty</span>())&#123;<br>st.<span class="hljs-built_in">pop</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>但是更常用的做法是重新定义一个栈来变相实现栈的清空。</p><p>下面来看一个题</p><blockquote><p><strong>【codeup 1918】 简单计算器</strong></p><p>读入一个只包含+ - x / 的非负整数计算表达式，计算该表达式的值</p><p>输入格式：</p><p>一个长度不超过<code>100</code>的字符串，其中操作符和操作数仅由+、−、∗、/、整数（不小于<code>1</code>且不大于<code>9</code>）构成，且操作符和操作数之间用空格分隔。数据确保表达式一定合法，且计算过程的所有结果不会超过10^9。</p><p>输出格式：</p><p>输出一行，即该表达式的值，精确到小数点后两位</p><p>样例输入</p><p>3 + 4 * 5</p><p>输出</p><p>23.00</p></blockquote><blockquote><h3 id="1-中缀表达式（Infix-Expression）"><strong>1. 中缀表达式（Infix Expression）</strong></h3><p>中缀表达式是我们日常生活中最常见的数学表达式形式。它的特点是运算符位于两个操作数之间。例如：</p><ul><li><code>3 + 4</code></li><li><code>(5 - 2) * 6</code></li><li><code>2 + 3 * 4</code></li></ul><h4 id="特点"><strong>特点</strong></h4><ul><li>运算符位于操作数之间。</li><li>需要使用括号来明确运算顺序。</li><li>人类易于理解和书写，但计算机处理起来较为复杂。</li></ul><h4 id="示例-3"><strong>示例</strong></h4><ul><li><code>2 + 3 * 4</code> 的中缀表达式需要根据运算符优先级计算：先计算 <code>3 * 4</code>，再计算 <code>2 + 12</code>，结果为 <code>14</code>。</li></ul><hr><h3 id="2-后缀表达式（Postfix-Expression，也称为逆波兰表达式）"><strong>2. 后缀表达式（Postfix Expression，也称为逆波兰表达式）</strong></h3><p>后缀表达式是一种不需要括号的表达式形式，它的特点是运算符位于操作数之后。例如：</p><ul><li><code>3 4 +</code></li><li><code>5 2 - 6 *</code></li><li><code>2 3 4 * +</code></li></ul><h4 id="特点-2"><strong>特点</strong></h4><ul><li>运算符位于操作数之后。</li><li>不需要括号，运算顺序完全由运算符的位置决定。</li><li>计算机处理起来非常方便，适合用栈（Stack）来求值。</li></ul><h4 id="示例-4"><strong>示例</strong></h4><ul><li><code>2 3 4 * +</code> 的后缀表达式计算过程：<ol><li>遇到 <code>3 4 *</code>，计算 <code>3 * 4 = 12</code>。</li><li>表达式变为 <code>2 12 +</code>。</li><li>计算 <code>2 + 12 = 14</code>，结果为 <code>14</code>。</li></ol></li></ul><hr><h3 id="3-中缀表达式转后缀表达式"><strong>3. 中缀表达式转后缀表达式</strong></h3><p>将中缀表达式转换为后缀表达式是计算机科学中的一个常见任务，通常使用栈（Stack）来实现。以下是转换的步骤：</p><h4 id="转换规则"><strong>转换规则</strong></h4><ol><li>初始化一个空栈和一个空输出列表。</li><li>从左到右扫描中缀表达式。</li><li>如果遇到操作数，直接添加到输出列表。</li><li>如果遇到左括号 <code>(</code>，将其压入栈。</li><li>如果遇到右括号 <code>)</code>，将栈中的运算符弹出并添加到输出列表，直到遇到左括号 <code>(</code>。左括号弹出但不添加到输出列表。</li><li>如果遇到运算符：<ul><li>弹出栈中优先级高于或等于当前运算符的所有运算符，并添加到输出列表。</li><li>将当前运算符压入栈。</li></ul></li><li>扫描结束后，将栈中剩余的运算符依次弹出并添加到输出列表。</li></ol><h4 id="示例-5"><strong>示例</strong></h4><p>将中缀表达式 <code>2 + 3 * 4</code> 转换为后缀表达式：</p><ol><li>输出列表：<code>2</code></li><li>栈：<code>+</code></li><li>输出列表：<code>2 3</code></li><li>栈：<code>+ *</code></li><li>输出列表：<code>2 3 4</code></li><li>栈：<code>+ *</code>（扫描结束，弹出栈中所有运算符）</li><li>输出列表：<code>2 3 4 * +</code></li></ol></blockquote><h2 id="7-2-队列的应用">7.2 队列的应用</h2><p>队列（queue）是一种先进先出的数据结构，与栈有所不同。</p><p>举一个例子来理解：食堂打饭排队，最先进去的先打到饭出队，也就是<strong>先进先出</strong></p><p>一般来说需要一个<strong>队首指针front来指向队首元素的前一个位置</strong>，而使用一个<strong>队尾指针rear来指向队尾元素</strong>。</p><p>与栈类似，当使用数组来实现queue时，队首指针front和队尾指针rear为int型变量（下标从0开始）；而当使用链表来实现时则为int*型变量的指针</p><p>下面使用数组q[]来实现队列，而int型变量front存放队首元素的前一个下标，rear存放队尾元素的下标（下标从0开始），下面演示常见操作：</p><p><strong>清空 clear</strong></p><p>初始状态为front=-1、rear=-1</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span>&#123;<br>    front=rear=<span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>获取队列内元素的个数 size</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">in <span class="hljs-title">size</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> rear-front;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>判空 empty</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(front==rear) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>入队 push</strong></p><p>由于rear指向队尾元素，因此元素入队时需先把rear+1，再存放到rear指向的位置</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">()</span></span>&#123;<br>    q[++rear]=x;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>出队 pop</strong></p><p>可以把队首指针+1来实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>&#123;<br>front++;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>取队首元素 get_front</strong></p><p>由于front指向的是队首元素的前一个元素，因此front+1才是队首元素的位置</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_front</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> q[front<span class="hljs-number">+1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>取队尾元素 get_rear</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_rear</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">return</span> q[rear];<br>&#125;<br></code></pre></td></tr></table></figure><p>与栈类似，这些操作必须在队列非空的情况下时候，要先判断</p><p>另外，多用STL比较好</p><h2 id="7-3-链表处理">7.3 链表处理</h2><h3 id="7-3-1-链表的概念">7.3.1 链表的概念</h3><p>线性表：常用的一种数据结构</p><ul><li>顺序表：可以简单地理解成“数组”</li><li>链表</li></ul><p>按正常方式定义一个数组的时候，计算机会从内存中取出一块连续的地址来存放给定长度的数组；而链表则是由若干个结点组成（每个结点代表一个元素），且结点在内存中的存储位置通常是<strong>不连续的</strong>。除此之外，链表的两个结点之间一般通过一个指针来从一个结点指向另一个结点，因此链表的结点一般由两部分构成，即数据域和指针域：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>    <span class="hljs-keyword">typename</span> data; <span class="hljs-comment">//数据域</span><br>    node* next; <span class="hljs-comment">//指针域</span><br>&#125;<br></code></pre></td></tr></table></figure><p>一般来说，数据域存放要储存的数据，而指针域指向下一个结点的地址，这样就会产生从某个节点开始的由指针链接的一条链式结构，即链表。</p><p>可以分为两类</p><ul><li>带头结点的链表</li><li>不带头结点的链表</li></ul><p>头结点一般称为head，其数据域data不存放任何内容，而指针域next指向第一个数据域有内容的结点（<strong>一般直接把这个结点叫做第一个结点</strong>），我们在这里统一采用带头结点的写法。最后一个结点的next指针指向NULL，表示一条链表的结尾</p><h3 id="7-3-2-使用malloc函数或new运算符为链表节点分配内存空间">7.3.2 使用malloc函数或new运算符为链表节点分配内存空间</h3><h4 id="malloc函数">malloc函数</h4><p>C语言中stdlib.h头文件下用于动态内存申请的函数，返回类型是申请的同变量类型的指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typename</span>* p=(<span class="hljs-keyword">typename</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">typename</span>));<br></code></pre></td></tr></table></figure><p>以申请一个int型变量和一个node型结构体变量为例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> *p=(<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<br>node* p=(node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(node));<br></code></pre></td></tr></table></figure><p>这个写法的逻辑是：以需要申请的内存空间大小（即sizeof(node)）为malloc函数的参数，这时malloc函数就会向内存申请一块大小为sizeof(node)的空间，并且返回指向这块空间的指针。但这时这个指针类型未确定(void*)，因此需要将它强转为node*型，这样等号右边就得到了一个node*型的指针，并通过赋值等号把这个指针赋给了node*型的指针变量p，就成功申请了一块node类型大小的内存空间，即一个node型的结构体变量，并通过指针p来访问它。</p><h4 id="new运算符">new运算符</h4><p>new是C++中用来申请动态空间的<strong>运算符</strong>，其返回类型同malloc函数的返回类型，基本用法如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">tyoename* p=<span class="hljs-keyword">new</span> <span class="hljs-keyword">typename</span>;<br></code></pre></td></tr></table></figure><p>同样以申请一个int型变量和一个node型变量为例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> *p=<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;<br>node* p=<span class="hljs-keyword">new</span> node;<br></code></pre></td></tr></table></figure><h4 id="内存泄漏">内存泄漏</h4><p>指malloc与new开劈出来的内存空间在使用之后没有释放，导致其在程序结束之前始终占据该内存空间，所以在使用完malloc和new开辟出来的空间之后必须将其释放。</p><h5 id="free函数">free函数</h5><p>free函数是对应malloc函数的，同样在stdlib.h下面</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//在free的参数中填写需要释放的内存空间的指针变量即可</span><br><span class="hljs-built_in">free</span>(p);<br></code></pre></td></tr></table></figure><p>free函数的效果：</p><ol><li>释放指针变量p所指向的内存空间</li><li>将指针变量p指向空地址NULL</li></ol><p>需要注意的是malloc和free必须成对出现否则容易爆</p><h5 id="delete运算符">delete运算符</h5><p>对应new运算符，使用方法和实现效果与free相同</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">delete</span>(p);<br></code></pre></td></tr></table></figure><p>delete和new运算符必须成对出现</p><h3 id="7-3-3-链表的基本操作">7.3.3 链表的基本操作</h3><h4 id="创建列表">创建列表</h4><p>现在可以通过malloc和new来获得若干个零散的结点，只需要把他们串起来，只需要让每个结点的next指针指向下一个结点的地址即可</p><blockquote><h3 id="1-操作符的作用"><strong>1. <code>-&gt;</code> 操作符的作用</strong></h3><p><code>-&gt;</code> 操作符用于通过指针访问对象的成员。它的作用相当于：</p><ol><li>解引用指针（<code>*ptr</code>）。</li><li>访问对象的成员（<code>(*ptr).member</code>）。</li></ol><p>换句话说，<code>ptr-&gt;member</code> 等价于 <code>(*ptr).member</code>。</p><hr><h3 id="2-使用场景"><strong>2. 使用场景</strong></h3><p><code>-&gt;</code> 操作符通常用于以下场景：</p><ol><li><strong>访问动态分配对象的成员</strong>：<ul><li>当对象是通过 <code>new</code> 动态分配时，返回的是指针，此时需要使用 <code>-&gt;</code> 访问成员。</li></ul></li><li><strong>访问结构体或类的指针成员</strong>：<ul><li>当结构体或类的实例是通过指针引用时，使用 <code>-&gt;</code> 访问成员。</li></ul></li><li><strong>访问智能指针的成员</strong>：<ul><li>对于智能指针（如 <code>std::unique_ptr</code> 或 <code>std::shared_ptr</code>），使用 <code>-&gt;</code> 访问成员。</li></ul></li></ol></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>    <span class="hljs-type">int</span> data;<br>    node* next;<br>&#125;;<br><br><span class="hljs-function">node *<span class="hljs-title">create</span><span class="hljs-params">(<span class="hljs-type">int</span> a[],<span class="hljs-type">int</span> len)</span></span>&#123;<br>    node *p,*pre,*head; <span class="hljs-comment">//当前结点 前驱结点 头结点</span><br>    head=<span class="hljs-keyword">new</span> node; <span class="hljs-comment">//创建头结点</span><br>    head-&gt;next=<span class="hljs-literal">NULL</span>; <span class="hljs-comment">//初始化，让头结点指向NULL</span><br>    <span class="hljs-comment">//pre=new node; //创建前驱结点</span><br>    <span class="hljs-comment">//上面一行不需要，因为前驱结点（pre）一开始就应该指向头结点，并不需要为 pre 创建一个新的结点，因为 pre 只需要作为指向头结点的指针</span><br>    pre=head; <span class="hljs-comment">//最开始前驱结点就是头结点</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;++i)&#123;<br>        p=<span class="hljs-keyword">new</span> node; <span class="hljs-comment">//创建结点 即前驱结点的后继结点</span><br>        p-&gt;data=a[i]; <span class="hljs-comment">//读入结点数据域 也可以scanf</span><br>        p-&gt;next=<span class="hljs-literal">NULL</span>; <span class="hljs-comment">//先初始化</span><br>        pre-&gt;next=p; <span class="hljs-comment">//前驱结点的指针域（指向前驱结点的后继结点）设为当前新建结点的地址，把前后两个结点连接起来</span><br>        <span class="hljs-comment">//必须要理解这里的pre和p都是指针，本质是地址</span><br>        <span class="hljs-comment">//所以比如i=0的情况下，原本是head-&gt;NULL的，现在是head-&gt;1了，因为修改了pre就等同于修改了head，因为pre和head的地址相同</span><br>        pre=p; <span class="hljs-comment">//把pre作为p，作为下一个结点的前驱结点</span><br>        <span class="hljs-comment">//其实是把pre的地址换个地方，现在pre的地址是上面那一通操作生成的p的地址</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> head; <span class="hljs-comment">//返回头结点指针</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">5</span>]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>    node* L=<span class="hljs-built_in">create</span>(a,<span class="hljs-number">5</span>);<br>    L=L-&gt;next; <span class="hljs-comment">//从第一个结点开始有数据域</span><br>    <span class="hljs-keyword">while</span>(L!=<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,L-&gt;data);<br>        L=L-&gt;next;<br>    &#125; <span class="hljs-comment">//输出1 2 3 4 5</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><h3 id="第-17-行和第-18-行：指针的传递"><strong>第 17 行和第 18 行</strong>：指针的传递</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">pre-&gt;next = p;  <span class="hljs-comment">// 将前驱节点的指针域（next）指向新节点p</span><br>pre = p;         <span class="hljs-comment">// 将pre指向当前节点p，作为下一个节点的前驱</span><br></code></pre></td></tr></table></figure><p>这两行代码的目的是 <strong>更新链表中各个节点的链接关系</strong>。让我们逐一解释：</p><ul><li><p><code>pre-&gt;next = p;</code></p><p>：</p><ul><li>这行代码是将前一个节点（即 <code>pre</code> 指向的节点）的 <code>next</code> 指针指向新创建的节点 <code>p</code>。</li><li>例如，假设链表目前有节点 <code>A</code> 和节点 <code>B</code>，此时 <code>pre</code> 指向节点 <code>A</code>，<code>p</code> 指向新创建的节点 <code>B</code>。你要做的是将 <code>A-&gt;next</code> 指向 <code>B</code>，也就是说，链表从 <code>A</code> 到 <code>B</code> 连接起来。</li></ul></li><li><p><code>pre = p;</code></p><p>：</p><ul><li>这行代码的作用是更新前驱节点 <code>pre</code> 的指向。</li><li>将 <code>pre</code> 更新为当前的节点 <code>p</code>，也就是将 <code>pre</code> 指向 <code>B</code>。</li><li>下一次循环时，<code>pre</code> 就是 <code>B</code>，此时它会作为前一个节点参与到 <code>next</code> 指针的更新。</li></ul></li></ul><p>换句话说， <strong><code>pre-&gt;next = p;</code></strong> 负责建立新节点的链接关系，而 <strong><code>pre = p;</code></strong> 则是更新 <code>pre</code> 为当前节点 <code>p</code>，为下一轮创建新的节点做准备。</p></blockquote><h4 id="查找元素">查找元素</h4><p>从第一个结点开始，不断判断当前结点的数据域是否等于x，如果等于就cnt++，这样结尾的时候cnt的值就是列表中元素x的个数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(node *head,<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br>    node *p=head-&gt;next; <span class="hljs-comment">//从第一个节点开始</span><br>    <span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">if</span>(p-&gt;data==x) cnt++;<br>        p=p-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="插入元素">插入元素</h4><p><strong>“在第3个位置插入元素4”的意思是在插入完成之后第3个位置的元素是4</strong>，意思是把原先第三个位置的元素让开（在第2和3之间插入）</p><p>假设原本是6 7 8 9 10</p><p>在第三个位置插入4之后，就是7指向4，而4指向8，依此思路进行代码实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//将x插入以head为头结点的链表的第pos个位置上</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(node *head,<span class="hljs-type">int</span> pos,<span class="hljs-type">int</span> x)</span></span>&#123;<br>    node* p=head;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;pos<span class="hljs-number">-1</span>;i++)&#123;<br>        p=p-&gt;next; <span class="hljs-comment">//pos-1是为了插入位置的前一个结点，这里相当于移动p的指针</span><br>    &#125;<br>    node *q=<span class="hljs-keyword">new</span> node;<br>    q-&gt;data=x; <span class="hljs-comment">//这个时候q还是野指针</span><br>    q-&gt;next=p-&gt;next;<br>    p-&gt;next=q;<br>&#125;<br></code></pre></td></tr></table></figure><p>这份代码可以直接写在“创建链表”部分的代码中进行使用，把create函数返回的头指针L直接作为第一个参数传入即可</p><p>顺序<strong>必须是</strong>先把新节点的指针域next指向后继结点，之后才能把前一个元素所在节点的指针指向新节点的地址</p><h4 id="删除元素">删除元素</h4><p>对链表来说，删除元素是指删除链表上所有值为给定的数x，操作是这样进行的：</p><ol><li>由指针变量p枚举结点，指针变量pre作为p指向的结点的前驱结点</li><li>当p指向的结点的数据域恰好为x时，进行下面三个操作<ol><li>令pre指向的结点的指针域指向指针变量p指向的结点的后继结点</li><li>释放p所指向结点的内存空间</li><li>令p指向pre指向的结点的后继结点</li></ol></li></ol><p>代码实现如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//删除以head为头结点的链表中所有数据域为x的结点</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">del</span><span class="hljs-params">(node* head,<span class="hljs-type">int</span> x)</span></span>&#123;<br>    node *p=head-&gt;next; <span class="hljs-comment">//p从第一个结点开始枚举</span><br>    node *pre=head; <span class="hljs-comment">//pre始终保存p的前驱结点的指针</span><br>    <span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">if</span>(p-&gt;data==x)&#123; <span class="hljs-comment">//数据域恰好为x，说明要删除该结点</span><br>            pre-&gt;next=p-&gt;next;<br>            <span class="hljs-built_in">delete</span>(p);<br>            p=pre-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">//数据域不是x，把pre和p都往后移一位</span><br>            pre=p;<br>            p=p-&gt;next;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这份代码可以直接写在“创建链表”部分的代码中进行使用，把create函数返回的头指针L直接作为第一个参数传入即可</p><p>最后总结一下这几个板子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>    <span class="hljs-type">int</span> data;<br>    node* next;<br>&#125;;<br><br><span class="hljs-function">node *<span class="hljs-title">create</span><span class="hljs-params">(<span class="hljs-type">int</span> a[],<span class="hljs-type">int</span> len)</span></span>&#123;<br>    node *p,*pre,*head;<br>    head=<span class="hljs-keyword">new</span> node;<br>    head-&gt;next=<span class="hljs-literal">NULL</span>;<br>    pre=head;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>        p=<span class="hljs-keyword">new</span> node;<br>        p-&gt;next=<span class="hljs-literal">NULL</span>;<br>        p-&gt;data-a[i];<br>        pre-&gt;next=p;<br>        pre=p;<br>    &#125;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(node *head,<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br>    node *p=head-&gt;next; <span class="hljs-comment">//从第一个节点开始</span><br>    <span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">if</span>(p-&gt;data==x) cnt++;<br>        p=p-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br><br><span class="hljs-comment">//将x插入以head为头结点的链表的第pos个位置上</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(node *head,<span class="hljs-type">int</span> pos,<span class="hljs-type">int</span> x)</span></span>&#123;<br>    node* p=head;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;pos<span class="hljs-number">-1</span>;i++)&#123;<br>        p=p-&gt;next; <span class="hljs-comment">//pos-1是为了插入位置的前一个结点，这里相当于移动p的指针</span><br>    &#125;<br>    node *q=<span class="hljs-keyword">new</span> node;<br>    q-&gt;data=x; <span class="hljs-comment">//这个时候q还是野指针</span><br>    q-&gt;next=p-&gt;next;<br>    p-&gt;next=q;<br>&#125;<br><br><span class="hljs-comment">//删除以head为头结点的链表中所有数据域为x的结点</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">del</span><span class="hljs-params">(node* head,<span class="hljs-type">int</span> x)</span></span>&#123;<br>    node *p=head-&gt;next; <span class="hljs-comment">//p从第一个结点开始枚举</span><br>    node *pre=head; <span class="hljs-comment">//pre始终保存p的前驱结点的指针</span><br>    <span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">if</span>(p-&gt;data==x)&#123; <span class="hljs-comment">//数据域恰好为x，说明要删除该结点</span><br>            pre-&gt;next=p-&gt;next;<br>            <span class="hljs-built_in">delete</span>(p);<br>            p=pre-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">//数据域不是x，把pre和p都往后移一位</span><br>            pre=p;<br>            p=p-&gt;next;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-3-4-静态链表">7.3.4 静态链表</h3><p>对于有些问题来说，结点的地址是比较小的整数，这样无必要建立动态链表，应使用简单的静态链表</p><p>实现原理是hash，通过建立一个结构体数组，并令数组的下标直接表示该结点的地址，来达到直接访问数组中的元素就能访问结点的效果，因为访问非常方便所以<strong>不需要头结点</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&#123;<br>    <span class="hljs-keyword">typename</span> data; <span class="hljs-comment">//数据域</span><br>    <span class="hljs-type">int</span> next; <span class="hljs-comment">//指针域</span><br>&#125;node[size]; <span class="hljs-comment">//注意数组名和结构体名不要相同</span><br></code></pre></td></tr></table></figure><p>next=-1表示没有后继结点</p><blockquote><p><strong>【PAT A1032】 Sharing</strong></p><p>给出两条链表的首地址以及若干结点的地址、数据、下一个结点的地址，求两条链表的首个共用结点的地址。如果两条链表没有共用结点则输出-1</p><p>注意：使用map容易超时</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">100010</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&#123;<br>    <span class="hljs-type">char</span> data;<br>    <span class="hljs-type">int</span> next;<br>    <span class="hljs-type">bool</span> flag; <span class="hljs-comment">//数据是否在第一条链表里面出现</span><br>    <span class="hljs-built_in">Node</span>()&#123;<br>        flag=<span class="hljs-literal">false</span>;<br>        next=<span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;node[maxn];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> s1,s2,n; <span class="hljs-comment">//s1 s2分别表示两条链表的首地址</span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;s1,&amp;s2,&amp;n);<br>    <span class="hljs-type">char</span> data;<br>    <span class="hljs-type">int</span> address,next;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %c %d&quot;</span>,&amp;address,&amp;data,&amp;next);<br>        node[address].data=data;<br>        node[address].next=next;<br>    &#125;<br>    <span class="hljs-type">int</span> p;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> p=s1;p!=<span class="hljs-number">-1</span>;p=node[p].next)&#123;<br>        node[p].flag=<span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> p=s2;p!=<span class="hljs-number">-1</span>;p=node[p].next)&#123;<br>        <span class="hljs-keyword">if</span>(node[p].flag) <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(p!=<span class="hljs-number">-1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%05d&quot;</span>,p);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-1&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这是一道静态列表所能解决的比较简单的题，而对于稍微复杂一点的题此处归纳一种通法</p><ol><li><p>定义静态链表</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&#123;<br>    <span class="hljs-keyword">typename</span> data; <span class="hljs-comment">//数据域</span><br>    <span class="hljs-type">int</span> next; <span class="hljs-comment">//指针域</span><br>    XXX; <span class="hljs-comment">//结点的某个性质，不同的题目会有不同的设置</span><br>&#125;node[<span class="hljs-number">100010</span>];<br></code></pre></td></tr></table></figure><p>例如可以设置结点是否为链表上的一个结点</p></li><li><p>在程序的开始对静态链表进行初始化，一般来说需要对定义里的XXX进行初始化，定义为正常情况下达不到的数字（一般来说需要小于所有能达到的数字）</p></li><li><p>题目一般都会给出一条链表的首结点的地址，那么我们就可以根据这个地址来遍历得到整条链表，同时需要注意这一步同时也是对性质XXX进行<strong>标记</strong>、并且对有效节点的个数进行计数的时候</p></li><li><p>由于使用静态链表的时候是采用hash的方式，这就会使得数组下标的不连续，而很多时候题目给出的结点并不都是有效结点（即可能存在不在链表上的结点）。为了能够可控地访问有效结点，一般需要对数组进行排序，把有效结点移到数组左端，这样就可以用步骤3得到的cnt来访问它们。</p><p>既然需要把有效结点移到前面，那么就可以使用之前定义的XXX来帮忙。在步骤2中XXX需要被初始化为比正常结点的XXX取值要小的数值，而由于无效结点的XXX在步骤3中并不会被修改，因此一定比有效结点的XXX小。于是可以使用特定的cmp函数来将cmp的两个参数结点中有无效结点时按XXX降序，这样就可以把有效结点全部移到数组左端</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(Node a,Node b)</span></span>&#123;<br><span class="hljs-keyword">if</span>(a.XXX==<span class="hljs-number">-1</span>||b.XXX==<span class="hljs-number">-1</span>)&#123; <span class="hljs-comment">//至少一个结点是无效结点 把它放在数组后面</span><br>        <span class="hljs-keyword">return</span> a.XXX&gt;b.XXX;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-comment">//第二级排序</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在步骤4之后有效结点均位于数组左端，且已经按结点的顺序进行了排序，接下来依题目而定</p></li></ol><blockquote><p><strong>【PAT A1052】 Linked List Sorting</strong></p><p>给出N个结点的地址address、数据域data以及指针域next，然后给出链表的首地址，要求把这个链表上的结点按data值从大到小输出。（输入格式与输出格式相同）</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//给出N个结点的地址address、数据域data以及指针域next，然后给出链表的首地址，要求把这个链表上的结点按data值从大到小输出。（输入格式与输出格式相同）</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">100010</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&#123;<br>    <span class="hljs-type">int</span> address;<br>    <span class="hljs-type">int</span> data;<br>    <span class="hljs-type">int</span> next=<span class="hljs-number">-1</span>;<br>    <span class="hljs-type">bool</span> flag=<span class="hljs-literal">false</span>;<br>&#125;node[maxn];<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(Node a,Node b)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(!a.flag||!b.flag) <span class="hljs-keyword">return</span> a.flag&gt;b.flag;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> a.data&lt;b.data;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> headAddress,n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;headAddress);<br>    <span class="hljs-type">int</span> address,data,next;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;address,&amp;data,&amp;next);<br>        node[address].address=address;<br>        node[address].data=data;<br>        node[address].next=next;<br>    &#125;<br>    <span class="hljs-type">int</span> p,cnt=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> p=headAddress;p!=<span class="hljs-number">-1</span>;p=node[p].next)&#123;<br>        node[p].flag=<span class="hljs-literal">true</span>;<br>        cnt++;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!cnt) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0 -1&quot;</span>);<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">sort</span>(node,node+maxn,cmp);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %05d\n&quot;</span>,cnt,node[<span class="hljs-number">0</span>].address);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;cnt;i++)&#123;<br>            <span class="hljs-keyword">if</span>(i!=cnt<span class="hljs-number">-1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%05d %d %05d\n&quot;</span>,node[i].address,node[i].data,node[i<span class="hljs-number">+1</span>].address);<br>            <span class="hljs-comment">//这里一定要注意第三项不要写成node[i].next，因为sort完了，我们要打印的顺序并不是按照链表链接的顺序</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%05d %d -1&quot;</span>,node[i].address,node[i].data);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1>第8章 提高篇（2）——搜索专题</h1><h2 id="8-1-深度优先搜索（DFS）">8.1 深度优先搜索（DFS）</h2><p>以枚举所有完整路径以遍历所有情况的搜索方法</p><p>dfs可以用栈来实现，但是递归更简单</p><p>把递归式理解成岔道口，递归边界理解成死胡同</p><blockquote><p>有n件物品，每件物品的重量为w[i]，价值为c[i]。现在需要选出若干件物品放入一个容量为V的背包中，使得在选入背包的物品重量和不超过容量V的前提下，让背包中物品的价值最大，求最大价值（1&lt;=n&lt;=20）</p></blockquote><p>分析：</p><p>死胡同：物品重量总和超过V</p><p>岔道口：每次选择的不同的物品</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">25</span>;<br><br><span class="hljs-type">int</span> n,v,maxValue,w[maxn],c[maxn];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> idx,<span class="hljs-type">int</span> sumW,<span class="hljs-type">int</span> sumC)</span></span>&#123;<br>    <span class="hljs-comment">//死胡同</span><br>    <span class="hljs-keyword">if</span>(idx==n)&#123; <span class="hljs-comment">//已经完成对n件物品的选择</span><br>        <span class="hljs-keyword">if</span>(sumW&lt;=v&amp;&amp;sumC&gt;maxValue)&#123;<br>            maxValue=sumC;<br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//岔路口</span><br>    <span class="hljs-built_in">dfs</span>(idx<span class="hljs-number">+1</span>,sumW,sumC); <span class="hljs-comment">//不选第idx件物品</span><br>    <span class="hljs-comment">//如果不选第idx件物品无法做到最大的话</span><br>    <span class="hljs-built_in">dfs</span>(idx<span class="hljs-number">+1</span>,sumW+w[idx],sumC+c[idx]); <span class="hljs-comment">//选第idx件物品（0起计）</span><br>    <span class="hljs-comment">//因为数组下标0起计，w[idx]其实就是已经选了idx+1件</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;v;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        cin&gt;&gt;w[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        cin&gt;&gt;c[i];<br>    &#125;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>); <span class="hljs-comment">//初始时第0件物品，总重量和总价值均为0</span><br>    cout&lt;&lt;maxValue;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于每件物品有两种选择，时间复杂度O($2^n$)，但是可以稍加优化来让效率更高。</p><p>上述代码中总是把n件物品的选择全部确定之后才更新最大价值，但是事实上忽略了背包容量不超过v这个特点。也就是说完全可以把sumW的判断加入“岔道口”，只有当sumW&lt;=V的时候才进入岔道，修改如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> idx,<span class="hljs-type">int</span> sumW,<span class="hljs-type">int</span> sumC)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(idx==n) <span class="hljs-keyword">return</span>; <span class="hljs-comment">//已经完成了对n件物品的选择</span><br>    <span class="hljs-comment">//岔道口</span><br>    <span class="hljs-built_in">dfs</span>(idx<span class="hljs-number">+1</span>,sumW,sumC); <span class="hljs-comment">//不选第idx件物品</span><br>    <span class="hljs-comment">//只有加入第idx件物品后未超过容量v才能继续</span><br>    <span class="hljs-keyword">if</span>(sumW+w[idx]&lt;=v)&#123;<br>        <span class="hljs-keyword">if</span>(sumC+c[idx]&gt;maxValue) maxValue=sumC+c[idx];<br>    &#125;<br>    <span class="hljs-built_in">dfs</span>(idx<span class="hljs-number">+1</span>,sumW+w[idx],sumC+c[idx]); <span class="hljs-comment">//选第idx件物品</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这样优化了时间复杂度。</p><p>这种通过题目条件限制来节省DFS计算量的方法叫做<strong>剪枝</strong></p><p>事实上下面给出了一类DFS问题的解决方法：<strong>给定一个序列，枚举这个序列中的所有子序列（可以不连续）</strong></p><blockquote><p>给定n个整数（可能有负数），从中选择恰好k个数，使这k个数的和恰好等于一个给定的数x；如果有多种方案，选择平方和最大的那一个</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> idx,<span class="hljs-type">int</span> nowK,<span class="hljs-type">int</span> sum,<span class="hljs-type">int</span> sumSqu)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(nowK==k&amp;&amp;sum==x)&#123;<br>        <span class="hljs-keyword">if</span>(sumSqu&gt;maxSumSqu)&#123;<br>            maxSumSqu=sumSqu;<br>            ans=temp;<br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//已经处理完n个数，或者超过k个数，或者和超过x，返回</span><br>    <span class="hljs-keyword">if</span>(idx==n||nowK&gt;k||sum&gt;x) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">//选idx号数</span><br>    temp.<span class="hljs-built_in">push_back</span>(a[idx]);<br>    <span class="hljs-built_in">dfs</span>(idx<span class="hljs-number">+1</span>,nowK<span class="hljs-number">+1</span>,sum+a[idx],sumSqu+a[idx]*a[idx]);<br>    temp.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-comment">//不选</span><br>    <span class="hljs-built_in">dfs</span>(idx<span class="hljs-number">+1</span>,nowK,sum,sumSqu);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="dfs的一些剪枝技巧">dfs的一些剪枝技巧</h3><p>先给出一段深搜模板</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> ans = 最坏情况, now;  <span class="hljs-comment">// now 为当前答案</span><br>这个模板要求在调用dfs之前先将起点标记，防止回溯出现环路。<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(传入数值)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (到达目的地) ans = 从当前解与已有解中选最优;<br>  <span class="hljs-keyword">for</span> (遍历所有可能性)<br>    <span class="hljs-keyword">if</span> (可行) &#123;<br>      进行操作;<br>      <span class="hljs-built_in">dfs</span>(缩小规模);<br>      撤回操作;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中的 ans 可以是解的记录，那么从当前解与已有解中选最优就变成了输出解。</p><h4 id="记忆化搜索">记忆化搜索</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> g[MAXN];  <span class="hljs-comment">// 定义记忆化数组</span><br><span class="hljs-type">int</span> ans = 最坏情况, now;<br><br><span class="hljs-function"><span class="hljs-type">void</span> dfs <span class="hljs-title">f</span><span class="hljs-params">(传入数值)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (g[规模] != 无效数值) <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// 或记录解，视情况而定</span><br>  <span class="hljs-keyword">if</span> (到达目的地) ans = 从当前解与已有解中选最优;  <span class="hljs-comment">// 输出解，视情况而定</span><br>  <span class="hljs-keyword">for</span> (遍历所有可能性)<br>    <span class="hljs-keyword">if</span> (可行) &#123;<br>      进行操作;<br>      <span class="hljs-built_in">dfs</span>(缩小规模);<br>      撤回操作;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-built_in">memset</span>(g, 无效数值, <span class="hljs-built_in">sizeof</span>(g));  <span class="hljs-comment">// 初始化记忆化数组</span><br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="最优性剪枝">最优性剪枝</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> ans = 最坏情况, now;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(传入数值)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (now比ans的答案还要差) <span class="hljs-keyword">return</span>;<br>  <span class="hljs-keyword">if</span> (到达目的地) ans = 从当前解与已有解中选最优;<br>  <span class="hljs-keyword">for</span> (遍历所有可能性)<br>    <span class="hljs-keyword">if</span> (可行) &#123;<br>      进行操作;<br>      <span class="hljs-built_in">dfs</span>(缩小规模);<br>      撤回操作;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="可行性剪枝">可行性剪枝</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> ans = 最坏情况, now;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(传入数值)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (当前解已不可用) <span class="hljs-keyword">return</span>;<br>  <span class="hljs-keyword">if</span> (到达目的地) ans = 从当前解与已有解中选最优;<br>  <span class="hljs-keyword">for</span> (遍历所有可能性)<br>    <span class="hljs-keyword">if</span> (可行) &#123;<br>      进行操作;<br>      <span class="hljs-built_in">dfs</span>(缩小规模);<br>      撤回操作;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8-2-广度优先搜索（BFS）">8.2 广度优先搜索（BFS）</h2><p>以<strong>广度</strong>为第一关键词。当碰到岔道口时，总是先依次访问从该岔道口能直接到达的所有结点，然后再按这些结点被访问的顺序去依次访问它们能直接到达的所有结点。</p><p>算法依靠<strong>队列</strong>来实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BFS</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span></span>&#123; <span class="hljs-comment">//s为起点</span><br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    q.<span class="hljs-built_in">push</span>(s);<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>        取出队首元素top;<br>        访问队首元素top; <span class="hljs-comment">//访问可以是任何事情,例如输出</span><br>        将队首元素出队; <br>        将top的下一层结点中未曾入队的结点全部入队,并设置为已入队;<br>        <span class="hljs-comment">//并标记它们的层号为now++，同时设置这些结点已入队</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>例题</p><blockquote><p>给出一个m*n的矩阵，矩阵中的元素为0或1。称位置(x,y)与其上下左右四个位置是相邻的。如果矩阵中有若干（1个也算若干个）个1是相邻的（不必两两相邻），那么称这些1构成了一个“块”，求给定的矩阵中块的个数。</p></blockquote><p>使用bfs的思想：枚举每一个位置的元素，如果是0就跳过，如果是1就使用bfs查询与该位置相邻的4个元素（前提是不出界），判断是否为1，如果是1那么继续查询，直到整个1块访问完毕。而为了避免走回头路可以定义一个bool数组inq(即in queue的缩写)来记录每个位置是否在bfs中已经入过队。</p><blockquote><p>[!TIP]</p><p>对于当前位置(x,y)而言，可以设置两个增量数组来访问相邻的4个位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> X[]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>&#125;;<br><span class="hljs-type">int</span> Y[]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<br></code></pre></td></tr></table></figure><p>分别对应(x,y+1) (x,y-1) (x+1,y) (x-1,y)</p><p>这样就可以用for循环去枚举4个方向，以确定当前坐标(nowX,nowY)相邻的4个位置</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;<br>    newX=nowX+X[i];<br>    newY=nowY+Y[i];<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><p>本题的bfs代码实现如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">105</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>    <span class="hljs-type">int</span> x,y; <span class="hljs-comment">//存放位置</span><br>&#125;Node;<br><span class="hljs-type">int</span> n,m; <span class="hljs-comment">//矩阵大小</span><br><span class="hljs-type">int</span> matrix[maxn][maxn]; <span class="hljs-comment">//01矩阵</span><br><span class="hljs-type">bool</span> inq[maxn][maxn]=&#123;<span class="hljs-literal">false</span>&#125;; <span class="hljs-comment">//记录是否入过队</span><br><span class="hljs-type">int</span> X[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>&#125;,Y[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;; <span class="hljs-comment">//坐标增量数组</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(x&gt;m||x&lt;<span class="hljs-number">1</span>||y&gt;n||y&lt;<span class="hljs-number">1</span>||inq[x][y]||matrix[x][y]==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">//只要出界||入过队||在该点不为1,就不访问</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-comment">//访问位置(x,y)所在的块，设置一个块内的1的inq为true</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>    queue&lt;node&gt; q;<br>    Node.x=x;Node.y=y;<br>    q.<span class="hljs-built_in">push</span>(Node);<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>        node top=q.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">//取队首元素top</span><br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123; <span class="hljs-comment">//得到相邻位置</span><br>            <span class="hljs-type">int</span> newX=top.x+X[i],newY=top.y+Y[i];<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">judge</span>(newX,newY))&#123; <span class="hljs-comment">//如果这个新位置是符合要求的，需要访问</span><br>                Node.x=newX;Node.y=newY;<br>                q.<span class="hljs-built_in">push</span>(Node); <span class="hljs-comment">//入队</span><br>                inq[newX][newY]=<span class="hljs-literal">true</span>; <span class="hljs-comment">//已经入过队</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;m&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>            cin&gt;&gt;matrix[i][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>; <span class="hljs-comment">//记录答案（块数</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>            <span class="hljs-keyword">if</span>(matrix[i][j]==<span class="hljs-number">1</span>&amp;&amp;!inq[i][j])&#123; <span class="hljs-comment">//如果这个位置是1而且没有被访问过</span><br>                ans++; <span class="hljs-comment">//块数++</span><br>                <span class="hljs-built_in">bfs</span>(i,j);<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;ans;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然也可以使用dfs来实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*dfs的思路：</span><br><span class="hljs-comment">从输入的点开始搜索，如果碰到0了就return</span><br><span class="hljs-comment">否则走岔路口：往四个方向走*/</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">105</span>;<br><span class="hljs-type">int</span> m,n,matrix[maxn][maxn];<br><span class="hljs-type">int</span> X[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>&#125;,Y[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;; <span class="hljs-comment">//坐标增量数组</span><br><span class="hljs-type">bool</span> visited[maxn][maxn];<span class="hljs-comment">//记录是否查询过</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">1</span>||x&gt;m||y&lt;<span class="hljs-number">1</span>||y&gt;n||visited[x][y]||!matrix[x][y]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">//只要出界||入过队||在该点不为1,就不访问</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-comment">//搜索一个块内，并标记为true</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">judge</span>(x,y)) <span class="hljs-keyword">return</span>;<br>    visited[x][y]=<span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;<br>        <span class="hljs-type">int</span> newX=x+X[i],newY=y+Y[i];<br>        <span class="hljs-built_in">dfs</span>(newX,newY);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>            cin&gt;&gt;matrix[i][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>; <span class="hljs-comment">//记录答案（块数</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>            <span class="hljs-keyword">if</span>(matrix[i][j]&amp;&amp;!visited[i][j])&#123; <span class="hljs-comment">//如果这个位置是1而且没有被访问过</span><br>                <span class="hljs-built_in">dfs</span>(i,j);<br>                ans++;<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;ans;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来再来看一个例题</p><blockquote><p>给定一个大小为n*m的迷宫，其中*代表不可通过的墙壁，而’.'代表平地，S表示起点，T表示终点。在移动过程中，如果当前位置是(x,y) （下标从0开始），且每次只能前往上下左右四个位置的平地，求从起点S到终点T的最少步数。</p></blockquote><p>由于求的是最少步数，而bfs是按照层次的顺序来遍历的，<strong>因此可以从S开始计数遍历的层数，到达终点T时的层数就是需要求解的起点S到终点T的最少步数。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">105</span>;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> X[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>&#125;,Y[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;; <span class="hljs-comment">//增量数组</span><br><span class="hljs-type">char</span> maze[maxn][maxn]; <span class="hljs-comment">//迷宫</span><br><span class="hljs-type">bool</span> inq[maxn][maxn]=&#123;<span class="hljs-literal">false</span>&#125;; <span class="hljs-comment">//是否已入过队</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>    <span class="hljs-type">int</span> x,y;<br>    <span class="hljs-type">int</span> step; <span class="hljs-comment">//从起点S到该位置的最少步数（即层数）</span><br>&#125;S,T,Node; <span class="hljs-comment">///起点、终点、临时结点</span><br><span class="hljs-comment">//判断这个路径是否可行</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>||x&gt;=n||y&lt;<span class="hljs-number">0</span>||y&gt;=m||maze[x][y]==<span class="hljs-string">&#x27;*&#x27;</span>||inq[x][y]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-comment">//找到一条最短的路径</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span>&#123;<br>    queue&lt;node&gt; q;<br>    q.<span class="hljs-built_in">push</span>(S);<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>        node top=q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span>(top.x==T.x&amp;&amp;top.y==T.y) <span class="hljs-keyword">return</span> top.step;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;<br>            <span class="hljs-type">int</span> newX=top.x+X[i],newY=top.y+Y[i];<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">judge</span>(newX,newY))&#123;<br>                Node.x=newX,Node.y=newY;<br>                Node.step=top.step<span class="hljs-number">+1</span>;<br>                q.<span class="hljs-built_in">push</span>(Node);<br>                inq[newX][newY]=<span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">//无法到达的时候返回-1</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)&#123;<br>            cin&gt;&gt;maze[i][j];<br>        &#125;<br>    &#125;<br>    cin&gt;&gt;S.x&gt;&gt;S.y&gt;&gt;T.x&gt;&gt;T.y;<br>    S.step=<span class="hljs-number">0</span>; <span class="hljs-comment">//初始化</span><br>    cout&lt;&lt;<span class="hljs-built_in">bfs</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>这里如果要改成“输出最短的路径”</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">105</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>    <span class="hljs-type">int</span> x,y;<br>    vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; &gt; path;<br>&#125;S,T,Node; <span class="hljs-comment">//起点、终点、临时结点</span><br><span class="hljs-type">int</span> n,m,maze[maxn][maxn],X[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>&#125;,Y[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">bool</span> inq[maxn][maxn]=&#123;<span class="hljs-literal">false</span>&#125;;<span class="hljs-comment">//是否已入过队</span><br><span class="hljs-comment">//判断这个路径是否可行</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">1</span>||x&gt;n||y&lt;<span class="hljs-number">1</span>||y&gt;m||maze[x][y]||inq[x][y]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span>&#123;<br>    queue&lt;node&gt; q;<br>    q.<span class="hljs-built_in">push</span>(S);<br>    inq[S.x][S.y]=<span class="hljs-literal">true</span>; <span class="hljs-comment">//起点入队</span><br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>        node top=q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span>(top.x==T.x&amp;&amp;top.y==T.y)&#123; <span class="hljs-comment">//到达终点</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; x:top.path)&#123;<br>                cout&lt;&lt;x.first&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>&lt;&lt;x.second&lt;&lt;endl;<br>            &#125;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;<br>            <span class="hljs-type">int</span> nowX=top.x+X[i],nowY=top.y+Y[i]; <span class="hljs-comment">//得到相邻的点</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">judge</span>(nowX,nowY))&#123; <span class="hljs-comment">//如果可以走</span><br>                Node.x=nowX,Node.y=nowY;<br>                Node.path=top.path; <span class="hljs-comment">//复制之前的路径</span><br>                Node.path.<span class="hljs-built_in">push_back</span>(&#123;Node.x,Node.y&#125;); <span class="hljs-comment">//加上现在的路径</span><br>                q.<span class="hljs-built_in">push</span>(Node); <span class="hljs-comment">//入队</span><br>                inq[Node.x][Node.y]=<span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br>            cin&gt;&gt;maze[i][j];<br>        &#125;<br>    &#125;<br>    S.x=<span class="hljs-number">1</span>,S.y=<span class="hljs-number">1</span>,S.path.<span class="hljs-built_in">push_back</span>(&#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;);<br>    T.x=n,T.y=m;<br>    <span class="hljs-built_in">bfs</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><blockquote><p>[!CAUTION]</p><p>在BFS中设置的inq数组的含义是<strong>结点是否已经入过队</strong>，而非结点是否已经被访问。</p><p>区别：如果设置成是结点是否已经被访问，有可能某个结点正在队列中（但还未被访问）的时候由于其他结点可以到达他而将这个结点再次入队，导致很多结点反复入队。</p></blockquote><blockquote><p>[!TIP]</p><p>由于元素入队的时候相当于是在队列里面创造了一个副本，因此在对应的容器中修改并不会修改到另一个元素。</p><p>所以当需要对队列中的元素进行修改而不仅仅是访问的时候，<strong>队列中存放的元素最好不要是元素本身而应该是它们的编号。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>    <span class="hljs-type">int</span> data;<br>&#125;a[<span class="hljs-number">10</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">3</span>;i++)&#123;<br>        a[i].data=i;<br>        q.<span class="hljs-built_in">push</span>(i); <span class="hljs-comment">//这里存放的是下标</span><br>    &#125;<br>    a[q.<span class="hljs-built_in">front</span>()].data=<span class="hljs-number">100</span>;<br>    cout&lt;&lt;a[<span class="hljs-number">1</span>].data; <span class="hljs-comment">//输出100</span><br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h1>第9章 提高篇（3）——数据结构专题（2）</h1><h2 id="9-1-树与二叉树">9.1 树与二叉树</h2><h3 id="9-1-1-树的定义与性质">9.1.1 树的定义与性质</h3><p>数据结构中将树枝分叉处、树叶、树根抽象为结点（node），其中树根抽象为根节点（root），且对于一棵树最多只存在一个根节点；把树叶抽象为叶子结点（leaf），且叶子结点不再延伸出新的结点；把茎干和树枝统一抽象为边（edge），且一条边只用来连接两个结点（一个端点一个）。</p><p>在数据结构中一般把根节点置于最上方（与现实中相反），然后向下延伸出若干条边到达子结点（从而向下形成子树(child），而子结点又向下延伸出边并连接一些结点，直至到达叶子结点。</p><p>下面给出树的几个比较实用的概念和性质，其中1,5经常用来出边界数据</p><ol><li>树可以没有结点，这种情况称之为空树</li><li>树的层次从根节点开始算起，即根结点为第一层，根结点子树的根结点为第二层，以此类推</li><li>二叉树的宽度（Width of a Binary Tree）通常指的是<strong>同一层中节点的最大个数</strong>。</li><li>由于一条边连接两个结点，且树中不存在环，因此对于有n个结点的树，边数一定是n-1，且满足连通、边数=顶点数-1的结构一定是一棵树</li><li>叶子结点被定义为度为0的结点，因此当树中只有一个结点（即只有根节点）时，根节点也算做叶子结点</li><li>结点的深度（depth）是指从根节点（深度为1）开始自顶而下逐层累加至该结点时的深度值，结点的高度（height）是指从最底层叶子结点（高度为1）开始自底向上逐层累加至该结点的高度值。树的深度是指树中结点的最大深度，树的高度是指树中结点的最大高度。对树而言深度==高度，但是具体到某个结点就不一定了。</li><li>多棵树组合在一起称之为森林（forest）</li></ol><h3 id="9-1-2-二叉树的递归定义">9.1.2 二叉树的递归定义</h3><p>直接给出二叉树的递归定义</p><ol><li>要么二叉树没有根节点，是一颗空树</li><li>要么二叉树由根节点、左子树、右子树组成，且左子树和右子树都是二叉树</li></ol><p>递归定义：用自身来定义自身（比如斐波那契数列F(n)=F(n-1)+F(n-2)就是一种递归定义，用自身序列的元素来定义这个序列本身）</p><p>或者说一个家族里面，爷爷是父亲的父亲，曾爷爷是父亲的父亲的父亲，这样直系血缘关系的男性都可以用父亲这个定义来定义</p><p>再分析二叉树的递归定义的递归边界和递归式：</p><ul><li>递归边界：如果当前结点为空，递归就到达了树的边界</li><li>递归式：一个结点连接的两个子树都是二叉树</li></ul><p>介绍几种特殊的二叉树</p><ol><li>满二叉树：每一层的结点个数都达到了当层能达到的最大结点数</li><li>完全二叉树：除了最下面一层以外每一层的结点个数都达到了当层能达到的最大结点数，且最下面一层只是从左到右存在若干的连续结点，而这些连续结点右边的结点全部不存在</li></ol><p>从二叉树的角度来理解几个树的概念</p><ol><li>层次：把二叉树看作家谱，那么层次就是辈分</li><li>孩子结点、父亲结点、兄弟节点、祖先节点、子孙节点：一个结点的子树的根节点称之为该节点的孩子结点，而它称之为该孩子结点的父亲结点，与该结点同父亲的结点称之为该结点的兄弟节点（同一层次非同父亲的结点称之为堂兄弟节点）。如果存在一个从结点X到结点Y从上而下的路径，称X是Y的祖先结点，Y是X的子孙结点。<strong>自己就是自己的祖先节点，也是自己的子孙结点</strong>。</li></ol><h3 id="9-1-3-二叉树的存储结构与基本操作">9.1.3 二叉树的存储结构与基本操作</h3><h4 id="1-二叉树的存储结构">1.二叉树的存储结构</h4><p>使用链表来定义，区别是由于二叉树每个结点有两条出边，指针域也变成了两个。如果子树是空树，那么就指向NULL，也把这种链表称为二叉链表</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>    <span class="hljs-keyword">typename</span> data; <span class="hljs-comment">//数据域</span><br>    node* lchild; <span class="hljs-comment">//指向左子树根节点的指针</span><br>    node* rchild; <span class="hljs-comment">//指向右子树根节点的指针</span><br>&#125;<br></code></pre></td></tr></table></figure><p>由于二叉树建树之前根节点不存在，地址一般设置为NULL</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">node *root=<span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure><p>如果需要新建节点（比如往二叉树里面插入结点的时候）可以使用这个函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">node* <span class="hljs-title">newNode</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span></span>&#123;<br>    node *Node=<span class="hljs-keyword">new</span> node;<br>    Node-&gt;data=v; <span class="hljs-comment">//结点的数据/权值为v</span><br>    Node-&gt;lchild=Node-&gt;rchild=<span class="hljs-literal">NULL</span>; <span class="hljs-comment">//初始状态下没有左右孩子</span><br>    <span class="hljs-keyword">return</span> Node;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-二叉树结点的查找、修改">2.二叉树结点的查找、修改</h4><p>查找：在给定数据域的条件下，在二叉树中找到所有数据域为给定数据域的结点</p><p>修改：在查找的基础上，将它们的数据域修改为给定的数据域</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">search</span><span class="hljs-params">(node* root,<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> newData)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span>(root-&gt;data==x) root-&gt;data=newData;<br>    <span class="hljs-comment">//往左右子树递归查找</span><br>    <span class="hljs-built_in">search</span>(root-&gt;lchild,x,newData);<br>    <span class="hljs-built_in">search</span>(root-&gt;rchild,x,newData);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-二叉树结点的插入">3.二叉树结点的插入</h4><p>可以这样考虑：查找失败的位置就是该插入的位置</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//insert函数将在二叉树中插入一个数据域为x的新结点</span><br><span class="hljs-comment">//注意根结点root要使用引用</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(node* &amp;root,<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)&#123; <span class="hljs-comment">//查找失败：插入位置：递归边界</span><br>        root=<span class="hljs-built_in">newNode</span>(x);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(由二叉树的性质，x应该插在左子树)&#123;<br>        <span class="hljs-built_in">insert</span>(root-&gt;lchild,x);<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">insert</span>(root-&gt;rchild,x);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为什么root一定要引用呢？这是因为在insert函数中将新建的结点赋给了root，如果不使用引用这个语句就无法作用到原变量（即上一层的root-&gt;lchild和root-&gt;rchild）上去，也就不能把新结点接到二叉树上面去，因此insert函数必须加引用</p><p><strong>判断是否需要加引用的方法</strong>：如果函数中需要新建结点，即对二叉树的结构进行修改，就需要加引用；如果是指修改当前已有结点的内容或只是遍历树，就不需要加引用。</p><p>至于有时候可能判断不出来，不妨试一下加引用和不加引用的区别再来进行选择。</p><p><strong>新建结点之后务必令新结点的左右指针域为NULL，表示这个新结点暂时没有左右子树</strong></p><h4 id="4-二叉树的创建">4.二叉树的创建</h4><p>二叉树的创建其实就是二叉树结点的插入过程，而插入所需要的结点数据域一般都会由题目给出。一般是把需要插入的数据存在数组中然后再一个一个insert进去，最终返回指向根节点的指针root</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//二叉树的建立</span><br><span class="hljs-function">node* <span class="hljs-title">Create</span><span class="hljs-params">(<span class="hljs-type">int</span> data[],<span class="hljs-type">int</span> len)</span></span>&#123;<br>    node* root=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>        <span class="hljs-built_in">insert</span>(root,data[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-二叉树存储结构图示">5.二叉树存储结构图示</h4><p>root==NULL是结点地址为NULL，也即结点不存在</p><p>而*root==NULL是错误的，因为这个意思是root指向的空间为空，但无法说明地址是否为空</p><h4 id="6-完全二叉树的存储结构">6.完全二叉树的存储结构</h4><p>对于完全二叉树来说有更方便的存储方法。假设从上到下从左到右从1开始编号：</p><p>对于完全二叉树中的任何一个结点（设编号为x）则其左孩子的编号一定是2x而右孩子的编号一定是2x+1</p><p>因此可以建立一个大小为$2^k$的数组存放所有结点的信息，其中k为完全二叉树的最大高度，其中1号位存放的是根节点（不从0开始）</p><p>且该数组中元素存放的顺序恰好为该完全二叉树的层序遍历序列，而判断某个结点是否为叶结点的标志是：该结点（记下标为root）的左子节点（为什么是左子节点？因为完全二叉树允许右边全空）的编号root*2大于结点总个数；判断某个结点是否为空节点的标志是该结点下标大于结点总个数n</p><h2 id="9-2-二叉树的遍历">9.2 二叉树的遍历</h2><p>指通过一定顺序访问二叉树中的所有节点。</p><p>把一颗二叉树分为3个部分：根结点、左子树、右子树，然后这样就可以递归遍历。</p><p>前三种遍历无论是哪一种，都有左子树一定先于右子树遍历，且所谓的”先中后“都是指根结点root在遍历中的位置。</p><h3 id="9-2-1-先序遍历">9.2.1 先序遍历</h3><h4 id="1-先序遍历的实现">1.先序遍历的实现</h4><p>先访问根结点root，再访问左子树和右子树。顺序为根-&gt;左-&gt;右</p><p>考虑递归式：顺序为根-&gt;左-&gt;右</p><p>递归边界：访问到子树为空树即死胡同</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">preorder</span><span class="hljs-params">(node *root)</span></span>&#123;<br><span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-comment">//访问根结点root，例如将其数据域输出</span><br>cout&lt;&lt;root-&gt;data;<br><span class="hljs-comment">//访问左子树</span><br><span class="hljs-built_in">preorder</span>(root-&gt;lchild);<br><span class="hljs-comment">//访问右子树</span><br><span class="hljs-built_in">preorder</span>(root-&gt;lchild);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-先序遍历序列的性质">2.先序遍历序列的性质</h4><p>由于先序遍历先访问根结点，<strong>因此对于一棵二叉树的先序遍历序列，序列的第一个一定是根结点。</strong></p><h3 id="9-2-2-中序遍历">9.2.2 中序遍历</h3><h4 id="1-中序遍历的实现">1.中序遍历的实现</h4><p>左子树-&gt;根节点-&gt;右子树</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inorder</span><span class="hljs-params">(node *root)</span></span>&#123;<br><span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-comment">//访问左子树</span><br><span class="hljs-built_in">inorder</span>(root-&gt;lchild);<br>cout&lt;&lt;root-&gt;data; <span class="hljs-comment">//把根结点的访问放在左右子树之间</span><br><span class="hljs-built_in">inorder</span>(root-&gt;rchild);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-中序遍历序列的性质">2.中序遍历序列的性质</h4><p>只要知道根结点，就可以通过根结点在中序遍历序列中的位置区分出左右子树。</p><h3 id="9-2-3-后序遍历">9.2.3 后序遍历</h3><h4 id="1-后序遍历的实现">1.后序遍历的实现</h4><p>左子树-&gt;右子树-&gt;根节点</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">postorder</span><span class="hljs-params">(node* root)</span></span>&#123;<br><span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-built_in">postorder</span>(root-&gt;lchild);<br><span class="hljs-built_in">postorder</span>(root-&gt;rchild);<br>cout&lt;&lt;root-&gt;data;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-后序遍历序列的性质">2.后序遍历序列的性质</h4><p>序列的最后一个一定是根节点。</p><p><strong>无论是先序遍历序列还是后序遍历序列，都必须知道中序遍历序列才能唯一地确定一棵树。</strong></p><p>因为只有通过中序遍历序列才能利用根结点把左右子树分开从而递归生成一棵二叉树。</p><p>当然这个做法必须要保证元素两两不同才能使用。</p><h3 id="9-2-4-层序遍历">9.2.4 层序遍历</h3><p>按照层次的顺序从根结点往下逐层进行遍历，且对同一层的结点从左到右进行遍历。这个比较像BFS。基本思路如下</p><ol><li>将根节点加入队列q</li><li>取出队首结点并访问之</li><li>如果该节点有左孩子，将左孩子入队</li><li>如果该节点有右孩子，将右孩子入队</li><li>返回2.直到队列为空</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LayerOrder</span><span class="hljs-params">(node *root)</span></span>&#123;<br>queue&lt;node*&gt; q; <span class="hljs-comment">//注意队列里面是存放地址</span><br>q.<span class="hljs-built_in">push</span>(root);<br><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>node* top=q.<span class="hljs-built_in">front</span>();<br>q.<span class="hljs-built_in">pop</span>();<br><span class="hljs-comment">//（访问队首元素）</span><br><span class="hljs-keyword">if</span>(top-&gt;lchild!=<span class="hljs-literal">NULL</span>) q.<span class="hljs-built_in">push</span>(top-&gt;lchild);<br><span class="hljs-keyword">if</span>(top-&gt;rchild!=<span class="hljs-literal">NULL</span>) q.<span class="hljs-built_in">push</span>(top-&gt;rchild);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>可以发现这里队列中的元素是node*而不是node，这是因为之前提到过queue中存放的只是元素的副本，如果想要对原元素进行修改就存放地址也就是node*型变量。</strong></p><p>另外，许多时候题目要求计算出每个结点所在的层次，这个时候需要在二叉树结点的定义中添加一个layer变量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>    <span class="hljs-type">int</span> data,layer;<br>    node* lchild;<br>    node* rchild;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LayerOrder</span><span class="hljs-params">(node *root)</span></span>&#123;<br>    queue&lt;node*&gt; q;<br>    root-&gt;layer=<span class="hljs-number">0</span>; <span class="hljs-comment">//设置根结点的层号为0</span><br>    q.<span class="hljs-built_in">push</span>(root);<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>        node* top=q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-comment">//访问队首元素</span><br>        <span class="hljs-keyword">if</span>(top-&gt;lchild!=<span class="hljs-literal">NULL</span>)&#123;<br>            top-&gt;lchild-&gt;layer=top-&gt;layer<span class="hljs-number">+1</span>;<br>            q.<span class="hljs-built_in">push</span>(top-&gt;lchild);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(top-&gt;rchild!=<span class="hljs-literal">NULL</span>)&#123;<br>            top-&gt;rchild-&gt;layer=top-&gt;layer<span class="hljs-number">+1</span>;<br>            q.<span class="hljs-built_in">push</span>(top-&gt;rchild);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后解决一个重要的问题，<strong>给定给定一棵二叉树的先序遍历序列和中序遍历序列，重建这棵二叉树。</strong></p><p>设已知先序序列为$pre_1、pre_2、\cdots 、pre_n$，中序序列为$in_1、in_2、\cdots、in_n$，则$pre_1$是当前二叉树根结点。</p><p>又由中序序列可知，当前二叉树的根结点将中序序列划分为左子树和右子树。因此需要在中序序列中找到$in_k=pre_1$这样就在中序序列中找到了根结点。易知左子树结点个数为numLeft=k-1，于是左子树的先序序列区间就是[2,k]，中序序列区间是[1,k-1]；右子树的先序序列区间是[k+1,n]，中序序列区间是[k+1,n]，于是就只需要往左子树和右子树递归构建二叉树即可。</p><p>事实上如果当前递归过程中先序序列的区间为[preL,preR]，中序序列的区间为[inL,inR]，那么左子树的结点个数为numLeft=k-inL，这样左子树的先序序列区间就是[preL+1,preL+numLeft]，左子树的中序序列区间是[inL,k-1]；右子树的先序序列区间是[preL+numLeft+1,preR]，中序序列区间是[k+1,inR]。</p><p>递归边界是当先序序列的长度小于0时，当前二叉树不存在。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> pre[],in[]; <span class="hljs-comment">//先序序列和中序序列</span><br><span class="hljs-comment">//当前先序序列区间为[preL,preR]，中序序列区间为[inL,inR]，返回根结点地址]</span><br><span class="hljs-function">node* <span class="hljs-title">create</span><span class="hljs-params">(<span class="hljs-type">int</span> preL,<span class="hljs-type">int</span> preR,<span class="hljs-type">int</span> inL,<span class="hljs-type">int</span> inR)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(preL&gt;preR) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    node* root=<span class="hljs-keyword">new</span> node;<br>    root-&gt;data=pre[preL];<br>    <span class="hljs-type">int</span> k;<br>    <span class="hljs-keyword">for</span>(k=inL;k&lt;=inR;k++)&#123; <span class="hljs-comment">//这里循环变量可以不使用i</span><br>        <span class="hljs-keyword">if</span>(in[k]==root-&gt;data) <span class="hljs-keyword">break</span>; <span class="hljs-comment">//在中序序列中找到根结点</span><br>    &#125;<br>    <span class="hljs-type">int</span> numLeft=k-inL;<br>    <span class="hljs-comment">//左子树的结点个数为numLeft=k-inL，左子树的先序序列区间就是[preL+1,preL+numLeft]，左子树的中序序列区间是[inL,k-1]；</span><br>    <span class="hljs-comment">//右子树的先序序列区间是[preL+numLeft+1,preR]，中序序列区间是[k+1,inR]</span><br>    <span class="hljs-comment">//返回左子树的根结点地址，赋值给root的左指针</span><br>    root-&gt;lchiild=<span class="hljs-built_in">create</span>(preL<span class="hljs-number">+1</span>,preL+numLeft,inL,k<span class="hljs-number">-1</span>);<br>    <span class="hljs-comment">//返回右子树的根结点地址，赋值给root的右指针</span><br>    root-&gt;rchild=<span class="hljs-built_in">create</span>(preL+numLeft<span class="hljs-number">+1</span>,preR,k<span class="hljs-number">+1</span>,inR);<br>    <span class="hljs-keyword">return</span> root; <span class="hljs-comment">//返回根结点地址</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果使用静态实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>    <span class="hljs-type">char</span> data;<br>    <span class="hljs-type">int</span> lchild;<br>    <span class="hljs-type">int</span> rchild;<br>&#125;Node[<span class="hljs-number">30</span>];<br><span class="hljs-type">int</span> idx=<span class="hljs-number">0</span>;<br><span class="hljs-comment">//Node[0]为根结点</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">create</span><span class="hljs-params">(<span class="hljs-type">int</span> preL,<span class="hljs-type">int</span> preR,<span class="hljs-type">int</span> inL,<span class="hljs-type">int</span> inR)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(preL&gt;preR) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int</span> cur=idx++;<br>    Node[cur].data=pre[preL];<br>    <span class="hljs-type">int</span> k;<br>    <span class="hljs-keyword">for</span>(k=inL;k&lt;=inR;k++)&#123;<br>        <span class="hljs-keyword">if</span>(in[k]==pre[preL]) <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> numLeft=k-inL;<br>    <br>    Node[cur].lchild=<span class="hljs-built_in">create</span>(preL<span class="hljs-number">+1</span>,preL+numLeft,inL,k<span class="hljs-number">-1</span>);<br>    Node[cur].rchild=<span class="hljs-built_in">create</span>(preL+numLeft<span class="hljs-number">+1</span>,preR,k<span class="hljs-number">+1</span>,inR);<br>    <span class="hljs-keyword">return</span> cur;<br>&#125;<br></code></pre></td></tr></table></figure><p>结论：<strong>中序序列可以与先序序列、后序序列、层序序列中的任意一个来构建一棵唯一的二叉树，而后面三个两两搭配均不可以。</strong></p><blockquote><p><strong>【PAT A1020】 Tree Traversals</strong></p><p>给出一棵二叉树的后序遍历序列和中序遍历序列，求这颗二叉树的层序遍历序列。</p></blockquote><p>考虑先用后序遍历序列和中序遍历序来重建二叉树，再对二叉树进行层序遍历。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">35</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>    <span class="hljs-type">int</span> data;<br>    node *lchild,*rchild;<br>&#125;;<br><span class="hljs-type">int</span> n,in[maxn],post[maxn];<br><span class="hljs-comment">//中序序列的开始和结尾，后序序列的开始和结尾</span><br><span class="hljs-comment">//返回构建出的二叉树的根结点</span><br><span class="hljs-function">node *<span class="hljs-title">create</span><span class="hljs-params">(<span class="hljs-type">int</span> inL,<span class="hljs-type">int</span> inR,<span class="hljs-type">int</span> postL,<span class="hljs-type">int</span> postR)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(postL&gt;postR) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-comment">//初始化根结点</span><br>    node* root=<span class="hljs-keyword">new</span> node;<br>    root-&gt;data=post[postR];<br>    <span class="hljs-comment">//先找到根节点所在的位置</span><br>    <span class="hljs-type">int</span> k;<br>    <span class="hljs-keyword">for</span>(k=inL;k&lt;=inR;k++)&#123;<br>        <span class="hljs-keyword">if</span>(in[k]==post[postR]) <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> numLeft=k-inL; <span class="hljs-comment">//左子树的结点个数</span><br>    <span class="hljs-comment">//左子树：中序序列区间为[inL,k-1] 后序序列区间为[postL,postL+numLeft-1]</span><br>    root-&gt;lchild=<span class="hljs-built_in">create</span>(inL,k<span class="hljs-number">-1</span>,postL,postL+numLeft<span class="hljs-number">-1</span>);<br>    <span class="hljs-comment">//右子树：中序序列区间为[k+1,inR] 后序序列区间为[postL+numLeft,postR-1]</span><br>    root-&gt;rchild=<span class="hljs-built_in">create</span>(k<span class="hljs-number">+1</span>,inR,postL+numLeft,postR<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br><span class="hljs-comment">//对二叉树进行层序遍历</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">layerOrder</span><span class="hljs-params">(node *root)</span></span>&#123;<br>    queue&lt;node*&gt; q;<br>    q.<span class="hljs-built_in">push</span>(root);<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>        node *top=q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        cout&lt;&lt;top-&gt;data&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;<br>        <span class="hljs-keyword">if</span>(top-&gt;lchild!=<span class="hljs-literal">NULL</span>) q.<span class="hljs-built_in">push</span>(top-&gt;lchild);<br>        <span class="hljs-keyword">if</span>(top-&gt;rchild!=<span class="hljs-literal">NULL</span>) q.<span class="hljs-built_in">push</span>(top-&gt;rchild);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin&gt;&gt;post[i];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin&gt;&gt;in[i];<br>    node *root=<span class="hljs-built_in">create</span>(<span class="hljs-number">1</span>,n,<span class="hljs-number">1</span>,n);<br>    <span class="hljs-built_in">layerOrder</span>(root);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="9-2-5-二叉树的静态实现">9.2.5 二叉树的静态实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>    <span class="hljs-keyword">typename</span> data;<br>    <span class="hljs-type">int</span> lchild;<br>    <span class="hljs-type">int</span> rchild;<br>&#125;Node[maxn];<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> idx=<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">newNode</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span></span>&#123;<br>    Node[idx].data=v;<br>    Node[idx].lchild=<span class="hljs-number">-1</span>; <span class="hljs-comment">// 以-1表示空</span><br>    Node[idx].rchild=<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> idx++;<br>&#125;<br></code></pre></td></tr></table></figure><p>诸如此类的。反正就是静态化。</p><p>需要注意的是与非静态的二叉树的层序遍历相同，静态实现的二叉树的层序遍历在定义队列的时候应该是<code>queue&lt;int&gt; q</code>，其中int是下标，而不应该是<code>queue&lt;node&gt; q</code>。</p><h2 id="9-3-树的遍历">9.3 树的遍历</h2><p>一般意义上的树，即子结点个数不限且子结点没有先后次序。</p><h3 id="9-3-1-树的静态写法">9.3.1 树的静态写法</h3><p>令指针域存放其所有子结点的地址（或者为其单开一个数组存放所有子结点的地址）。</p><p>静态写法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>    <span class="hljs-keyword">typename</span> data; <span class="hljs-comment">//数据域</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; child; <span class="hljs-comment">//指针域，存放所有子结点的下标</span><br>&#125;Node[maxn];<br></code></pre></td></tr></table></figure><p>与二叉树的静态实现类似，当需要新建一个结点时，就按顺序从数组中取出一个下标即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> idx=<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">newNode</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span></span>&#123;<br>    Node[idx].data=v;<br>    Node[idx].child.<span class="hljs-built_in">clear</span>(); <span class="hljs-comment">//清空子结点</span><br>    <span class="hljs-keyword">return</span> idx++; <span class="hljs-comment">//返回结点下标并令idx自增</span><br>&#125;<br></code></pre></td></tr></table></figure><p>不过一般题目里涉及非二叉树的树的考察的时候都会给出结点的编号，且一般都是0-n-1,所以不需要newNode函数。</p><h3 id="9-3-2-树的先根遍历">9.3.2 树的先根遍历</h3><p>即先访问根结点，再去访问所有子树。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">(<span class="hljs-type">int</span> root)</span></span>&#123;<br>    <span class="hljs-comment">//访问当前结点，比如输出</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp;x:Node[root].child)&#123;<br><span class="hljs-built_in">preOrder</span>(x); <span class="hljs-comment">//递归访问结点root的所有子结点</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在树的先根遍历代码中，虽然没有显式地写出递归边界，但实际上递归边界是存在的。递归边界是由树的结构决定的，具体来说，当遍历到一个叶子节点时，该节点没有子节点，因此不会进入for循环，递归调用自然终止。</p><h3 id="9-3-3-树的层序遍历">9.3.3 树的层序遍历</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>    <span class="hljs-type">int</span> layer;<br>    <span class="hljs-type">int</span> data;<br>    vector&lt;<span class="hljs-type">int</span>&gt; child;<br>&#125;Node[maxn];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">layerOrder</span><span class="hljs-params">(<span class="hljs-type">int</span> root)</span></span>&#123;<br>    queue&lt;<span class="hljs-type">int</span>&gt; q; <span class="hljs-comment">//记得queue里面存放的是指针/下标</span><br>    Node[root].layer=<span class="hljs-number">0</span>;<br>    q.<span class="hljs-built_in">push</span>(root);<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>        <span class="hljs-type">int</span> top=q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        cout&lt;&lt;Node[top].data;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp;x:Node[top].child)&#123;<br>            <span class="hljs-keyword">if</span>(x!=<span class="hljs-number">-1</span>)&#123;<br>                Node[x].layer=Node[top].layer<span class="hljs-number">+1</span>;<br>                q.<span class="hljs-built_in">push</span>(x);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="9-3-4-从树的遍历看DFS和BFS">9.3.4 从树的遍历看DFS和BFS</h3><h4 id="1-DFS与先根遍历">1.DFS与先根遍历</h4><p>对于所有合法的DFS求解过程，都可以把它画成树的形式，此时死胡同等价于树中的叶子结点，而岔道口等价于树中的非叶子结点，而且对这棵树的DFS遍历过程就是树的先根遍历的过程。</p><h4 id="2-BFS与层序遍历">2.BFS与层序遍历</h4><p>对所有合法的BFS求解过程，也可以画成树的形式。</p><blockquote><h4 id="【PAT-A1053-Path-of-Equal-Weight">【PAT A1053] Path of Equal Weight</h4><p>给定一棵树和每个结点的权值，求所有从根结点到叶子结点的路径，使得每条路径上的结点的权值之和等于给定的常数S。如果有多条这样的路径则按路径非递增的顺序输出。其中路径的大小指的是类似于字典序的排序(a1-&gt;a2-&gt;…an)</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">105</span>;<br><span class="hljs-type">int</span> n,m,S; <span class="hljs-comment">//树的结点数，非叶子结点个数（边数），给定权</span><br><span class="hljs-type">int</span> id,k,child;<br><span class="hljs-comment">//记录路径(记录的是结点的编号)，有更高权值的路径应优先输出，而读入时已经对权值排好了序，因此dfs的时候总是会优先访问权值更大的进行输出</span><br>vector&lt;<span class="hljs-type">int</span>&gt; path;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>    <span class="hljs-type">int</span> data;<br>    <span class="hljs-type">int</span> layer;<br>    vector&lt;<span class="hljs-type">int</span>&gt; child;<br>&#125;Node[maxn];<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> Node[a].data&gt;Node[b].data;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> idx,<span class="hljs-type">int</span> sum)</span></span>&#123; <span class="hljs-comment">//idx是目前访问的结点编号，sum是目前的权值和</span><br>    <span class="hljs-keyword">if</span>(sum&gt;S) <span class="hljs-keyword">return</span>; <span class="hljs-comment">//剪枝</span><br>    <span class="hljs-keyword">if</span>(sum==S)&#123;<br>        <span class="hljs-keyword">if</span>(Node[idx].child.<span class="hljs-built_in">empty</span>())&#123; <span class="hljs-comment">//如果这个时候是叶子结点才输出,否则直接return</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp;x:path) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,Node[x].data);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp;x:Node[idx].child)&#123;<span class="hljs-comment">//枚举所有孩子结点</span><br>        <span class="hljs-comment">//选择这个孩子结点</span><br>        path.<span class="hljs-built_in">push_back</span>(x); <span class="hljs-comment">//将结点child加到路径path末尾 </span><br>        <span class="hljs-built_in">dfs</span>(x,sum+Node[x].data); <span class="hljs-comment">//递归进入下一层</span><br>        <span class="hljs-comment">//不选择这个孩子结点,回溯</span><br>        path.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;S);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;Node[i].data);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;id,&amp;k);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;k;i++)&#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;child);<br>            Node[id].child.<span class="hljs-built_in">push_back</span>(child); <br>        &#125;<br>        <span class="hljs-comment">//输出的时候按照路径的权值输出，先把孩子的权值排好序</span><br>        <span class="hljs-built_in">sort</span>(Node[id].child.<span class="hljs-built_in">begin</span>(),Node[id].child.<span class="hljs-built_in">end</span>(),cmp);<br>    &#125;<br>    path.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">//插入根结点</span><br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>,Node[<span class="hljs-number">0</span>].data);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="9-4-二叉查找树（BST）">9.4 二叉查找树（BST）</h2><h3 id="9-4-1-二叉查找树的定义">9.4.1 二叉查找树的定义</h3><ul><li>要么是空树</li><li>若左子树不空，则左子树上所有结点的值均<strong>小于等于</strong>它的根结点的值</li><li>若右子树不空，则右子树上所有结点的值均<strong>大于</strong>它的根结点的值</li><li>左、右子树也分别为二叉排序树</li></ul><blockquote><p>其实有两种定义方式，还有一种是</p><ul><li>若左子树不空，则左子树上所有结点的值均小于它的根结点的值</li><li>若右子树不空，则右子树上所有结点的值均大于它的根结点的值</li><li><strong>没有权值相等的结点</strong></li></ul><p>这种情况下在结点里面加一个cnt变量记录这个权值的出现次数。</p></blockquote><h3 id="9-4-2-二叉查找树的基本操作">9.4.2 二叉查找树的基本操作</h3><h4 id="1-查找">1.查找</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>    <span class="hljs-type">int</span> v;<br>    <span class="hljs-type">int</span> lchild,rchild;<br>    <span class="hljs-type">int</span> siz; <span class="hljs-comment">//(两子树+自己本身)的大小（结点数之和）</span><br>&#125;bst[maxn];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> idx)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(idx==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">//查找失败</span><br>    <br>    <span class="hljs-keyword">if</span>(v==bst[idx].v)&#123;<br>        <span class="hljs-keyword">return</span> idx;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(v&lt;bst[idx].v)&#123;<br>        <span class="hljs-built_in">search</span>(v,bst[idx].lchild);<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">search</span>(v,bst[idx].rchild);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注：统一采用静态实现</strong></p><h4 id="2-插入">2.插入</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> idx)</span></span>&#123; <span class="hljs-comment">//v表示权值，idx表示当前的结点编号</span><br>    bst[idx].siz++;<br>    <span class="hljs-keyword">if</span>(v&gt;bst[idx].v)&#123; <span class="hljs-comment">//说明v应该插入到右子树</span><br>        <span class="hljs-keyword">if</span>(bst[idx].rchild!=<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-built_in">insert</span>(v,bst[idx].rchild);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">//不存在右孩子</span><br>            cnt++;<br>            bst[cnt].v=v;<br>            bst[cnt].siz=<span class="hljs-number">1</span>;<br>            bst[idx].rchild=cnt;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">if</span>(bst[idx].lchild!=<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-built_in">insert</span>(v,bst[idx].lchild);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            cnt++;<br>            bst[cnt].v=v;<br>            bst[cnt].siz=<span class="hljs-number">1</span>;<br>            bst[idx].lchild=cnt;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-删除">3.删除</h4><p>删除二叉搜索树（BST）中的节点有三种情况：</p><ol><li><strong>目标节点是叶子节点</strong>：直接删除即可。</li><li><strong>目标节点只有一个子节点</strong>：用它的唯一子节点代替它。</li><li><strong>目标节点有两个子节点</strong>：找到它的<strong>前驱</strong>（左子树的最大值）或<strong>后继</strong>（右子树的最小值）替换它，然后递归删除这个前驱或后继节点。</li></ol><p>先给出找前驱和后继的函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findPre</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span></span>&#123;<br>    <span class="hljs-type">int</span> idx=<span class="hljs-number">1</span>; <span class="hljs-comment">//从根结点开始搜索</span><br>    <span class="hljs-type">int</span> ans=-inf;<br>    <span class="hljs-keyword">while</span>(idx)&#123;<br>        <span class="hljs-keyword">if</span>(bst[idx].v&lt;v)&#123;<br>            ans=bst[idx].v;<br>            idx=bst[idx].rchild;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            idx=bst[idx].lchild;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findPost</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span></span>&#123;<br>    <span class="hljs-type">int</span> idx=<span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> ans=inf;<br>    <span class="hljs-keyword">while</span>(idx)&#123;<br>        <span class="hljs-keyword">if</span>(bst[idx].v&gt;v)&#123;<br>            ans=bst[idx].v;<br>            idx=bst[idx].lchild;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            idx=bst[idx].rchild;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><p>再给出删除的函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;idx, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (idx == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 树为空，直接返回</span><br><br>    <span class="hljs-keyword">if</span> (v &lt; bst[idx].v) &#123;<br>        <span class="hljs-comment">// 目标值在左子树</span><br>        <span class="hljs-built_in">remove</span>(bst[idx].lchild, v);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (v &gt; bst[idx].v) &#123;<br>        <span class="hljs-comment">// 目标值在右子树</span><br>        <span class="hljs-built_in">remove</span>(bst[idx].rchild, v);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 找到目标节点</span><br>        <span class="hljs-keyword">if</span> (bst[idx].lchild == <span class="hljs-number">0</span> &amp;&amp; bst[idx].rchild == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 情况1：叶子节点，直接删除</span><br>            idx = <span class="hljs-number">0</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (bst[idx].lchild == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 情况2：只有右子树</span><br>            idx = bst[idx].rchild;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (bst[idx].rchild == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 情况2：只有左子树</span><br>            idx = bst[idx].lchild;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 情况3：有两个子节点</span><br>            <span class="hljs-type">int</span> preIdx = bst[idx].lchild;<br>            <span class="hljs-keyword">while</span> (bst[preIdx].rchild) &#123; <span class="hljs-comment">// 找前驱</span><br>                preIdx = bst[preIdx].rchild;<br>            &#125;<br>            bst[idx].v = bst[preIdx].v; <span class="hljs-comment">// 用前驱值替换</span><br>            <span class="hljs-built_in">remove</span>(bst[idx].lchild, bst[preIdx].v); <span class="hljs-comment">// 递归删除前驱</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (idx != <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 维护子树大小信息</span><br>        bst[idx].siz = <span class="hljs-number">1</span> + bst[bst[idx].lchild].siz + bst[bst[idx].rchild].siz;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="9-4-3-二叉查找树的性质">9.4.3 二叉查找树的性质</h3><h2 id="9-5-平衡二叉树（AVL树）">9.5 平衡二叉树（AVL树）</h2><h3 id="9-5-1-平衡二叉树的定义">9.5.1 平衡二叉树的定义</h3><h3 id="9-5-2-平衡二叉树的基本操作">9.5.2 平衡二叉树的基本操作</h3><h2 id="9-6-并查集">9.6 并查集</h2><h3 id="9-6-1-并查集的定义">9.6.1 并查集的定义</h3><p>并查集是一种维护集合的数据结构。</p><p>“并”“查”“集”分别取自合并、查找、集合。</p><p>并查集支持以下两个操作</p><ol><li>合并：合并两个集合</li><li>查找：判断两个元素是否在一个集合</li></ol><p>实现方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> father[N];<br></code></pre></td></tr></table></figure><p>其中<code>father[i]</code>表示元素<code>i</code>的父亲结点，而父亲结点本身也是这个集合内的元素。比如<code>father[1]=2</code>表示元素1的父亲结点是元素2，以这种父系关系来表示元素所属的集合。另外如果<code>father[i]==i</code>则说明元素i是该集合的根结点，<strong>但对于同一个集合来说只存在一个根结点，且将其作为所属集合的标识。</strong></p><h3 id="9-6-2-并查集的基本操作">9.6.2 并查集的基本操作</h3><h4 id="1-初始化">1.初始化</h4><p>一开始每个元素都是独立的一个集合，只需要全令<code>father[i]=i</code>或令<code>father[i]=-1</code></p><h4 id="2-查找">2.查找</h4><p>由于规定了同一个集合只存在一个根结点，因此查找操作就是对给定的结点去寻找其根结点的过程，实现的方式可以是递推或者递推。思路都是反复寻找父亲结点直到寻找到根结点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findFather</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(x!=father[x])&#123;<br>        x=father[x];<br>    &#125;<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findFather</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(x==father[x]) <span class="hljs-keyword">return</span> x;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">findFather</span>(father[x]);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-合并">3.合并</h4><p>合并指的是把两个集合并成一个集合。题目中一般给出两个元素然后要求把这两个元素所在的集合合并。具体实现是先判断两个元素是否属于一个集合，只有当两个元素属于不同集合的时候才合并，而合并的过程一般是把其中一个集合的根结点的父亲指向另一个集合的根结点。思路如下：</p><ol><li>对于给定的两个元素a b，先判断他们是否属于同一个集合，调用查找函数判断根结点是否相同即可。</li><li>合并两个集合：在1中已经获得了两个元素的根结点faA和faB，因此只需要把其中一个的父亲结点指向另一个结点。比如令<code>father[faA]=faB</code>或者反过来都可以。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Union</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>    <span class="hljs-type">int</span> faA=<span class="hljs-built_in">findFather</span>(a);<br>    <span class="hljs-type">int</span> faB=<span class="hljs-built_in">findFather</span>(b);<br>    <span class="hljs-keyword">if</span>(faA!=faB)&#123;<br>        father[faA]=faB;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="9-6-3-路径压缩">9.6.3 路径压缩</h3><p>上面提到的函数都没有进行优化。下面考虑一种极端情况，即题目给出的元素数量很多而且形成一条链，那么这个查找函数的效率就会很低。下面提出一种优化思路。</p><p>因为我们<code>findFather()</code>函数就只是为了寻找根结点，我们完全可以<strong>把当前查询结点的路径上的所有结点的父亲都指向根结点</strong>，查找的时候就不需要一直回溯去寻找父亲，时间复杂度降为$O(1)$。</p><p>进行转换的步骤可以这样概括：</p><ol><li>按照原来的写法获得x的根结点r</li><li>重新从x开始走一遍寻找根结点的过程，把路径上经过的所有结点的父亲全部改为根结点r。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findFather</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-type">int</span> a=x; <span class="hljs-comment">//由于x在下面的while循环会变成根结点，先存一下原来的x</span><br>    <span class="hljs-keyword">while</span>(x!=father[x])&#123;<br>        x=father[x];<br>    &#125;<br>    <span class="hljs-comment">//到这里x存放的是根结点，下面把路径上所有结点的father都改成根结点。</span><br>    <span class="hljs-keyword">while</span>(a!=father[a])&#123;<br>        <span class="hljs-type">int</span> z=a;<br>        a=father[a];<br>        father[z]=x;<br>    &#125;<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure><p>也有递归写法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findFather</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(x==father[x]) <span class="hljs-keyword">return</span> x;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-type">int</span> F=<span class="hljs-built_in">findFather</span>(father[x]);<br>        father[x]=F;<br>        <span class="hljs-keyword">return</span> F;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面给出一个简单使用并查集的题目</p><h3 id="例题-好朋友">例题 好朋友</h3><blockquote><h2 id="题目描述-2">题目描述</h2><p>有一个叫作“数码世界”的奇异空间，在数码世界里生活着许许多多的数码宝贝，其中有些数码宝贝之间可能是好朋友。并且数码世界有两条不成文的规定:</p><p>第一，数码宝贝A和数码宝贝B是好朋友等价于数码宝贝B和数码宝贝A是好朋友。</p><p>第二，如果数码宝贝A和数码宝贝C是好朋友，而数码宝贝B和数码宝贝C也是好朋友，那么A和B也是好朋友。<br>现在给出这些数码宝贝中所有好朋友的信息，问:可以把这些数码宝贝分成多少组，满足每组中的任意两只数码宝贝都是好朋友，且任意两组之间的数码宝贝都不是好朋友。</p><h2 id="输入格式-2">输入格式</h2><p>输入的第一行有两个正整数n(n&lt;=100)和m(m&lt;=100)，分别表示数码宝贝的个数和好朋友的组数，其中数码宝贝编号为1~n。<br>接下来有m行，每行两个正整数a和b，表示数码宝贝a和数码宝贝b是好朋友。</p><h2 id="样例输入">样例输入</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">4</span> <span class="hljs-number">2</span><br><span class="hljs-number">1</span> <span class="hljs-number">4</span><br><span class="hljs-number">2</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h2 id="样例输出">样例输出</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure></blockquote><p>本题是一个并查集模型，可以把题目中的“组”视为集合，而题目中给出的好朋友关系视为两个结点之间的边，那么在输入这些好朋友关系时就可以同时对它们进行并查集的合并操作。</p><p>对于集合个数的求解，需要用到这条规则：<strong>对于同一个集合来说只存在一个根结点，且将其作为所属集合的标识</strong>。因此开一个<code>bool flag[n]</code>来记录每个结点是否作为某个集合的根结点，这样在处理完输入数据之后就可以遍历所有元素，令它所在的集合的根结点的<code>flag</code>设置为<code>true</code>，最后累加<code>flag</code>中的元素即可。代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">110</span>;<br><span class="hljs-type">int</span> father[maxn];<br><span class="hljs-type">bool</span> flag[maxn];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findFather</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-type">int</span> a=x;<br>    <span class="hljs-keyword">while</span>(x!=father[x])&#123;<br>        x=father[x];<br>    &#125;<br>    <span class="hljs-keyword">while</span>(a!=father[a])&#123;<br>        <span class="hljs-type">int</span> z=a;<br>        a=father[a];<br>        father[z]=x;<br>    &#125;<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Union</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>    <span class="hljs-type">int</span> faA=father[a];<br>    <span class="hljs-type">int</span> faB=father[b];<br>    <span class="hljs-keyword">if</span>(faA!=faB)&#123;<br>        father[faA]=faB;<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n,m,a,b;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        father[i]=i;<br>        <span class="hljs-comment">//flag[i]=false; 全局变量默认是false</span><br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>        cin&gt;&gt;a&gt;&gt;b;<br>        <span class="hljs-built_in">Union</span>(a,b);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        flag[<span class="hljs-built_in">findFather</span>(i)]=<span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        ans+=(<span class="hljs-type">int</span>)flag[i];<br>    &#125;<br>    cout&lt;&lt;ans;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="9-7-堆">9.7 堆</h2><h3 id="9-7-1-堆的定义与基本操作">9.7.1 堆的定义与基本操作</h3><h3 id="9-7-2-堆排序">9.7.2 堆排序</h3><h2 id="9-8-哈夫曼树">9.8 哈夫曼树</h2><h3 id="9-8-1-哈夫曼树">9.8.1 哈夫曼树</h3><h3 id="9-8-2-哈夫曼编码">9.8.2 哈夫曼编码</h3><h1>第10章 提高篇（4）——图算法专题</h1><h2 id="10-1-图的定义和相关术语">10.1 图的定义和相关术语</h2><p>图由顶点和边组成。分为有向图和无向图。</p><p>顶点的度：与该顶点相连的边的条数。</p><p>对于有向图：顶点的出边条数称为出度，入边条数称为入度。</p><p>顶点和边的权值分别称为点权和边权。</p><h2 id="10-2-图的存储">10.2 图的存储</h2><h3 id="10-2-1-邻接矩阵">10.2.1 邻接矩阵</h3><p>设图G(V,E)的顶点编号从0到n-1，则可以令二维数组G[n][n]的两维分别表示图的顶点标号。</p><p>若G[i][j]==1 -&gt; 顶点i和j之间有边，若为0则没有。另外如果存在边权则令G[i][j]存放边权，而对于不存在的边就设边权为0,-1,或inf。</p><p>对于无向图来说，邻接矩阵是一个对称矩阵。</p><p>为了防止MLE，邻接矩阵只适用于顶点数目不太大(&lt;=1000)的题目。</p><h3 id="10-2-2-邻接表">10.2.2 邻接表</h3><p>设图G(V,E)的顶点编号从0到n-1，每个顶点都可能会有若干条出边，如果把同一个顶点的所有出边放到一个列表中，那么n个顶点就会有n个列表（没有出边则对应空表）。这n个列表被称为图G的<strong>邻接表</strong>，记作Adj[n]，其中Adj[i]存放顶点i的所有出边组成的列表。</p><p>这里我们使用vector来实现邻接表。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&#123;<br>  <span class="hljs-type">int</span> v; <span class="hljs-comment">//边的终点编号</span><br>  <span class="hljs-type">int</span> w; <span class="hljs-comment">//边权</span><br>  <span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> _v,<span class="hljs-type">int</span> _w):<span class="hljs-built_in">v</span>(_v),<span class="hljs-built_in">w</span>(_w)&#123;&#125;;<br>&#125;<br>vector&lt;Node&gt; Adj[n];<br></code></pre></td></tr></table></figure><p>然后如果我们这里想要添加从1号到达3号顶点的有向边，边权为4，就可以这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Adj[<span class="hljs-number">1</span>].<span class="hljs-built_in">emplace_back</span>(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>);<br></code></pre></td></tr></table></figure><p>如果想要添加一条无向边，可以这样设计一个函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 添加无向边 (u, v, w)</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v, <span class="hljs-type">int</span> w)</span> </span>&#123;<br>    Adj[u].<span class="hljs-built_in">emplace_back</span>(v, w);  <span class="hljs-comment">// 在u的邻接表中添加边 (u, v, w)</span><br>    Adj[v].<span class="hljs-built_in">emplace_back</span>(u, w);  <span class="hljs-comment">// 在v的邻接表中添加边 (v, u, w)</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这样，当添加无向边时，不仅将 <code>(v, w)</code> 添加到 <code>Adj[u]</code> 中，也会将 <code>(u, w)</code> 添加到 <code>Adj[v]</code> 中，保证图的双向性质。</p><h2 id="10-3-图的遍历">10.3 图的遍历</h2><h3 id="10-3-1-采用深度优先搜索（DFS）法遍历图">10.3.1 采用深度优先搜索（DFS）法遍历图</h3><p>首先介绍两个概念：</p><ol><li><strong>连通分量</strong>：在无向图中，如果两个顶点之间可以相互到达（可以是通过一定路径间接到达），那么就称这两个顶点连通。如果图G(V,E)的任意两个顶点均连通，则称图G为连通图，否则为非连通图，且称其中的极大连通子图为连通分量。</li><li><strong>强连通分量</strong>：在有向图中，如果两个顶点可以各自通过一条有向路径到达另一个顶点，就称这两个顶点强连通。如果图G(V,E)的任意两个顶点都强连通，则称图G为强连通图；否则称为非强连通图，且称其中的极大强连通子图为强连通分量。</li></ol><p>为了叙述上的方便下面把连通分量和强连通分量统称为<strong>连通块</strong>。</p><p>所以要遍历整个图就是要对所有连通块进行遍历。DFS遍历图的基本思路就是把以及访问过的顶点设置为已访问，在下次递归碰到这个顶点时就不再处理，直到整个图的顶点都被标记为已访问。</p><p>下面是一份DFS的伪代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">DFS</span>(u)&#123; <span class="hljs-comment">//访问顶点u</span><br>vis[u]=<span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span>(从u出发能到达的所有顶点v)&#123;<br>        <span class="hljs-keyword">if</span>(!vis[v]) <span class="hljs-built_in">DFS</span>(v);<br>    &#125;<br>    DFSTraveG&#123; <span class="hljs-comment">//遍历图G</span><br>        <span class="hljs-keyword">for</span>(G的所有顶点u)&#123;<br>            <span class="hljs-keyword">if</span>(!vis[u]) <span class="hljs-built_in">DFS</span>(u); <span class="hljs-comment">//访问u所在的连通块</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这份代码的基础上可以代入邻接矩阵和邻接表的代码，得到如下模板：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//邻接矩阵版本</span><br>cosnt <span class="hljs-type">int</span> maxv=<span class="hljs-number">1000</span>; <span class="hljs-comment">//最大顶点数</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf=<span class="hljs-number">0x3f3f3f3f</span>;<br><br><span class="hljs-type">int</span> n,G[maxv][maxv];<br><span class="hljs-type">bool</span> vis[maxv]=&#123;<span class="hljs-literal">false</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> depth)</span></span>&#123;<br>    vis[u]=<span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">//如果需要对u进行一些操作可以在这里进行</span><br>    <span class="hljs-comment">//下面对所有从u出发能到达的分支顶点进行枚举</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v=<span class="hljs-number">0</span>;v&lt;n;v++)&#123;<br>        <span class="hljs-keyword">if</span>(!vis[v]&amp;&amp;G[u][v]!=inf)&#123;<br>            <span class="hljs-built_in">dfs</span>(v,depth<span class="hljs-number">+1</span>); <span class="hljs-comment">//访问v，深度++</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFSTrave</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-comment">//遍历图G</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> u=<span class="hljs-number">0</span>;u&lt;n;u++)&#123;<br>        <span class="hljs-keyword">if</span>(!vis[u])&#123;<br>            <span class="hljs-built_in">dfs</span>(u<span class="hljs-number">+1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//邻接表版本</span><br>cosnt <span class="hljs-type">int</span> maxv=<span class="hljs-number">1000</span>; <span class="hljs-comment">//最大顶点数</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf=<span class="hljs-number">0x3f3f3f3f</span>;<br><br>vector&lt;<span class="hljs-type">int</span>&gt; Adj[maxv];<br><span class="hljs-type">int</span> n; <span class="hljs-comment">//顶点数</span><br><span class="hljs-type">bool</span> vis[maxv]=&#123;<span class="hljs-literal">false</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> depth)</span></span>&#123;<br>    vis[u]=<span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">//如果要对u进行一些操作可以在这里</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;(<span class="hljs-type">int</span>)Adj[u].<span class="hljs-built_in">size</span>();i++)&#123;<br>        <span class="hljs-type">int</span> v=Adj[u][i];<br>        <span class="hljs-keyword">if</span>(!vis[v]) <span class="hljs-built_in">dfs</span>(v,depth<span class="hljs-number">+1</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DFSTrave</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> u=<span class="hljs-number">0</span>;u&lt;n;u++)&#123;<br>        <span class="hljs-keyword">if</span>(!vis[u]) <span class="hljs-built_in">dfs</span>(u,<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="【PAT-A1034】-Head-of-a-gang">【PAT A1034】 Head of a gang</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">2010</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf=<span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">int</span> G[maxn][maxn];<br><span class="hljs-type">int</span> weight[maxn];<br><span class="hljs-type">bool</span> vis[maxn];<br>map&lt;string,<span class="hljs-type">int</span>&gt; stringToInt;<br>map&lt;<span class="hljs-type">int</span>,string&gt; intToString;<br>map&lt;string,<span class="hljs-type">int</span>&gt; Gang;<br><span class="hljs-type">int</span> n,k;<br><span class="hljs-type">int</span> numPerson;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">change</span><span class="hljs-params">(string s)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(stringToInt.<span class="hljs-built_in">find</span>(s)!=stringToInt.<span class="hljs-built_in">end</span>())&#123;<br>        <span class="hljs-keyword">return</span> stringToInt[s];<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        stringToInt[s]=numPerson;<br>        intToString[numPerson]=s;<br>        <span class="hljs-keyword">return</span> numPerson++;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> now,<span class="hljs-type">int</span> &amp;head,<span class="hljs-type">int</span> &amp;numMember,<span class="hljs-type">int</span> &amp;totalValue)</span></span>&#123;<br>    vis[now]=<span class="hljs-literal">true</span>;<br>    numMember++;<br>    <span class="hljs-keyword">if</span>(weight[now]&gt;weight[head]) head=now;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v=<span class="hljs-number">0</span>;v&lt;numPerson;v++)&#123;<br>        <span class="hljs-keyword">if</span>(!vis[v]&amp;&amp;G[now][v]!=<span class="hljs-number">0</span>)&#123;<br>            totalValue+=G[now][v];<br>            <span class="hljs-built_in">dfs</span>(v,head,numMember,totalValue);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfstrave</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;numPerson;i++)&#123;<br>        <span class="hljs-keyword">if</span>(!vis[i])&#123;<br>            <span class="hljs-type">int</span> head=i,numMember=<span class="hljs-number">0</span>,totalValue=<span class="hljs-number">0</span>;<br>            <span class="hljs-built_in">dfs</span>(i,head,numMember,totalValue);<br>            <span class="hljs-keyword">if</span>(numMember&gt;<span class="hljs-number">2</span>&amp;&amp;totalValue&gt;k)&#123;<br>                Gang[intToString[head]]=numMember;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;k;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        string s1,s2;<br>        <span class="hljs-type">int</span> w;<br>        cin&gt;&gt;s1&gt;&gt;s2&gt;&gt;w;<br>        <span class="hljs-type">int</span> id1=<span class="hljs-built_in">change</span>(s1);<br>        <span class="hljs-type">int</span> id2=<span class="hljs-built_in">change</span>(s2);<br>        weight[id1]+=w;<br>        weight[id2]+=w;<br>        G[id1][id2]+=w;<br>        G[id2][id1]+=w;<br>    &#125;<br>    <span class="hljs-built_in">dfstrave</span>();<br>    cout&lt;&lt;Gang.<span class="hljs-built_in">size</span>()&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;[x,y]:Gang)&#123;<br>        cout&lt;&lt;x&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;y&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="10-3-2-采用广度优先搜索（BFS）法遍历图">10.3.2 采用广度优先搜索（BFS）法遍历图</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//邻接矩阵版本</span><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> G[maxv][maxv];<br><span class="hljs-type">bool</span> inq[maxv];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123; <span class="hljs-comment">//遍历顶点u所在的连通块</span><br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    q.<span class="hljs-built_in">push</span>(u);<br>    inq[u]=<span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>        <span class="hljs-type">int</span> top=q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v=<span class="hljs-number">0</span>;v&lt;n;v++)&#123;<br>            <span class="hljs-keyword">if</span>(!inq[v]&amp;&amp;G[top][v]!=<span class="hljs-number">0</span>)&#123;<br>                q.<span class="hljs-built_in">push</span>(v);<br>                inq[v]=<span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfsTrave</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(!inq[i])&#123;<br>            <span class="hljs-built_in">bfs</span>(i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//邻接表版本</span><br>vector&lt;<span class="hljs-type">int</span>&gt; Adj[maxv];<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">bool</span> inq[maxv];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    q.<span class="hljs-built_in">push</span>(u);<br>    inq[u]=<span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>        <span class="hljs-type">int</span> top=q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v:Adj[top])&#123;<br>            <span class="hljs-keyword">if</span>(!inq[v])&#123;<br>                q.<span class="hljs-built_in">push</span>(v);<br>                inq[v]=<span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfsTrave</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(!inq[i])&#123;<br>            <span class="hljs-built_in">bfs</span>(i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果需要记录每个结点的层次，可以使用结构体</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//邻接表版本</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>    <span class="hljs-type">int</span> v;<br>    <span class="hljs-type">int</span> layer;<br>&#125;Node;<br>vector&lt;node&gt; Adj[maxv];<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">bool</span> inq[maxv];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span></span>&#123; <span class="hljs-comment">//s为起始顶点编号</span><br>    queue&lt;node&gt; q;<br>    Node.v=s;Node.layer=<span class="hljs-number">0</span>;<br>    q.<span class="hljs-built_in">push</span>(Node);<br>    inq[Node.v]=<span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>        node top=q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span>(node next:Adj[top.v])&#123;<br>            next.layer=top.layer<span class="hljs-number">+1</span>;<br>            <span class="hljs-keyword">if</span>(!inq[next.v])&#123;<br>                q.<span class="hljs-built_in">push</span>(next);<br>                inq[next.v]=<span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="10-4-最短路径">10.4 最短路径</h2><p>这是一个很经典的问题：给定图G(V,E)，求一条从起点到终点的路径，使得这条路径上经过的所有边的边权之和最小。</p><h3 id="10-4-1-Dijkstra算法">10.4.1 Dijkstra算法</h3><h3 id="10-4-2-Bellman-Ford算法和SPFA算法">10.4.2 Bellman-Ford算法和SPFA算法</h3><h3 id="10-4-3-Floyd算法">10.4.3 Floyd算法</h3><h2 id="10-5-最小生成树">10.5 最小生成树</h2><h3 id="10-5-1-最小生成树及其性质">10.5.1 最小生成树及其性质</h3><h3 id="10-5-2-prim算法">10.5.2 prim算法</h3><h3 id="10-5-3-kruskal算法">10.5.3 kruskal算法</h3><h2 id="10-6-拓扑排序">10.6 拓扑排序</h2><h3 id="10-6-1-有向无环图">10.6.1 有向无环图</h3><h3 id="10-6-2-拓扑排序">10.6.2 拓扑排序</h3><h2 id="10-7-关键路径">10.7 关键路径</h2><h3 id="10-7-1-AOV网和AOE网">10.7.1 AOV网和AOE网</h3><h3 id="10-7-2-最长路径">10.7.2 最长路径</h3><h3 id="10-7-3-关键路径">10.7.3 关键路径</h3><h1>第11章 提高篇（5）——动态规划专题</h1><h2 id="11-1-动态规划的递归写法和递推写法">11.1 动态规划的递归写法和递推写法</h2><h3 id="11-1-1-什么是动态规划">11.1.1 什么是动态规划</h3><p>是用来解决一类<strong>最优化问题</strong>的算法思想。简单来说，动态规划将一个复杂的问题分解成若干个子问题，通过综合子问题的最优解来得到原问题的最优解。动态规划会将每个求解过的子问题的解记录下来。</p><p>一般可以使用递推或递归的写法来实现动态规划，其中递归写法又称记忆化搜索</p><h3 id="11-1-2-动态规划的递归写法">11.1.2 动态规划的递归写法</h3><p>使用记忆化搜索来计算斐波那契数列</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> dp[maxn];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">F</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(n&lt;=<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(dp[n]) <span class="hljs-keyword">return</span> dp[n]; <span class="hljs-comment">//已经计算过，直接返回结果</span><br>    <span class="hljs-keyword">else</span>&#123;<br>        dp[n]=<span class="hljs-built_in">F</span>(n<span class="hljs-number">-1</span>)+<span class="hljs-built_in">F</span>(n<span class="hljs-number">-2</span>);<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>引出概念：如果一个问题可以被分解成若干子问题，而且这些子问题会重复出现，那么就称这个问题拥有<strong>重叠子问题</strong></p><p>因此一个问题必须有重叠子问题才能用动态规划去解决</p><h3 id="11-1-3-动态规划的递推写法">11.1.3 动态规划的递推写法</h3><blockquote><p><strong>数塔问题</strong></p><p>把一些数字排成数塔的形状，第i层有i个数字，现在要从第一层走到第n层，每次只能走向下一层连接的两个数字中的一个，问：最后将路径上所有数字相加后得到的和最大为多少？</p></blockquote><p>按照题目的描述，使用一个二维数组f去存储存放在第i层的第j个数字，如果尝试去穷举所有路径，那么时间复杂度是$O(2^n)$,无法接受，这是因为会重复访问，解决方法是记录下来一个数字到底层所有路径可以产生的最大值，之后访问这个数的时候直接调用即可。不妨令dp[i][j]表示从第i行第j个数字出发到达底层的所有路径中能得到的最大和，在定义这个数组之后，dp[1][1]就是最终想要的答案，现在我们来求它。</p><p>注意到一个细节，如果要求dp[1][1]，就一定要先求出它的两个子问题dp[2][1]和dp[2][2]，即进行了一次<strong>决策</strong>，是走f[2][1]还是f[2][2]，于是dp[1][1]可以写成这个式子<br>$$<br>\mathrm{dp}[1][1]=max(\mathrm{dp[2][1],dp[2][2]})+\mathrm{f[1][1]}<br>$$<br>由此可以归纳得到这么一个信息：如果要求出d[i][j]，就一定要求出它的两个子问题d[i+1][j]和d[i+1][j+1]，即进行了一次<strong>决策</strong>，于是就有<br>$$<br>\mathrm{dp}[i][j]=max(\mathrm{dp[i+1][j],dp[i+1][j+1]})+\mathrm{f[i][j]}<br>$$<br>把d[i][j]称之为问题的<strong>状态</strong>，上面的式子称之为<strong>状态转移方程</strong>，把各状态转移为d[i+1][j]和d[i+1][j+1]。可以注意到状态d[i][j]只和第i+1层的状态有关，而与其他层的状态无关，这样层号为i的状态总是可以由层号为i+1的两个子状态得到。又注意到递归边界应该是数塔的最后一层的dp值总是等于元素本身，即dp[n][j]==f[n][j]，把这种可以直接确定结果的部分称之为<strong>边界</strong>，而<strong>动态规划的递推写法总是从这种边界出发，又通过状态转移方程扩散到整个dp数组</strong>。</p><p>这样就可以从底层各位置的dp值开始不断向上求，最后就可以得到dp[1][1]，即最后需要的答案。代码实现如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">1000</span>;<br><span class="hljs-type">int</span> n,f[maxn][maxn],dp[maxn][maxn];<br><br><span class="hljs-comment">//状态转移方程的递归实现，调用时从初始状态调用</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">P</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(dp[i][j]) <span class="hljs-keyword">return</span> dp[i][j]; <span class="hljs-comment">//记忆化存储</span><br>    <span class="hljs-keyword">if</span>(i==n) <span class="hljs-keyword">return</span> dp[i][j]=f[i][j];<br>    <span class="hljs-keyword">return</span> dp[i][j]=<span class="hljs-built_in">max</span>(<span class="hljs-built_in">P</span>(i<span class="hljs-number">+1</span>,j),<span class="hljs-built_in">P</span>(i<span class="hljs-number">+1</span>,j<span class="hljs-number">+1</span>))+f[i][j];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=i;j++)&#123;<br>            cin&gt;&gt;f[i][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//边界条件</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        dp[n][i]=f[n][i];<br>    &#125;<br>    <span class="hljs-comment">//从n-1层往上不断计算dp[i][j]</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">1</span>;i--)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=i;j++)&#123;<br>            <span class="hljs-comment">//状态转移方程</span><br>            dp[i][j]=<span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">+1</span>][j],dp[i<span class="hljs-number">+1</span>][j<span class="hljs-number">+1</span>])+f[i][j];<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>用递归也可以实现类似的效果</p><p>使用递归写法的计算方式是<strong>自底而上</strong>，即从边界开始不断向上解决问题，直到解决目标问题</p><p>而使用递归写法是<strong>自顶向下</strong>，从目标问题开始将它分解成子问题的组合，直至分解至边界</p><p>从上面的问题再引申出一个概念：如果一个问题的最优解可以由其子问题的最优解构造而来，那么称这个问题具有<strong>最优子结构</strong>。最优子结构保证了动态规划问题中原问题的最优解可以由子问题的最优解推导而来，因此一个问题必须拥有最优子结构才能用动态规划去解决。</p><p>需要指出，<strong>一个问题必须拥有重叠子问题和最优子结构才能使用动态规划去解决</strong>，指出两个概念的区别</p><ol><li>分治与动态规划。分治分解出的子问题是不重叠的，而动态规划解决的问题拥有重叠子问题。分治法解决的不一定是最优化问题，而动态规划解决的一定是最优化问题。</li><li>贪心与动态规划。都要求原问题有最优子结构。贪心类似于自顶而下，但是并不是等待子问题求解完毕之后再去选择使用哪一个，而是选择一个策略去直接解决一个子问题。而动态规划总是从边界开始得到。</li></ol><h2 id="11-2-最大连续子序列和">11.2 最大连续子序列和</h2><blockquote><p>给定一个数字序列$A_1,A_2, \cdots A_n$，求i,j (1≤i≤j≤n)，使得$A_i+\cdots A_j$最大，输出这个最大和。</p><p>样例</p><p>-2 11 -4 13 -5 -2</p></blockquote><p>如果暴力来做枚举i和j要$\mathrm{O(n^2)}$的复杂度，而计算a[i]+…+a[j]需要O(n)的复杂度，因此总共复杂度为$\mathrm{O(n^3)}$。如果采用前缀和的方法令s[i]=a[0]+a[1]+…+a[i]，这样a[i]+…+a[j]=s[j]-s[i-1]使得计算时间为O(1)，总复杂度还是$\mathrm{O(n^2)}$，无法接受。</p><p>下面介绍动态规划的做法，复杂度为O(n)。</p><ol><li><p>令dp[i]表示以a[i]作为末尾的连续序列的最大和（这里说a[i]必须要作为连续序列的末尾）。</p><p>通过设置这么一个dp数组，那么我们无非就是要求从dp[0]到dp[n-1]中的最大值（因为以哪个元素作为结尾是未知的）。接下来想办法求解dp数组</p></li><li><p>做如下考虑：因为dp[i]必须是以a[i]结尾的连续序列，那么只有两种情况</p><ol><li>这个最大和的连续序列只有一个元素即以a[i]开始又以a[i]结束</li><li>这个最大和的连续序列有多个元素，即从某处p开始(p&lt;i)，一直到a[i]结尾。</li></ol><p>第一种情况最大和就是a[i]本身。</p><p>第二种情况最大和是dp[i-1]+a[i]，即a[p]+…+a[i-1]+a[i]=dp[i-1]=a[i] (<strong>强行把i和i-1的情况拆开，得到状态方程的思路</strong>)</p><p>由于只有这两种情况，得到状态转移方程<br>$$<br>\mathrm{dp[i]}=max (\mathrm{a[i],dp[i-1]+a[i]})<br>$$<br>这个式子只和i与i之前的元素有关，且边界为dp[0]=a[0]，于是枚举i即可解决问题。</p></li></ol><h4 id="无后效性">无后效性</h4><p>状态的无后效性指的是：当前状态记录了历史信息，一旦当前状态确定，就不会再改变，且未来的决策只能在已有的一个或若干个状态的基础上进行，历史信息只能通过已有的状态去影响未来的决策。</p><p>对于动态规划可解的问题来说，总会有很多设计状态的方式，<strong>但并不是所有状态都具有无后效性</strong>，因此必须要设计一个无后效性的状态以及相应的状态转移方程。</p><p><strong>设计状态和状态转移方程是动态规划的核心。</strong></p><h2 id="11-3-最长不下降子序列（LIS）">11.3 最长不下降子序列（LIS）</h2><blockquote><p>在一个数字序列中，找到一个最长的子序列（可以不连续），使得这个序列是不下降的。</p></blockquote><p>暴力法：每个元素有取和不取两种情况，对之进行判断，直到枚举完成，时间复杂度$\mathrm{O(2^n)}$。下面介绍动态规划法。</p><p>令dp[i]表示以a[i]结尾的最长不下降子序列长度（与最大连续子序列和问题一样，以a[i]结尾是强制的要求），这样对于a[i]就有两种可能：</p><ol><li>如果存在a[i]之前的元素a[j] (j&lt;i) 使得a[j]≤a[i]且dp[j]+1&gt;dp[i]（即把a[i]跟在以a[j]结尾的LIS后面时能比当前以a[i]结尾的LIS长度更长），那么就把a[i]跟在以a[j]结尾的LIS后面，形成一条更长的不下降子列（令dp[i]=dp[j]+1）</li><li>如果a[i]之前的元素都比a[i]大，那么a[i]就只能自己形成一条长度为1的LIS</li></ol><p>最后以a[i]结尾的LIS长度就是1,2中能形成的最大长度。</p><p>由此写出状态转移方程<br>$$<br>\mathrm{dp[i]}=max(\mathrm{1,dp[j]+1}) \<br>(j=1,2,\cdots.i-1&amp;&amp;a[j]&lt;a[i]) \<br>边界dp[i]=1（先假设每个元素自成一个子序列）<br>$$<br>一个代码实现的案例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> ans=<span class="hljs-number">-1</span>; <span class="hljs-comment">//记录最大的dp[i]</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    dp[i]=<span class="hljs-number">1</span>; <span class="hljs-comment">//先假设每个元素自成一个子序列</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;i;j++)&#123;<br>        <span class="hljs-keyword">if</span>(a[i]&gt;=a[j]&amp;&amp;(dp[j]<span class="hljs-number">+1</span>&gt;dp[i]))&#123;<br>dp[i]=dp[j]<span class="hljs-number">+1</span>; <span class="hljs-comment">//状态转移方程用以更新dp[i]</span><br>            <span class="hljs-comment">//也可以是dp[i]=max(dp[i],dp[j]+1); 上面那个判断去掉</span><br>        &#125;<br>    &#125;<br>    ans=<span class="hljs-built_in">max</span>(ans,dp[i]);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="11-4-最长公共子序列（LCS）">11.4 最长公共子序列（LCS）</h2><blockquote><p>给定两个字符串（或数字序列）a和b，求一个字符串，使得这个字符串是A和B的最长公共部分的长度（子序列可以不连续）</p><p>样例：</p><p>“sadstory&quot;和&quot;adminsorry&quot;的最长公共子序列是&quot;adsory”，长度为6。</p></blockquote><p>令dp[i][j]表示字符串a的i号位和字符串b的j号位之前的LCS长度（下标从1开始），如dp[4][5]表示&quot;sads&quot;和&quot;admin&quot;的LCS长度。那么可以根据a[i]和b[j]的情况分为两种决策。</p><ol><li>若a[i]==b[j]，则字符串a和字符串b的LCS增加了一位，即有dp[i][j]=dp[i-1][j-1]+1</li><li>如果a[i]!=b[j]，那么字符串a的i号位和字符串b的j号位之前的LCS无法延长，因此dp[i][j]将会继承dp[i-1][j]与dp[i][j-1]中的较大值，即有dp[i][j]=max{dp[i-1][j],dp[i][j-1]} （因为不相同，所以从这一位开始往前倒一位是不影响长度的，但是从哪一个维度倒一位就要分类，也就是取一个max）</li></ol><p>由此得到状态转移方程<br>$$<br>\mathrm{dp[i][j]}=<br>\begin{cases}<br>\mathrm{dp[i-1][j-1]+1,a[i]==b[j]} \<br>max(\mathrm{dp[i-1][j],dp[i][j-1]}), \mathrm{a[i]!=b[j]}<br>\end{cases} \<br>边界：\mathrm{dp[i][0]=dp[j][0]=0} \<br>\mathrm{i和j从1遍历到各自字符串的长度}<br>$$</p><h2 id="11-5-最长回文子串">11.5 最长回文子串</h2><blockquote><p>给出一个字符串s，求s的最长回文子串的长度。</p><p>例：</p><p>“PATZJUJZTACCBCC&quot;的最长回文子串为&quot;ATZJUJZTA”，长度为9</p></blockquote><p>动态规划法，时间复杂度$\mathrm{O(n^2)}$</p><p>令<code>bool dp[i][j]</code>表示s[i]至s[j]所表示的子串是回文子串，这样根据s[i]是否等于s[j]可以把答案分成两类：</p><ol><li>若s[i]==s[j]，则只要s[i+1]至s[j-1]是回文子串，s[i]至s[j]就是回文子串；反之。</li><li>如果s[i]!=s[j]，那么s[i]至s[j]就一定不是回文子串。</li></ol><p>由此可以写出状态转移方程<br>$$<br>\mathrm{dp[i][j]=}<br>\begin{cases}<br>\mathrm{dp[i+1][j-1] ,s[i]==s[j]} \<br>\mathrm{false, s[i]!=s[j]}<br>\end{cases} \<br>\mathrm{边界dp[i][i]=1， dp[i][i+1]=(s[i]==s[i+1]?true:false)}<br>$$<br>但是直接双重循环会无法保证计算过dp[i+1][j-1]，从而无法计算出dp[i+1][j-1]，解决方法如下：</p><p>根据递归写法从边界出发的原理：考虑按子串的长度和子串的初始位置进行枚举，即先枚举子串长度L，再枚举左端点i，这样右端点i+L-1也可以直接得到。</p><h2 id="11-6-DAG最长路">11.6 DAG最长路</h2><h2 id="11-7-背包问题">11.7 背包问题</h2><h3 id="11-7-1-多阶段动态规划问题">11.7.1 多阶段动态规划问题</h3><p>这一类问题的特征是：可以描述成若干个有序的阶段，且每个阶段的状态只和上一个阶段的状态有关。只需从第一个问题开始按照阶段的顺序解决每个阶段中状态的计算，就可以得到最后一个阶段中状态的解。</p><h3 id="11-7-2-01背包问题">11.7.2 01背包问题</h3><blockquote><p>有n件物品，每件物品的重量为w[i]，价值为c[i]。现有一个容量为V的背包，问如何选取物品放入背包使得背包内物品的总价值最大。<strong>每件物品都只有一件。</strong></p></blockquote><p>dfs的方法时间复杂度为$O(2^n)$，显然不行，使用动态规划则为$O(nV)$</p><p>令dp[i][v]表示前i件物品(1≤i≤n,0≤v≤V)<strong>恰好</strong>（“恰好”指的是恰好把容量v填满）装入容量为v的背包所能获得的最大价值</p><p>考虑第i件物品的选择策略，有如下两种：</p><ol><li>不放第i件物品，那么问题转化为dp[i-1][v]</li><li>放第i件物品，那么问题转化为前i-1件物品恰好装入容量为v-w[i]的背包所能获得的最大价值，也即dp[i-1][v-w[i]]+c[i]</li></ol><p>则有<br>$$<br>\mathrm{dp[i][v]}=max{\mathrm{dp[i-1][v],dp[i-1][v-w[i]]+c[i]}} \<br>1≤i≤n,w[i]≤v≤V<br>$$<br>上面就是状态转移方程。又注意到dp[i][v]只与之前的状态dp[i-1][]有关，所以可以枚举i从1到n，v从0到V，通过边界dp[0][v]=0*(0件物品价值当然是0)*就可以把整个dp数组递推出来，而由于dp[i][v]表示的是恰好为v的情况，所以需要枚举dp[n][v]，取其最大值即可。</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v=w[i];v&lt;=V;v++)&#123;<br>        dp[i][v]=<span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][v],dp[i<span class="hljs-number">-1</span>][v-w[i]]+c[i]);<br><br>    &#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v=<span class="hljs-number">1</span>;v&lt;=V;v++)&#123;<br>    ans=<span class="hljs-built_in">max</span>(ans,dp[n][v]);<br>&#125;<br>cout&lt;&lt;ans;<br></code></pre></td></tr></table></figure><p>时间复杂度和空间复杂度均为$O(nV)$，但是空间复杂度还可以继续优化</p><p>注意到每次计算dp[i][v]的时候只需要计算dp[i-1][v]左侧部分的数据（即从0到v的部分的数据），且计算dp[i+1][]的时候，dp[i-1][]部分的数据又没用了。所以开一个一维数组dp[v]，枚举方向i从1到n，v从V到0（<strong>逆序！</strong>），状态转移方程变为<br>$$<br>\mathrm{dp[v]}=max{\mathrm{dp[v],dp[v-w[i]]+c[i]}} \<br>1≤i≤n,w[i]≤v≤V<br>$$<br>相当于每次计算出dp[i][v]的时候，就覆盖掉dp[i-1][v]，以节省空间</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v=V;v&gt;=w[i];v--)&#123;<br>        dp[v]=<span class="hljs-built_in">max</span>(dp[v],dp[v-w[i]+c[i]]);<br>    &#125;<br>&#125;<br>cout&lt;&lt;dp[V];<br></code></pre></td></tr></table></figure><p>记得用一维数组存放时，v的枚举必须是逆序！</p><p>对于能够划分阶段的问题来说，都可以尝试把阶段作为状态的一维，这样使得我们更方便地得到满足无后效性的状态。如果当前设计的状态不满足无后效性，不妨把状态进行升维，增加一维或者若干维来表示相应的信息。</p><h3 id="11-7-3-完全背包问题">11.7.3 完全背包问题</h3><blockquote><p>有n种物品，每件物品的重量为w[i]，价值为c[i]。现有一个容量为V的背包，问如何选取物品放入背包使得背包内物品的总价值最大。<strong>每件物品都有无穷件。</strong></p></blockquote><p>同样令dp[i][v]表示前i件物品(1≤i≤n,0≤v≤V)<strong>恰好</strong>（“恰好”指的是恰好把容量v填满）装入容量为v的背包所能获得的最大价值</p><p>对于第i件物品来说</p><ol><li>不放第i件物品则有dp[i][v]=dp[i-1][v]</li><li>放第i件物品转移到dp[i][v-w[i]]+c[i]这个状态，这是因为每件物品可以放任意件，放了第i件物品之后还可以放第i件物品</li></ol><p>状态转移方程为<br>$$<br>\mathrm{dp[i][v]}=max{\mathrm{dp[i-1][v],dp[i][v-w[i]]+c[i]}} \<br>1≤i≤n,w[i]≤v≤V \<br>边界\ d[0][v]=0<br>$$<br>也可以改写成一维模式<br>$$<br>\mathrm{dp[v]}=max{\mathrm{dp[v],dp[v-w[i]]+c[i]}} \<br>1≤i≤n,w[i]≤v≤V \<br>边界\ d[v]=0<br>$$<br>这就和01背包问题完全一致了，唯一的区别在于这里的v必须是<strong>正向枚举</strong></p><p>因为dp[i][v]可以直接覆盖dp[i-1][v]</p><h2 id="11-8-总结">11.8 总结</h2><p>总结过的模型列举如下：</p><ol><li><p>最大连续子序列和</p><p>令dp[i]表示以a[i]作为结尾的连续序列的最大和。</p></li><li><p>最长不下降子序列(LIS)</p><p>令dp[i]表示以a[i]结尾的最长不下降子序列长度</p></li><li><p>最长公共子序列(LCS)</p><p>令dp[i][j]表示字符串a的i号位和字符串b的j号位之前的LCS长度</p></li><li><p>最长回文子串</p><p>令bool dp[i][j]表示s[i]至s[j]所表示的子串是否是回文子串</p></li><li><p>数塔DP</p><p>令dp[i][j]表示从第i行第j个数字出发的到达最底层的所有路径上所能得到的最大和</p></li><li><p>DAG最长路</p><p>令dp[i]表示从i号顶点出发能获得的最长路径长度</p></li><li><p>01背包</p><p>令dp[i][v]表示前i件物品恰好装入容量为v的背包所能获得的最大价值</p></li><li><p>完全背包</p><p>令dp[i][v]表示前i件物品恰好装入容量为v的背包所能获得的最大价值</p></li></ol><p><strong>特别说明：一般来说“子序列”可以不连续，“子串”必须连续。</strong></p><p>当题目与序列或字符串(记作a)有关时，可以考虑把状态设计成下面两种形式，然后根据端点特点去考虑状态转移方程。</p><ol><li>令dp[i]表示以a[i]结尾（或开头）的xxx</li><li>令dp[i][j]表示a[i]至a[j]区间的xxx</li></ol><p>其中xxx均为原问题的表述。</p><p>当题目中的问题设计几个维度时候，分析题目中的状态需要几维来表示，然后对其中的每一维采取下面的某一个表述：</p><ol><li>恰好为i</li><li>前i</li></ol><p>在每一维的的含义设置完毕之后，dp数组的含义就可以设置成**“令dp数组表示恰好为i（或前i）、恰好为j（或前j）…的XXX”**，其中xxx为原问题的表述，接下来通过端点的特点去考虑状态转移方程。</p>]]></content>
    
    
    <categories>
      
      <category>程设</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>洛谷P5076 【深基16.例7】普通二叉树（简化版） 题解</title>
    <link href="/2025/03/02/2025-03-02-%E6%B4%9B%E8%B0%B7P5076-%E3%80%90%E6%B7%B1%E5%9F%BA16.%E4%BE%8B7%E3%80%91%E6%99%AE%E9%80%9A%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E7%AE%80%E5%8C%96%E7%89%88%EF%BC%89-%E9%A2%98%E8%A7%A3/"/>
    <url>/2025/03/02/2025-03-02-%E6%B4%9B%E8%B0%B7P5076-%E3%80%90%E6%B7%B1%E5%9F%BA16.%E4%BE%8B7%E3%80%91%E6%99%AE%E9%80%9A%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E7%AE%80%E5%8C%96%E7%89%88%EF%BC%89-%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<blockquote><h1>P5076 【深基16.例7】普通二叉树（简化版）</h1><h2 id="题目描述">题目描述</h2><p>您需要写一种数据结构，来维护一些数（都是绝对值 $10^9$ 以内的数）的集合，最开始时集合是空的。其中需要提供以下操作，操作次数 $q$ 不超过 $10^4$：</p><ol><li>定义数 $x$ 的排名为集合中小于 $x$ 的数的个数 $+1$。查询数 $x$ 的排名。<strong>注意 $x$ 不一定在集合里</strong>。</li><li>查询排名为 $x(x\ge 1)$ 的数。<strong>保证集合里至少有 $x$ 个数</strong>。</li><li>求 $x$ 的前驱（前驱定义为小于 $x$，且最大的数）。若不存在则输出 $-2147483647$。</li><li>求 $x$ 的后继（后继定义为大于 $x$，且最小的数）。若不存在则输出 $2147483647$。</li><li>插入一个数 $x$，本题的数据保证插入前 $x$ 不在集合中。</li></ol><p>保证执行 $1,3,4$ 操作时，集合中有至少一个元素。</p><h2 id="输入格式">输入格式</h2><p>第一行是一个整数 $q$，表示操作次数。</p><p>接下来 $q$ 行，每行两个整数 $op,x$，分别表示操作序号以及操作的参数 $x$。</p><h2 id="输出格式">输出格式</h2><p>输出有若干行。对于操作 $1,2,3,4$，输出一个整数，表示该操作的结果。</p><h2 id="输入输出样例-1">输入输出样例 #1</h2><h3 id="输入-1">输入 #1</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">7</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">1</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h3 id="输出-1">输出 #1</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">2<br>3<br>1<br>5<br></code></pre></td></tr></table></figure></blockquote><h1>题解</h1><h2 id="方法1">方法1</h2><p>使用BST</p><p>一个实现如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">using</span> i64=<span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> u64=<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> u32=<span class="hljs-type">unsigned</span>;<br><span class="hljs-keyword">using</span> u128=<span class="hljs-type">unsigned</span> __int128;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf=<span class="hljs-number">2147483647</span>;<br><br><span class="hljs-comment">//需要实现：按照排名找权值，按照权值找排名，找前驱，找后继，插入</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>    <span class="hljs-type">int</span> v;<br>    <span class="hljs-type">int</span> lchild=<span class="hljs-number">0</span>,rchild=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> siz; <span class="hljs-comment">//(两子树+自己本身)的大小（结点数之和）</span><br>&#125;bst[<span class="hljs-number">100010</span>]; <span class="hljs-comment">//以1为根结点</span><br><br><span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>; <span class="hljs-comment">//表示总结点数目</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> idx)</span></span>&#123; <span class="hljs-comment">//v表示权值，idx表示当前的结点编号</span><br>    bst[idx].siz++;<br>    <span class="hljs-keyword">if</span>(v&gt;bst[idx].v)&#123; <span class="hljs-comment">//说明v应该插入到右子树</span><br>        <span class="hljs-keyword">if</span>(bst[idx].rchild!=<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-built_in">insert</span>(v,bst[idx].rchild);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123; <span class="hljs-comment">//不存在右孩子</span><br>            cnt++;<br>            bst[cnt].v=v;<br>            bst[cnt].siz=<span class="hljs-number">1</span>;<br>            bst[idx].rchild=cnt;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">if</span>(bst[idx].lchild!=<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-built_in">insert</span>(v,bst[idx].lchild);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            cnt++;<br>            bst[cnt].v=v;<br>            bst[cnt].siz=<span class="hljs-number">1</span>;<br>            bst[idx].lchild=cnt;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findPre</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span></span>&#123;<br>    <span class="hljs-type">int</span> idx=<span class="hljs-number">1</span>; <span class="hljs-comment">//从根结点开始搜索</span><br>    <span class="hljs-type">int</span> ans=-inf;<br>    <span class="hljs-keyword">while</span>(idx)&#123;<br>        <span class="hljs-keyword">if</span>(bst[idx].v&lt;v)&#123;<br>            ans=bst[idx].v;<br>            idx=bst[idx].rchild;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            idx=bst[idx].lchild;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findPost</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span></span>&#123;<br>    <span class="hljs-type">int</span> idx=<span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> ans=inf;<br>    <span class="hljs-keyword">while</span>(idx)&#123;<br>        <span class="hljs-keyword">if</span>(bst[idx].v&gt;v)&#123;<br>            ans=bst[idx].v;<br>            idx=bst[idx].lchild;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            idx=bst[idx].rchild;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fromRankfindV</span><span class="hljs-params">(<span class="hljs-type">int</span> rk,<span class="hljs-type">int</span> idx)</span></span>&#123; <span class="hljs-comment">//idx是当前遍历到的根结点</span><br>    <span class="hljs-type">int</span> leftSize=bst[bst[idx].lchild].siz;<br>    <span class="hljs-keyword">if</span>(rk&lt;=leftSize)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">fromRankfindV</span>(rk,bst[idx].lchild);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(rk==leftSize<span class="hljs-number">+1</span>)&#123;<br>        <span class="hljs-keyword">return</span> bst[idx].v;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">fromRankfindV</span>(rk-leftSize<span class="hljs-number">-1</span>,bst[idx].rchild);<br>    &#125;<br>    <br>&#125;<br><br><span class="hljs-comment">//标准做法</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fromVfindRank</span><span class="hljs-params">(<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> idx)</span></span>&#123; <span class="hljs-comment">//最后返回值还需要再+1</span><br>    <span class="hljs-keyword">if</span>(idx==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(v&lt;=bst[idx].v)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">fromVfindRank</span>(v,bst[idx].lchild);<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> bst[bst[idx].lchild].siz<span class="hljs-number">+1</span>+<span class="hljs-built_in">fromVfindRank</span>(v,bst[idx].rchild);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-type">int</span> q;<br>    cin&gt;&gt;q;<br><br>    <span class="hljs-keyword">while</span>(q--)&#123;<br>        <span class="hljs-type">int</span> op;<br>        <span class="hljs-type">int</span> x;<br>        cin&gt;&gt;op&gt;&gt;x;<br>        <span class="hljs-keyword">if</span>(op==<span class="hljs-number">1</span>)&#123;<br>            cout&lt;&lt;<span class="hljs-built_in">fromVfindRank</span>(x,<span class="hljs-number">1</span>)<span class="hljs-number">+1</span>&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op==<span class="hljs-number">2</span>)&#123;<br>            cout&lt;&lt;<span class="hljs-built_in">fromRankfindV</span>(x,<span class="hljs-number">1</span>)&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op==<span class="hljs-number">3</span>)&#123;<br>            cout&lt;&lt;<span class="hljs-built_in">findPre</span>(x)&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op==<span class="hljs-number">4</span>)&#123;<br>            cout&lt;&lt;<span class="hljs-built_in">findPost</span>(x)&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op==<span class="hljs-number">5</span>)&#123;<br>            <span class="hljs-keyword">if</span>(cnt==<span class="hljs-number">0</span>)&#123;<br>                cnt=<span class="hljs-number">1</span>;<br>                bst[<span class="hljs-number">1</span>].v=x;<br>                bst[<span class="hljs-number">1</span>].siz=<span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-built_in">insert</span>(x,<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是找前驱和找后继的函数可以省略，因为可以先查询x的排名rank，然后查询排名为rank-1和rank+1的数，就分别是前驱和后继了。</p><p>如果rank+1&gt;cnt或者rank-1&lt;1，那么就可以分别输入inf和-inf</p><h2 id="方法2">方法2</h2><p>使用STL容器multiset</p><blockquote><h2 id="multiset的常见用法详解">multiset的常见用法详解</h2><h3 id="multiset的定义">multiset的定义</h3><p><code>multiset</code> 是一个集合容器，它可以存储多个相同的元素。换句话说，如果你有一堆重复的数，比如 3、5、5、5、7，你可以用<code>multiset</code>来妥善管理它们。与<code>set</code>不同的是，<code>set</code>不会允许重复的元素，而<code>multiset</code>非常欢迎重复元素的加入。</p><p>可以使用统一初始化的元素来创建</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    multiset&lt;<span class="hljs-type">int</span>&gt; numbers = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">9</span>&#125;;<br><br>    <span class="hljs-comment">// 基于范围的for循环遍历multiset</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : numbers) &#123;<br>        cout &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意，<code>multiset</code>会自动按升序排列元素。</strong></p><p><strong>如果是自定义类型，需要重载小于号</strong></p><h3 id="multiset内元素的访问">multiset内元素的访问</h3><p>使用迭代器</p><h3 id="multiset常用函数实例解析">multiset常用函数实例解析</h3><h4 id="insert">insert()</h4><p>略了</p><h4 id="erase">erase()</h4><p><code>erase</code>方法用来删除元素。但是要注意！如果你直接传入一个值，所有与这个值相同的元素都会被删除。如果你只想删除一个特定的元素，最好先找到它的迭代器，然后用这个迭代器来删除。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    multiset&lt;<span class="hljs-type">int</span>&gt; numbers = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>&#125;;<br><br>    <span class="hljs-comment">// 删除所有的5</span><br>    numbers.<span class="hljs-built_in">erase</span>(<span class="hljs-number">5</span>);<br><br>    <span class="hljs-comment">// 打印当前的multiset</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : numbers) &#123;<br>        cout &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果只想删除第一个5</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> it = numbers.<span class="hljs-built_in">find</span>(<span class="hljs-number">5</span>);  <span class="hljs-comment">// 找到第一个5</span><br><span class="hljs-keyword">if</span> (it != numbers.<span class="hljs-built_in">end</span>()) &#123;<br>    numbers.<span class="hljs-built_in">erase</span>(it);  <span class="hljs-comment">// 只删除找到的第一个5</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="size">size()</h4><p>略了</p><h4 id="clear">clear()</h4><p>略了</p><h4 id="empty">empty()</h4><p>略</p><h4 id="lower-bound">lower_bound()</h4><p>略 <strong>和algorithm</strong>中的不一样</p><h4 id="upper-bound">upper_bound()</h4><p>略 <strong>和algorithm</strong>中的不一样</p></blockquote><h3 id="分析题目">分析题目</h3><h4 id="1-查询-x-数的排名">1. 查询 x 数的排名</h4><p>排名，说白了就是排序之后的x的下标。</p><p>我们只要用lower_bound方法，找到第一个x的位置。</p><p>然后从begin开始往后遍历容器，只要达到这个位置，就输出当前下标即可。</p><h4 id="2-查询排名为-x-的数">2.查询排名为 x 的数</h4><p>遍历容器，只要当前排名到达x，就输出当前值。</p><p>（因为multiset容器无法进行随机访问）</p><h4 id="3-求-x-的前驱（前驱定义为小于-x，且最大的数）">3.求 x 的前驱（前驱定义为小于 x，且最大的数）</h4><p>前驱，也就是x的前一个。</p><p>我们只要用lower_bound方法找到第一个x的位置，然后输出上一个就OK了。</p><h4 id="4-求-x-的后继（后继定义为大于-x，且最小的数）。">4.求 x 的后继（后继定义为大于 x，且最小的数）。</h4><p>后继，也就是第一个大于x的数。</p><p>我们可以用upper_bound方法，直接找到这个值。</p><h4 id="5-插入一个数-x">5.插入一个数 x</h4><p>直接用insert方法插入即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>multiset&lt;<span class="hljs-type">int</span>&gt;q;<br><span class="hljs-type">int</span> n,t,x,order;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    q.<span class="hljs-built_in">insert</span>(<span class="hljs-number">-0x7fffffff</span>);<br>    q.<span class="hljs-built_in">insert</span>(<span class="hljs-number">0x7fffffff</span>);<br>    <span class="hljs-comment">//提前放入这两个数，避免错误</span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">while</span>(n--)<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;t,&amp;x);<br>        <span class="hljs-keyword">if</span>(t==<span class="hljs-number">1</span>)<br>        &#123;<br>            <span class="hljs-keyword">auto</span> it=q.<span class="hljs-built_in">lower_bound</span>(x);<br>            <span class="hljs-comment">//可以写作multiset&lt;int&gt;::iterator，因为lower_bound方法返回的是迭代器</span><br>            <span class="hljs-comment">// it 取得 x 的位置</span><br>            <br>            order=<span class="hljs-number">0</span>;<br>            <span class="hljs-comment">//order为排名</span><br>            <br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i=q.<span class="hljs-built_in">begin</span>();i!=it;i++,order++);<br>            <span class="hljs-comment">//这里就处理出了x的排名——order</span><br>            <br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,order);<br>            <span class="hljs-comment">//输出order即为答案</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t==<span class="hljs-number">2</span>)<br>        &#123;<br>            order=<span class="hljs-number">-1</span>;<br>            <span class="hljs-comment">//初值为-1是因为前面有一个-0x7fffffff，所以order要多跑一步</span><br><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i:q)<br>                <span class="hljs-keyword">if</span>(++order==x)<br>                <span class="hljs-comment">//缩写，order先自增一，再判断是否与x相等</span><br>                <span class="hljs-comment">//如果是(order++==x)，那就是先判断再自增，这里要尤其注意</span><br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,i);<br>                <span class="hljs-comment">//i就是容器里的值，输出i</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t==<span class="hljs-number">3</span>)<br>        &#123;<br>            <span class="hljs-keyword">auto</span> it=q.<span class="hljs-built_in">lower_bound</span>(x);<br>            <span class="hljs-comment">//取得第一个大于等于x的值</span><br>            <span class="hljs-comment">//也就是第一个x的位置</span><br>            <span class="hljs-comment">//由于我们要取得前驱，所以it要自减一</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,*--it);<br>            <span class="hljs-comment">//这句是先自减，再输出，是缩写</span><br>            <span class="hljs-comment">//等价于：</span><br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">                it--;</span><br><span class="hljs-comment">                printf(&quot;%d\n&quot;,*it);</span><br><span class="hljs-comment">            */</span><br>            <span class="hljs-comment">//因为是迭代器（指针），所以输出前面加 *</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t==<span class="hljs-number">4</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,*q.<span class="hljs-built_in">upper_bound</span>(x));<br>            <span class="hljs-comment">//要取得后继，就是第一个大于x的值</span><br>            <span class="hljs-comment">//用upper_bound方法取得第一个大于x的迭代器</span><br>            <span class="hljs-comment">//输出即可</span><br>            <span class="hljs-comment">//因为是迭代器（指针），所以输出前面加 *</span><br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            q.<span class="hljs-built_in">insert</span>(x);<br>            <span class="hljs-comment">//直接添加即可</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>程设</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>算法</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mlf德语 2.28日笔记</title>
    <link href="/2025/02/28/2.28/"/>
    <url>/2025/02/28/2.28/</url>
    
    <content type="html"><![CDATA[<p>A2 §Lektion 19 Text C</p><p>-jährig  多少岁的 alltäglich  日常的 ganztags  全天 also 就是说，于是</p><p>eine Dreizimmerwohnung mit ungefähr（大约） 18 Quadratmeter pro Zimmer</p><p>ein Paar Fragen stellen</p><p>der Lebenslauf -^e  履历，简历</p><p>die Angabe  陈述 angeben  陈述，标出</p><p>der Haushalt --e  家务，一家（户）im Haushalt  在家庭中</p><p>Angst haben  担忧Sauber machen  打扫干净</p><blockquote><p>“<strong>verwöhnen</strong>. Das heißt ihre Schwiegereltern alles für ihre Tochter machen,ihre Tochter hat keine <strong>Pflichten（义务，职责）</strong>, sie kann machen, was sie will, und die Großeltern machen, was ihre Enkelin möchte.”</p><p>…“Dadurch konnten wir beide nicht voll arbeiten, und unser <strong>Gehalt（薪水）</strong> war ziemlich niedrig. Heute können wir voll arbeiten und gut verdienen.”</p></blockquote><blockquote><p>Leben viel Familien so wie sie?  许多家庭都像她一样生活吗？</p></blockquote><blockquote><p>“Ich glaube,heute leben nur noch wenige Menschen so. <u><strong>Tendenz geht dahin (趋势是)</strong></u> , dass <strong><u>immer</u> (越来越) mehr</strong> junge Ehepaare alleine leben wollen.”</p><p>“Ich danke Ihnen für das Gespräch, auf wiedersehen.”</p><p>“<u>Gern geschehen.</u>  不客气。” ……</p></blockquote><p>口语常见回答：问来到德国的好处？</p><p>berühren  接触</p><h6 id="Man-kann-neues-Land-neue-Freunde-und-neue-Kultur-kennenlernen-beruhren">&quot;Man kann neues Land, neue Freunde und neue Kultur kennenlernen/berühren. &quot;</h6><p>etw. auffrischen  温习</p><h6 id="mein-Englisch-auf-frischen-konnen">mein Englisch auf/frischen können</h6><p>der Studiengang -^e  大学课程</p><p>Studiengang wechseln  转专业</p><blockquote><p>Ich habe gehört, dass er seinen Studiengang wechseln möchte.</p><p>Ich habe in der Zeitung gelesen, dass …</p><p>Ich möchte gerne wissen, wie spät <u>es ist</u>?</p><p>Ich wollte fragen, …</p><p>Entschuldigung. Könnten Sie mir sagen, …</p></blockquote><p>die Form --en = der Typ --en  种类</p><p>die Rolle = der Charakter --e = die Eigenschaft --en  角色，个性，特点</p><blockquote><h6 id="Vielleicht-spezialisieren-sie-u-sich-u-wie-die-Tiere-miteinander-kommunizieren-konnen">Vielleicht spezialisieren sie <u>sich</u>, wie die Tiere miteinander kommunizieren können.</h6></blockquote><p>die Maske = der Mundschutz --e  口罩</p><p>unter anderem (u.a.) = außerdem = zusätzlich = darüber hinaus = extra  此外</p><p>die Stufe =der Rang -^e  等级，阶梯</p><blockquote><p>“Ich habe dich lieb.”  对你有好感</p></blockquote><h5 id="Es-lohnt-sich-…-zu-…-值得">Es lohnt sich, … zu …  值得</h5><p>§Lektion 19 Text D</p><blockquote><p>Die traditionelle chinesische Oper hat viele verschiedene Formen. <strong><u>Es gibt</u></strong> eine Sichuan-Oper, eine Huai-Oper, eine Shaoxing-Oper, eine Kun-Oper. <strong><u>Am bekanntesten aber ist</u></strong> die Peking-Oper. Sie ist <strong>in der mittler<u>en</u></strong> Qing-Zeit, <strong>nämlich</strong> im 18. <strong>Jahrhundert</strong> entstanden, und <strong>zwar</strong> in Anhui.</p><p>（中国传统戏曲形式多样。有川剧、淮剧、绍剧和昆剧。但最著名的还是京剧。京剧产生于清朝<strong>中期</strong>，<strong>即</strong> 18 <strong>世纪</strong>的安徽。）</p><p>In der Peking-Oper gibt es vier Charaktere oder Rollen: “Sheng” - die männliche <strong>Hauptrolle</strong>, “Dan” - die weibliche Rolle, “Jing” - die kriegerische (有关战斗的) Rolle und “Chou” - die <strong>lustige</strong> Rolle, ein chinesischer Clown. Die Schauspieler <strong><u>spezialisieren</u></strong> sich <strong>jeweils</strong> <strong><u>auf</u></strong> <u><strong>eine dieser vier</strong></u> Rollen, <u>d.h. (das heißt)</u> ein Sheng-Schauspieler spielt niemals eine Jing-Rolle, oder ein Jing-Schauspieler eine Chou-Rolle. Bis 1949 waren in der Peking-Oper fast alle Schauspieler Männer, d.h. auch die Frauenrollen spielten Männer. Der berühmteste männliche Frauen<strong>darsteller</strong> war Mei Lanfang.</p><p>（京剧中有四个角色：“生”–男<strong>主角</strong>，“旦”–女主角，“净”–武生，“丑”–<strong>滑稽</strong>角色，即中国丑角。演员<strong>各自</strong><u><strong>擅长</strong></u>这**<u>四个角色中的一个</u><strong>，即 “生 ”演员从不扮演 “净 ”角色，“净 ”演员也不扮演 “丑 ”角色。1949 年之前，京剧演员几乎都是男性，即旦角也由男性扮演。最有名的男旦</strong>演员**是梅兰芳。）</p><p><u><strong>Das Besondere an</strong></u> der Peking-Oper <u><strong>ist</strong></u> ihre Symbolik. Die <strong>Bewegungen</strong> in der Peking-Oper sind eine komplizierte Symbolsprache, d.h. die Bewegungen der Schauspieler sind nicht <strong>realistisch</strong>. Typisch für die Peking-Oper ist auch die <strong>Akrobatik</strong>. Die Schauspieler tragen <strong>kunstvolle</strong> Kostüme und Masken. Auch die Kostüme und Masken haben symbolische Bedeutung. So zeigen die Farben der Kleider <u><strong>unter anderem（其中包括）</strong></u> den sozialen <strong>Rang</strong> der Person, die Farben der Maske ihren Charakter. Meistens stehen auf der <strong>Bühne</strong> nur ein Tisch und zwei Stühle. Das Bühnenbild und die <strong>sogenannt</strong>en <strong>Requisiten</strong> können symbolische Bedeutung haben. So kann ein Stuhl nicht ein Stuhl, sondern ein Berg oder ein <strong>Gefängnis</strong> sein. Und wenn der Schauspieler auf den Tisch <strong>steigt</strong>, bedeutet das, dass man ihn nun nicht mehr sehen kann.</p><p>（京剧**<u>的特殊之处在于</u><strong>它的象征性。京剧的</strong>动作<strong>是一种复杂的符号语言，即演员的动作不是</strong>写实的**。<strong>杂技</strong>也是京剧的典型特征。演员穿着<strong>精致的</strong>戏服，戴着面具。服装和面具也具有象征意义。例如，服装的颜色代表了人物的社会<strong>地位</strong>，面具的颜色代表了人物的性格。<strong>舞台</strong>上通常只有一张桌子和两把椅子。舞台布景和<strong>所谓的道具</strong>可能具有象征意义。例如，一把椅子可能不是一把椅子，而是一座山或一座<strong>监狱</strong>。如果演员<strong>爬</strong>到桌子上，就意味着不能再看到他。）</p><p>Die <strong>Zuschauer</strong> kennen den Inhalt der Opern, und die meisten haben die gleiche Oper schon viele Male gesehen. Peking-Oper-Fans interessieren sich <u><strong>nicht für</strong></u> den Inhalt des <strong>Stück</strong>s, <u><strong>sondern</strong></u> dafür, wie die Schauspieler das Stück spielen und singen. Die Atmosphäre bei Peking-Oper-<strong>Vorführungen</strong> ist sehr <strong>zwanglos</strong>. Die Zuschauer essen während der Vorführung <strong>Sonnenblumenkerne</strong> und unterhalten sich mit dem Nachbarn, und wenn ihnen eine <strong>Darbietung</strong> besonders gut gefällt, rufen sie “Hao!”. Allerdings sind diese begeisterten Peking-Oper-<strong>Besucher</strong> heute <u><strong>zum größten Teil</strong></u> ältere Menschen. <strong><u>Unter</u></strong> den jungen Chinesen ist die Peking-Oper nicht mehr beliebt.</p><p>（<strong>观众</strong>对戏曲内容了如指掌，同一部戏，他们大多看过很多遍。京剧迷们感兴趣的不是<strong>戏</strong>的内容，而是演员如何扮演和演唱。京剧<strong>演出</strong>的气氛非常<strong>随意</strong>。观众会在演出过程中吃<strong>葵花籽</strong>，与周围的人聊天，如果他们特别喜欢某场<strong>演出</strong>，就会大喊一声 “好！”。不过，如今这些热情的京剧<strong>观众</strong><u><strong>大多是</strong></u>老年人。京剧在中国年轻人中已不再流行。）</p></blockquote><p>jm. Bescheid sagen  告知某人</p><p>sich konzentrieren auf  集中注意力于</p><h6 id="…-der-immer-auf-“Deepseek”-konzentriert">… , der immer auf “Deepseek” konzentriert</h6><p>starke Kopfscherzen haben</p><p>an jm. denken  对谁念念不忘</p><p>bei jm. sein</p><h6 id="Warst-du-gestern-beim-arzt">Warst du gestern beim arzt?</h6><p>sich die Wörter merken  熟记单词</p><p>§课堂练习</p><h5 id="Personen-unterscheiden">Personen unterscheiden</h5><h6 id="Sie-machen-seit-zwei-Wochen-Urlaub-im-Hotel-Schonblick-im-1-Schwarzwald-Uber-einige-der-anderen-Urlauber-u-wissen-u-Sie-schon-recht-gut-u-Bescheid-u-uber-einige-wissen-Sie-nichts-nur-den-Namen-Sie-unterhalten-sich-mit-Ihrem-Partner-Ihrer-Partnerin-uber-die-anderen-Urlauber">Sie machen seit zwei Wochen Urlaub im Hotel &quot;Schönblick &quot; im 1 Schwarzwald. Über einige der anderen Urlauber <u>wissen</u> Sie schon recht gut <u>Bescheid</u>, über einige wissen Sie nichts, nur den Namen. Sie unterhalten sich mit Ihrem Partner/Ihrer Partnerin über die anderen Urlauber:</h6><blockquote><p>Frau Donner ist die junge Frau von Zimmer 51, mit der niemand reden will.</p><p>Ach, Frau Biedermann! Das ist die Frau aus Hamburg, deren Tochter jeden Abend in die Disko geht!!!</p><p>Herr Salzburg ist der Hippie（嬉皮士）, den wir gestern in der Sauna（桑拿浴） getroffen haben.</p><p>Frau Scheuermann ist die hysterische（歇斯底里） Frau aus Lübeck, die wir in der Bar gesehen haben.</p><p>Herr Sanders ist der Fabrikant（工厂主） aus Gelsenkirchen, dessen Sekretärin täglich anruft.</p><p>Frau Lüders ist die Frau von Zimmer 91, über die man nichts sagen kann.</p><p>Frau Brendels ist die junge Frau aus Paderborn, deren Mann <u><strong>vor kurzem（最近）</strong></u> gestorben ist.</p><p>Herr Rabe, ach, das ist der unfreundliche Herr von Zimmer 137, der auch im Urlaub arbeitet.</p><p>Herr Blankenese ist der freundliche Herr von Zimmer 23, mit dem ich beim Skifahren war.</p><p>Herr Überfeld ist ein Baseball-spieler, mit dem nur über Sport reden kann.</p></blockquote><p>etwas (+A) veranstalten 举办die Veranstaltung 举办，聚会</p><p>Seminar (n. --e 研讨会) ist eine Lehrverstaltung.</p><h5 id="Relativsatze-bauen">Relativsatze bauen</h5><h6 id="Die-Berlinale-ein-internationales-Filmfestival">Die Berlinale - ein internationales Filmfestival</h6><h6 id="Lesen-Sie-die-Satzanfange-und-finden-Sie-den-passenden-Relativsatz">Lesen Sie die Satzanfange und finden Sie den passenden Relativsatz.</h6><blockquote><ol><li>Die Berlinale ist ein internationales Filmfestival, das jedes Jahr im Februar in Berlin stattfindet.</li><li>„Rebecca“ von Alfred Hitchcock war der erste Film, den man 1951 auf der Berlinale sehen konnte.</li><li>Seit der ersten Berlinale gibt es einen populären Preis, der „Goldener Bär“ heißt.</li><li>Für das Festival arbeitet eine Jury, in der international bekannte Schauspieler und <strong>Regisseur</strong>e**（导演）**sitzen.</li><li>Es gibt ein <strong>Programmheft（节目单）</strong>, in dem man Informationen <strong><u>zu</u></strong> den Filmen lesen kann.</li><li>Das **Wettbewerbsprogramm（比赛日程）**zeigt neue Filme, die man in den letzten 12 Monaten vor Beginn des Festivals produziert hat.</li><li>Viele Fans warten <u>vor</u> den Festivalkinos <strong><u>auf</u></strong> die Filmstars, mit denen sie gern gemeinsam <u>auf einem Foto sein（入镜）</u> wollen.</li><li>Sehr beliebt ist der <strong>Programmpunkt（节目段）</strong> „Außereuropäischer Film“, der Filme z.B. aus Afrika, Lateinamerika und Asien zeigt.</li></ol></blockquote>]]></content>
    
    
    <categories>
      
      <category>德语</category>
      
    </categories>
    
    
    <tags>
      
      <tag>德语</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mlf德语 2.27日笔记</title>
    <link href="/2025/02/27/2.27/"/>
    <url>/2025/02/27/2.27/</url>
    
    <content type="html"><![CDATA[<p>Ich freue mich sehr.<br>Es ist Zeit … zu …</p><blockquote><p>Die Schlange schlingt sich um ihr Opfer.</p></blockquote><p>蛇缠住它的捕获物。</p><blockquote><p>[!IMPORTANT]</p><h5 id="etw-erscheinen-jm-adj-某人感到某物如何">etw. erscheinen jm. adj.  某人感到某物如何</h5><h5 id="某物衬得某人如何">某物衬得某人如何</h5><h6 id="vor-mit-Dativ-erscheinen-jm-adj">vor/mit + Dativ + erscheinen + jm. + adj.</h6><h6 id="durch-Akkusativ-wirken-u-auf-jn-u-im-Vergleich-adj">durch + Akkusativ + wirken + <u>auf jn.</u> +(im Vergleich)+ adj.</h6><h6 id="mit-in-Dativ-wirken-jm-vergleichsweise-adj">mit/in + Dativ + wirken + jm. +(vergleichsweise)+ adj.</h6><h6 id="in-Dativ-wirken-u-auf-jn-u-adj">in + Dativ + wirken +<u>auf jn.</u> + adj.</h6></blockquote><blockquote><p>Vor diesem prächtigen Palast erscheint er sehr bescheiden.</p></blockquote><p>（在这座宏伟的宫殿前，他显得很谦逊。）</p><blockquote><p>Durch ihre elegante Kleidung wirkt sie auf die Gäste sehr stilvoll.</p></blockquote><p>（通过她优雅的服装，她在客人眼中显得很有格调。）</p><blockquote><p>In dieser schwierigen Situation wirkt er auf seine Familie sehr stark.</p></blockquote><p>（在这种困难的局面下，他对他的家人显得很坚强。）</p><p>der Stil --e 风格</p><p>Ich bin erschöpft.</p><h5 id="etw-fasziniert-jm">etw. fasziniert  jm.</h5><p>Das beeindruckt mich sehr.</p><blockquote><p>[!NOTE]</p><h5 id="die-Bucherei">die Bücherei</h5><ul><li>侧重于指“公共图书馆”“<strong>社区</strong>图书馆”</li></ul><h5 id="die-Bibliothek">die Bibliothek</h5><ul><li>使用范围更广，包括大学图书馆、国家图书馆等，强调其作为知识收藏和<strong>研究中心</strong>的性质。</li></ul><h5 id="die-Buchhandlung">die Buchhandlung</h5><ul><li>指“书店”，是专门用于<strong>销售</strong>书籍、杂志、报纸等出版物的商业场所。</li></ul></blockquote><blockquote><p>[!NOTE]</p><h5 id="der-Sportplatz">der Sportplatz</h5><ul><li>通常指“运动场”“体育场（一般指<strong>户外</strong>综合性运动场地）”。它主要用于各种户外体育项目，比如田径、足球、橄榄球等。</li></ul><h5 id="das-Stadion">das Stadion</h5><ul><li>意为“体育场”“<strong>大型</strong>运动场”，一般指规模较大、设施较为完善的综合性体育场馆，能够容纳大量观众，常用于<strong>举办</strong>大型体育赛事、演唱会等活动。</li></ul><h5 id="die-Sporthalle">die Sporthalle</h5><ul><li>指“体育馆”“<strong>室内</strong>体育馆”，主要用于进行一些在室内进行的体育项目，如篮球、排球、羽毛球、体操等。</li></ul></blockquote><p>der Lebensunterhalt (unz.)  生活费</p><blockquote><p>Ich habe beschlossen, im nächste März Test DAF zu machen.</p></blockquote><p>Ich rate dir, …  /  Ich schlage dir vor,…</p><blockquote><p>Die Prinzessin hat keine Schwierigkeiten,einen Mann zu finden.</p></blockquote><blockquote><p>Wir passen nicht zusammen.</p></blockquote><h5 id="Sehr-geehrte-Damen-und-Herren">Sehr geehrte Damen und Herren.</h5><blockquote><p>Ich bin total <u>begeistert <strong>von</strong></u> der Verbotenen Stadt, die mir <u>gut gefallen</u> hat.</p><p>Sie habt mir absolut / total fasziniert.</p><p>Die Verbotene Stadt hat mich sehr beeindruckt.</p><p>Die Verbotene Stadt ist in Wirklichkeit viel beeindruckender als <u><strong>auf</strong> den Fotos</u>.</p><p>Die Verbotene Stadt erscheint mir groß und bedeutend.</p></blockquote><p>entlassen–entlässt–entließ–entlassen 解雇  / kündigen（声明）离职</p><p>das Seminar --e (课堂讨论) = die Vorlesung (im Hörsaal) （公共讲课）</p><p>der Hörsaal --die Hörsäle 阶梯教室</p><h6 id="Wie-gefallt-es-dir-in-Shanghai">Wie gefällt es dir in Shanghai?</h6><blockquote><p>[!NOTE]</p><h5 id="austauschen">austauschen</h5><ul><li>物品<strong>交换</strong><ul><li>Wir haben unsere Jacken ausgetauscht, weil ich deine lieber mag.（我们交换了外套，因为我更喜欢你的。）</li></ul></li><li>意见、想法交换<ul><li>Wir sollten unsere Meinungen austauschen, um eine bessere Lösung zu finden.（我们应该交流一下我们的意见，以便找到更好的解决方案。）</li></ul></li><li>更换物品<ul><li>Er hat das alte Auto gegen ein neues ausgetauscht.（他用旧汽车换了一辆新的。）</li></ul></li></ul><h5 id="umtauschen">umtauschen</h5><ul><li><p>货币<strong>兑换</strong></p><ul><li>Kann ich hier Euros in US-Dollar umtauschen?（我可以在这里把欧元兑换成美元吗？）</li></ul></li><li><p>度量衡换算</p><ul><li>Bitte umtauschen Sie die Gewichte von Kilogramm in Pfund.（请把重量从千克换算成磅。）</li></ul></li><li><p>更换物品（特定情境）</p><ul><li>Sie können das Ticket am Schalter umtauschen, wenn Sie den falschen Flug gebucht haben.（如果您订错了航班，可以在售票柜台更换车票。）</li></ul></li></ul></blockquote><p>sich (+D) Zeit +nehmen</p><blockquote><p>Ich bin aufgewachsen.</p></blockquote><p>Ich spiele am Computer.</p><p>nachdenken 思索,考虑</p><h6 id="uber-j-n-etw-nachdenken-uberlegen">(über j-n / etw.)  nachdenken  =  überlegen</h6><blockquote><p>Ich brauche einen Moment, um nachzudenken.</p></blockquote><p>das Schulkind ist ein Kind, das <u>zur/in die/auf(国家机构)</u> Schule geht.</p><p>einigen 统一 vereinigen 联合 das Königreich 王国</p><h5 id="das-Vereinigte-Konigreich-英国">das Vereinigte Königreich 英国</h5><p>miteinander adv. 互相 durcheinander adv. 混乱</p><blockquote><p>Eine schwache Schule hat eine Menge von Schreibwaren.</p><p>差生文具多。</p></blockquote><p>durchhalten 坚持到底</p><blockquote><p>“Halte Durch! ”</p></blockquote><p>die Fußgängezone 步行区 die Einkaufsstraße 购物街</p><blockquote><p>[!IMPORTANT]</p><h5 id="entschieden">entschieden</h5><ul><li><strong>用法及示例</strong><ul><li><strong>作动词过去式和过去分词</strong>：表示“决定”“作出决定”“解决”等含义，常用于描述已经完成的动作，其主语通常是人或具有决策能力的主体。<ul><li>Er hat gestern entschieden, nach Berlin zu fahren.（他昨天决定去柏林。）</li><li>Die Angelegenheit wurde endlich entschieden.（这件事终于得到了解决。）</li></ul></li><li><strong>作形容词</strong>：意为“坚定的”“果断的”“明确的”，用于修饰名词或作表语，描述人或事物的性质或状态。<ul><li>Sie hat eine entschiedene Haltung gegenüber dieser Frage.（她对这个问题持坚定的态度。）</li></ul></li></ul></li></ul><h5 id="beschliesen">beschließen</h5><ul><li><p>动词，意为“决定”“决议”“商定”等，通常用于正式、官方或集体的决策场合，强调通过讨论、协商等方式达成一致意见后做出决定。</p></li><li><p><strong>用法及示例</strong></p><ul><li>Der Ausschuss hat beschlossen, das Projekt zu genehmigen.（委员会决定批准这个项目。）</li><li>Die Regierung hat ein neues Gesetz beschlossen.（政府通过了一项新法律。）</li></ul></li><li><p>“entschieden”作为动词时侧重于描述个人或主体做出决定的行为，强调动作本身；作为形容词时用于描述性质或状态。而“beschließen”更强调通过集体讨论、协商等方式达成一致的决策过程，常用于正式场合。</p></li></ul></blockquote><blockquote><p>&quot;Nach dem Essen können Sie zum Bund bummeln(闲逛，磨洋工), wo viel Gebäude im westlichen Baustil stehen.</p><p>…Man vergleicht die Waren(货物) in der Nanjingstraße mit einer ‘Prinzessin,die keine Schwierigkeiten hat, einen Mann zu finden.’</p><p>&quot;Interessant! &quot;</p></blockquote><p>schlimm  最坏</p>]]></content>
    
    
    <categories>
      
      <category>德语</category>
      
    </categories>
    
    
    <tags>
      
      <tag>德语</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mlf德语 2.26日笔记</title>
    <link href="/2025/02/26/2.26/"/>
    <url>/2025/02/26/2.26/</url>
    
    <content type="html"><![CDATA[<p><strong>dasselbe</strong>  pron. 同样的</p><blockquote><p><u>Zum großen Teil</u> ist es einfach dasselbe.</p></blockquote><p>在大多数情况下它都是一样的。</p><blockquote><p>Gern und gerne bedeuten dasselbe, allein und alleine auch.</p></blockquote><p>&quot; gern&quot; 和&quot; gerne&quot; 的意思是一样的，&quot; allein&quot; 和&quot; alleine&quot; 也是如此。</p><blockquote><p>[!NOTE]</p><p><strong>一、die Tatsache（事实）</strong></p><ul><li><p>主要指客观存在的、<strong>已经发生的事件</strong>或情况。例如：</p><ul><li><h6 id="u-Die-Tatsache-dass-u-er-heute-nicht-zur-Arbeit-kam-hat-alle-uberrascht-他今天没来上班这个事实让所有人都很惊讶。"><u>Die Tatsache, dass</u> er heute nicht zur Arbeit kam, hat alle überrascht.他今天没来上班这个事实让所有人都很惊讶。</h6></li></ul></li><li><p>强调事情的实际发生性，是一种可以被证实或者证伪的具体情况。</p></li><li><p>可以单独使用，也可以在一些固定搭配中出现，如</p><h6 id="“auf-Grund-der-Tatsachen”（根据事实）。">“auf Grund der Tatsachen”（根据事实）。</h6></li></ul><p><strong>二、die Wahrheit（真相、真理）</strong></p><ul><li><p>更侧重于<strong>事物的本质、内在的真实</strong>情况，往往带有一种经过思考、探究后得出的真实结论的意味。例如：</p><ul><li><h6 id="Die-Wahrheit-uber-den-Vorfall-u-wird-bald-u-herauskommen">Die Wahrheit über den Vorfall <strong><u>wird bald</u></strong> herauskommen.</h6><h6 id="关于这个事件的真相很快就会大白。">关于这个事件的真相很快就会大白。</h6></li></ul></li><li><p>在哲学语境下，“die Wahrheit”还可以表示真理，是一种普遍的、永恒的正确概念。</p></li><li><p>同样可以单独使用，在表达观点或者探究事情本质的时候经常用到。例如</p><h6 id="“die-ganze-Wahrheit”（全部真相）。">“die ganze Wahrheit”（全部真相）。</h6></li></ul><p>总的来说，“die Tatsache”更偏向于具体的事件事实，“die Wahrheit”更强调事物的真实本质或者经过挖掘后的真相。</p></blockquote><p>Ich muss ehrlich sagen, …</p><p>seien wir doch mal ehrlich …</p><blockquote><p><u>Seien</u> wir doch mal ehrlich, <strong><u>wir</u></strong> alle machen manchmal Fehler.</p><p>咱们坦率地说吧，我们所有人有时候都会犯错。</p></blockquote><p>Sei ehrlich!  说实话</p><p>die Wolke --n 云<br>der Wolkenkratzer – 摩天大楼</p><p>das Viertel –  城市区<br>das Kulturviertel –  文化区</p><blockquote><p>&quot;So ist das also. &quot; = “Also so was.”  原来如此</p></blockquote><blockquote><p>[!TIP]</p><ol><li><p><strong>So ist das also.</strong></p><p>字面意思是“原来是这样啊”，语气比较<strong>平和</strong>、客观，</p><p>常用于在了解事情真相或原因后的一种自然反应。</p></li><li><p><strong>Also so was.</strong></p><p>有“原来是这么回事”“原来还有这种事”的意思，</p><p>语气可能稍带一点<strong>惊讶或感慨</strong>。</p></li><li><p><strong>Nun wird mir alles klar.</strong></p><p>“现在一切都清楚了”，通常用于在困惑或疑惑之后，<strong>突然明白</strong>了事情的全貌。</p></li><li><p><strong>Aha.</strong></p><p>这是一个比较简洁的表达方式，类似于英语中的“aha” ，</p><p>表示突然明白了或者理解了某个事情，语气相对<strong>轻松</strong>。</p></li></ol></blockquote><p>der Turm -^ 塔</p><p>der Fernsehturm 电视塔</p><blockquote><p>[!CAUTION]</p><p>“sich etwas vorstellen”  常用于表达“想象”；</p><p>“jemandem jemanden vorstellen”  则明确表示“介绍”。</p></blockquote><blockquote><p>Kannst du dir vorstellen, wie es in 100 Jahren aussehen wird?</p></blockquote><p>（你能想象一下100年后会是什么样子吗？）</p><blockquote><p>Die Arbeit war mühsam, aber die Ergebnisse sind sehr gut.<br><u>Alles in allem</u> lohnt <u>sich</u> der Einsatz.</p></blockquote><p>这项工作很辛苦，但结果非常好。总的来说，付出是值得的。</p><blockquote><p>[!TIP]</p><h5 id="“Protokoll”和“Abmachung”辨析">“Protokoll”和“Abmachung”辨析</h5></blockquote><ul><li><p>das <strong>Protokoll</strong></p><ul><li><p><strong>正式协议</strong>文件，如贸易、外交等领域，具有权威性与约束力。如：</p></li><li><h6 id="Die-beiden-Lander-unterzeichneten-ein-Handelsprotokoll-（两国签署了一份贸易协议。）">Die beiden Länder unterzeichneten ein Handelsprotokoll.（两国签署了一份贸易协议。）</h6></li><li><p>活动记录，像会议、谈判等的详细纪要。如：</p><h6 id="Das-Protokoll-der-Sitzung-wurde-verteilt-（会议纪要已分发。）">Das Protokoll der Sitzung wurde verteilt.（会议纪要已分发。）</h6></li><li><p>操作程序，如实验、活动等的<strong>步骤规范</strong>。如：</p><h6 id="Das-Protokoll-fur-das-Experiment-muss-eingehalten-werden-实验程序必须遵守。">Das Protokoll für das Experiment muss eingehalten werden.  (实验程序必须遵守。)</h6></li><li><p><strong>外交礼节</strong>仪式，用于国际关系中遵循的传统规范。如：</p><h6 id="Die-diplomatischen-Protokolle-sind-wichtig-（外交礼节很重要。）">Die diplomatischen Protokolle sind wichtig.（外交礼节很重要。）</h6></li></ul></li><li><p><strong>Abmachung</strong></p><ul><li><p>口头或书面的<strong>约定</strong>、协议，不一定正式，但有约束力。如：</p><h6 id="Es-gab-eine-Abmachung-zwischen-den-Freunden-（朋友们有个约定。）">Es gab eine Abmachung zwischen den Freunden.（朋友们有个约定。）</h6></li></ul></li></ul><h5 id="例句对比">例句对比</h5><table><thead><tr><th>场景</th><th>Protokoll例句</th><th>Abmachung例句</th></tr></thead><tbody><tr><td>正式会议记录</td><td>Das Protokoll der Sitzung wurde veröffentlicht.</td><td>-</td></tr><tr><td>正式协议签署</td><td>Die Unternehmen haben ein Kooperationsprotokoll unterzeichnet.</td><td>-</td></tr><tr><td>日常约定</td><td>-</td><td>Ich habe mit meiner Schwester eine Abmachung getroffen.</td></tr><tr><td>商务合作初步约定</td><td>Ein vorläufiges Protokoll zur Zusammenarbeit wurde erstellt.</td><td>Die Geschäftspartner trafen eine Abmachung über die Lieferzeit.</td></tr></tbody></table><h5 id="总结">总结</h5><p>“Protokoll”更正式、强调记录与程序；“Abmachung”侧重约定内容，<u>使用场景更广</u>。</p><p>der Raub --e  = der überfall -^e 抢劫</p><p>der Raubüberfall</p><blockquote><p>Der Einbrecher wollte <strong><u>sich</u></strong> den Raubüberfall <strong><u>nicht unter die Weste jubeln lassen</u></strong>.<br>这个窃贼不让人家把抢劫案推在自己身上。</p></blockquote><blockquote><p>[!CAUTION]</p><p>Die <u>Redewendung</u> <strong><u>“sich etwas unter die Weste jubeln lassen”</u></strong> bedeutet, dass jemand versucht, sich einer Verantwortung oder Schuld zu <u>entziehen</u> oder etwas Unerlaubt**<u>es</u>** zu <u>vertuschen</u>. In diesem Fall möchte der Einbrecher also nicht <u>zugeben</u> oder akzeptieren, dass er den Raubüberfall <u>begangen</u> hat, und versucht <u>wahrscheinlich</u>, die Schuld von sich zu <u>weisen</u> oder <u>Beweise</u> zu verbergen.</p><p><u><strong>&quot;瞒天过海 &quot;</strong></u>这一<u>固定搭配</u>指某人试图<u>逃避</u>责任或罪责，或<u>掩盖</u>未经授权的事情。在这种情况下，窃贼不想<u>承认</u>或接受自己<u>实施</u>了抢劫，<u>很可能</u>是想<u>否认</u>自己有罪或隐藏<u>证据</u>。</p></blockquote><p>zeugen 证明 überzeugend 有说服力的</p><p>der Zeuge / die Zeugin  证人</p><p>zuständig （主管的）= verantwortlich （负责的）</p><p>verbergen（藏住） = vertuschen（掩盖）=  verstecken（藏进）</p><blockquote><p>Er konnte seine Fr<u>eu</u>de nicht verbergen.</p></blockquote><p>der Beweis --e （证据概念）= das Beweismittel –  （证据材料）</p><blockquote><p>Durch sein Verhalten machte er sich verdächtig.</p><p>他的行为使他受到怀疑。</p><p>Der Mann (Die Sache) kommt mir verdächtig vor.</p><p>我觉得这个人(这件事)有可疑之处。</p><p>Er hat mich verdächtigt,das Geld entwendet zu haben.</p><p>他怀疑我偷了钱。</p></blockquote><p>verdächtigen 怀疑</p><p>Sie verdächtigte ihn, gelogen zu haben.   (lügen–log–gelogen)<br>她怀疑他在撒谎。</p><p>einbrechen（强闯）= entwenden（偷窃）</p><p>entscheinen = vorkommen 显出</p><h6 id="Ob-wir-die-Reise-machen-konnen-u-entscheint-u-u-vom-u-Wetter">Ob wir die Reise machen können, <u>entscheint</u> <u><strong>vom</strong></u> Wetter.</h6><p>（我们能否进行这次旅行<u>取决于</u>天气。）</p><p>“unter…bedingungen … treten…auf ”  在特定的条件下，某种情况开始出现</p><h6 id="Unter-bestimmten-Wetterbedingungen-treten-Schaden-an-den-Pflanzen-auf-die-normalerweise-nicht-vorkommen">Unter bestimmten Wetterbedingungen treten Schäden an den Pflanzen auf, die normalerweise nicht vorkommen.</h6><p>（在特定的天气条件下，植物会出现一些通常不会出现的损害。）</p><p>passieren（发生）= auftreten（出现）</p>]]></content>
    
    
    <categories>
      
      <category>德语</category>
      
    </categories>
    
    
    <tags>
      
      <tag>德语</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mlf德语 2.25日笔记</title>
    <link href="/2025/02/25/2.25/"/>
    <url>/2025/02/25/2.25/</url>
    
    <content type="html"><![CDATA[<p>die Stimme der Geigen  小提琴声</p><blockquote><p>[!NOTE]</p><h6 id="“-u-Was-fur-Filme-u-sieht-dein-Freund-am-liebsten-”">“<u>Was für Filme</u> sieht dein Freund am liebsten?”</h6><p>更侧重于询问“什么样的（哪一类的）电影”，强调电影的类型、种类等特征。</p><h6 id="“-u-Welche-Filme-u-sieht-dein-Freund-am-liebsten-”">“<u>Welche Filme</u> sieht dein Freund am liebsten?”</h6><p>更直接地询问“哪些电影”，可以是对具体电影名称或者一系列电影的询问。</p></blockquote><p>In welchem Schulfach warst du denn ganz schlecht?<br>你哪门课真的学得不好？</p><p>“finden + 宾语 + 形容词”</p><h6 id="Ich-finde-es-langweilig">Ich finde es langweilig.</h6><p>Aber：</p><p>“Ich finde es langweilig.” 更侧重于对具体事物的评价;</p><p>“Mir ist langweilig.” 更侧重于表达自身的感受。</p><p>die Haut -^e 皮肤</p><h6 id="die-sieben-Haute-der-Zwiebel-洋葱的七层外衣">die sieben Häute der Zwiebel  洋葱的七层外衣</h6><blockquote><p>[!CAUTION]</p><h6 id="“sind-das-meine-Unterhosen-”">“sind das meine Unterhosen?”</h6><p>“das”是**<u>不定代词</u>**，泛指“这些”，用于看到一些不明具体是否是自己衣裤的东西时询问；</p><h6 id="“sind-die-meine-Unterhosen-”">“sind die meine Unterhosen?”</h6><p>“die”是定冠词，特指某些特定的内裤（双方都明确知道是哪些），用于询问特定衣裤是否是自己的 。</p></blockquote><p>Auf welche Weise?</p><blockquote><p>Wenn du eine Aufgabe erledigen musst, auf welche Weise wirst du <strong>es</strong> tun?</p></blockquote><p>（当你必须完成一项任务时，你将以何种方式去做？）</p><blockquote><p>[!CAUTION]</p><p>“sie” 是合理的，但 “es” 同样可用。</p></blockquote><blockquote><p>[!IMPORTANT]</p><ul><li><strong>语义侧重点</strong>：“lügen”侧重于描述说谎这个行为本身以及谎言的内容；“anlügen”更侧重于强调欺骗的对象，突出是针对某人进行说谎。</li><li><strong>用法搭配</strong>：“lügen”可作不及物动词也可作及物动词，用法相对灵活；“anlügen”只能作及物动词，且必须有宾语（被欺骗的对象）。</li></ul><h5 id="例句对比">例句对比</h5><ul><li><strong>lügen</strong><ul><li>Sie lügt, um ihre Fehler zu verbergen.（她说谎是为了掩盖自己的错误。）</li><li>Er lügt über seine Erfahrungen.（他编造自己的经历。）</li></ul></li><li><strong>anlügen</strong><ul><li>Er anlügt seine Eltern, dass er gut in der Schule ist.（他对父母撒谎说自己在学校表现很好。）</li><li>Sie anlügt ihren Freund, weil sie nicht mit ihm ausgehen will.（她对朋友撒谎，因为她不想和他出去。）</li></ul></li></ul></blockquote><p>verbergen 隐藏，掩盖  ( -verbirgst-verbirg   -verbarg-verborgen )</p><blockquote><p>In diesem Spruch liegt eine tiefe Weisheit verborgen.</p></blockquote><p>（这句格言包含着深刻的智慧。）</p><p>dünn 瘦，贫乏</p><p>Die Aussage des Buches ist sehr dünn.<br>(口，贬)这本书的内容很贫乏。</p><p>Das Eis war zu dünn, er ist durch**(ge)**brochen.<br>冰层太薄，他跌进去了。</p><blockquote><p>[!IMPORTANT]</p><p>“irgendwie” 常见为 “不知怎么地” “以某种方式” “反正” “大概”等</p><p>用于表达一种**<u>不太明确、模糊的方式</u>**、程度或状态。</p><h4 id="用法示例">用法示例</h4><ul><li><h5 id="表示“不知怎么地”“莫名其妙地”">表示“不知怎么地”“莫名其妙地”</h5><ul><li>Er hat irgendwie Angst bekommen.（不知怎么地，他突然害怕起来了。）</li><li>Irgendwie habe ich das Gefühl, <u>dass etwas nicht stimmt</u>.（不知为何，我有种感觉，好像哪里不对劲。）</li></ul></li><li><h5 id="表示“以某种方式”“用某种办法”">表示“以某种方式”“用某种办法”</h5><ul><li>Ich werde irgendwie das Problem lösen.（我会以某种方式解决这个问题。）</li><li>Sie hat irgendwie die Wahrheit herausgefunden.（她不知用什么办法发现了真相。）</li></ul></li><li><h5 id="表示“反正”“不管怎样”">表示“反正”“不管怎样”</h5><ul><li>Irgendwie wird schon alles gut gehen.（反正一切都会好起来的。）</li><li>Er kann es nicht genau erklären, aber irgendwie weiß er, dass es stimmt.（他无法确切地解释，但反正他知道这是对的。）</li></ul></li><li><h5 id="表示“大概”“大约”">表示“大概”“大约”</h5><ul><li>Er wird irgendwie um diese Zeit ankommen.（他大概会在这个时间到达。）</li><li>Es ist irgendwie teuer, dieser Mantel.（这件外套好像挺贵的。）</li></ul></li></ul><h3 id="与其他类似词语的区别">与其他类似词语的区别</h3><ul><li><p><strong>与“irgendein(e)”的区别</strong> ****</p><p>“irgendein(e)” 是形容词，用于修饰名词，表示“某个”“任意的”“随便一个” 。例如：Ich brauche irgendein Buch.（我需要任意一本（随便哪一本）书。）</p><ul><li>而“irgendwie” 是副词，用于修饰动词、形容词或其他副词，表示方式、程度等。例如：Er singt irgendwie gut.（他唱歌不知怎么地还不错。）</li></ul></li><li><p><strong>与“etwa”的区别</strong></p><ul><li>“etwa” 也有“大约”“大概”的意思，但更侧重于表示数量、时间、距离等方面的近似。例如：Es dauert etwa eine Stunde.（大约需要一个小时。）</li><li>“irgendwie” 更强调一种模糊、不确定的方式或状态。例如：Er wird irgendwie kommen, vielleicht mit dem Bus oder zu Fuß.（他大概会来，也许是坐公共汽车，也许是步行。）</li></ul></li></ul></blockquote><h5 id="区别总结">区别总结</h5><ul><li>“liegen”更侧重于描述一般性的“躺”的状态，不特别强调方向；而“hinliegen”则更强调躺的方向或位置关系，有“朝着某个方向躺”“往某处平卧”的意味。</li><li>在很多情况下，“liegen”可以单独使用来表达“躺”的意思，而“hinliegen”通常需要搭配具体的方位词或介词短语来<strong>明确躺的方向或位置</strong>。</li></ul><h5 id="例句对比-2">例句对比</h5><ul><li>只用liegen<ul><li>Das Kind liegt <strong><u>im Gras</u></strong>.（孩子躺在草地上。） 这里只是陈述孩子处于躺着的状态，没有特别强调方向。</li></ul></li><li>用hinliegen<ul><li>Die Katze liegt hin in der Sonne.（猫朝着太阳的方向躺着。） 此句强调了猫躺的方向是朝着太阳。</li></ul></li></ul><blockquote><p>[!NOTE]<br><strong>herausfinden</strong>意为“查明”“弄清楚”“找出（真相、答案等）”</p><p>强调通过努力、调查、询问等方式了解具体。</p><ul><li><p><strong>作为不及物动词</strong>：不直接接宾语，常与介词搭配使用。例如：</p><h6 id="Wir-mussen-herausfinden-was-passiert-ist-（我们必须弄清楚发生了什么。）">Wir müssen herausfinden, was passiert ist.（我们必须弄清楚发生了什么。）</h6></li><li><p><strong>作为及物动词</strong>：后面可直接接宾语。例如：</p><h6 id="Er-hat-herausgefunden-wer-der-Dieb-ist-（他已经查明了谁是小偷。）">Er hat herausgefunden, wer der Dieb ist.（他已经查明了谁是小偷。）</h6></li></ul><p>如果想表达“找到”的意思，用“finden”；</p><p>如果是想表达“查明、弄清楚”的意思，用“herausfinden” 。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>德语</category>
      
    </categories>
    
    
    <tags>
      
      <tag>德语</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mlf德语 2.24日笔记</title>
    <link href="/2025/02/24/2.24/"/>
    <url>/2025/02/24/2.24/</url>
    
    <content type="html"><![CDATA[<p>Machen Sie sich keine sorgen!</p><p>Wir sind <u>Fortgeschrittene</u> 进步者.</p><p>Spezialität  --en 名菜</p><h6 id="Shanghai-ist-eine-Stadt-die-sehr-gros-ist">Shanghai ist eine Stadt, die sehr groß ist.</h6><p>etwas  geht (nie) kaputt.</p><p>der Besen – 扫帚</p><p>Wir sind unserem Ziel einen **<u>bedeutend</u>**en Schritt näher gekommen.</p><h6 id="Ihr-Lacheln-ist-nur-eine-Maske-sie-ist-oft-traurig-u-an-der-Oberflache-u-（她的微笑只是面具，她常常表面看起来很悲伤。）">Ihr Lächeln ist nur eine Maske, sie ist oft traurig <u>an der Oberfläche</u>.（她的微笑只是面具，她常常表面看起来很悲伤。）</h6><h6 id="Die-Farbe-dieser-Blume-andert-sich-u-an-der-Oberflache-u-beim-Sonneneinfall-（这种花的颜色在阳光下表面会发生变化。）">Die Farbe dieser Blume ändert sich <u>an der Oberfläche</u> beim Sonneneinfall.（这种花的颜色在阳光下表面会发生变化。）</h6><p><u>In Beziehung auf</u> Ihre Frage nach dem nächsten Meeting, es findet am Montag um 10 Uhr statt.</p><p>Wir haben schon eine <u>Ewigkeit</u> auf dich gewartet.</p><h6 id="u-Seit-Ewigkeiten-u-gibt-es-Legenden-uber-dieses-alte-Schloss-（关于这座古老的城堡，很久以前就有传说流传。）"><u>Seit Ewigkeiten</u> gibt es Legenden über dieses alte Schloss.（关于这座古老的城堡，很久以前就有传说流传。）</h6><p>allgemein 一般的</p><h6 id="u-Im-allgemeinen-u-sind-die-Leute-in-diesem-Bereich-sehr-fleisig-（一般来说，这个领域的人们非常勤奋。）"><u>Im allgemeinen</u> sind die Leute in diesem Bereich sehr fleißig.（一般来说，这个领域的人们非常勤奋。）</h6><blockquote><p>[!CAUTION]</p><p>“bedeutend”侧重于表示“重要的”“有重大意义的”，强调事物本身的价值和影响力；<br>“bemerkenswert”侧重于“值得注意的”“引人注目的”，强调事物能引起他人的关注。</p></blockquote><p><strong>例句</strong>：</p><ul><li><p><strong>bedeutend</strong></p><ul><li>Die Erfindung des Internets ist ein bedeutender Fortschritt in der Menschheitsgeschichte.（互联网的发明是人类历史上的一项重大进步。）</li><li>Er ist ein bedeutender Künstler, dessen Werke weltweit bekannt sind.（他是一位著名的艺术家，其作品闻名于世。）</li></ul></li><li><p><strong>bemerkenswert</strong></p><ul><li><p>Die schnelle Entwicklung dieser kleinen Firma ist bemerkenswert.（这家小公司的快速发展值得注意。）</p></li><li><p>Es war ein bemerkenswerter Auftritt des jungen Sängers auf der Bühne.（这位年轻歌手在舞台上的表现引人注目。）</p></li></ul></li></ul><p>Ich liebe die Studenten, <u>denen</u> ich viel geholfen habe.</p><p>der Fotoapparat = die Kamera</p><h6 id="Die-Kamera-die-meine-Mutter-mir-geschenkt-habe-gefallt-mir-jm-etw-schenken">Die Kamera, die meine Mutter mir geschenkt habe, gefällt mir.(jm. etw. schenken)</h6><p>Frau Peng, die aus Xinjiang kommt, studiert am CDHAW.<br>Frau Peng, die aus Xinjiang kommt, <u>lernt</u> Deutsch mit mir am CDHAW zusammen.<br>Ich lerne Deutsch mit Frau Peng, die aus Xinjiang kommt.</p><p>Ich liebe die Lehrer, die mir viel geholfen haben.<br>Ich liebe die Schüler,denen ich viel geholfen habe.</p><blockquote><p>Die große Mauer liegt in Nordchina. Viele Ausländer wollen sie besichtigen.</p></blockquote><p>Die große Mauer liegt in Nordchina, die viele Ausländer besichtigen wollen.<br>Viele Ausländer wollen die große Mauer besichtigen, die in Nordchina liegt.</p><p>Es gibt noch eine Schwierigkeiten, die ich unbedingt(adv.无论如何) überwinden(克服困难) muss.</p><p>Die Kinder weinen(哭) nicht mehr, denen die Kindergärtnerin Märchen erzählt <strong><u>hat</u></strong>.</p><h6 id="需要自行完善时态">需要自行完善时态</h6><p>das Märchen – 童话</p><p>Bringt mir etw. Leckeres!</p><p>Schulnoten 学校成绩</p><blockquote><p>[!CAUTION]</p><p>“Wirkung”侧重于事物本身所具有的直接作用、效果，强调内在的作用力；“Auswirkung”侧重于行为、事件等产生的结果或后果，强调对外部的影响和扩散。</p></blockquote><p><strong>例句</strong>：</p><ul><li><strong>Wirkung</strong><ul><li>Die Wirkung dieses Heilmittels tritt schnell ein.（这种药物的效果很快显现。）</li><li>Die Wirkung des Lichts auf die Pflanzen ist sehr wichtig.（光对植物的作用非常重要。）</li></ul></li><li><strong>Auswirkung</strong><ul><li>Die Auswirkungen des Regens auf die Ernte sind offensichtlich.（雨水对收成的影响显而易见。）</li><li>Die Auswirkungen seines Fehlverhaltens auf die Firma waren fatal.（他的不当行为对公司的后果是致命的。）</li></ul></li></ul><p>im Weg sein  妨碍</p><h6 id="Er-ist-immer-im-Weg-wenn-ich-arbeiten-mochte-（当我想工作的时候，他总是妨碍我。）">Er ist immer im Weg, wenn ich arbeiten möchte.（当我想工作的时候，他总是妨碍我。）</h6><h6 id="Die-vielen-Probleme-sind-im-Weg-um-das-Projekt-erfolgreich-abzuschliesen-（许多问题妨碍了项目的成功完成。）">Die vielen Probleme sind im Weg, um das Projekt erfolgreich abzuschließen.（许多问题妨碍了项目的成功完成。）</h6><p>Schwierigkeiten bewältigen 克服困难</p><p>es geht jemandem gut 描述某人的状态良好</p><h6 id="wenn-er-seine-Probleme-bewaltigt-hatte-ware-es-ihm-gut-gegangen">wenn er seine Probleme bewältigt hätte, wäre es ihm gut gegangen.</h6><p>vesichern 保险  Versicherung  保险，Sozialversicherung 社保</p><p>Wie lange willst du denn eigentlich (adv. 究竟) noch weitermachen (继续做)?</p><p>der Vorteil 优点  der Nachteil 缺点</p><p>Nicht nur wir waren davon begeistert (热烈的，赞赏的), sondern auch allen anderen hat es sehr gut gefallen.</p><p>hässlich/ scheußlich  丑陋的</p><p>in Beziehung zu / mit = zu tun haben 与…有关</p><p>angehen 攻击，涉及，与……有关</p><blockquote><p>das geht <strong>dich</strong> nicht<u><strong>s</strong></u> an! 这与你无关</p></blockquote><p>in Rechtung Westen 向西</p><p>ausstellen 展示  Ausstellung 展览</p><p>in Wirklichkeit 事实上</p><p>der Eindruck 印象  beeindruckend 令人印象深刻的</p><h6 id="Sie-ist-in-Wirklichkeit-noch-viel-beeindruckender-als-auf-den-Fotos">Sie ist in Wirklichkeit noch viel beeindruckender als auf den Fotos.</h6>]]></content>
    
    
    <categories>
      
      <category>德语</category>
      
    </categories>
    
    
    <tags>
      
      <tag>德语</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于C++20中的新特性 ranges和views的学习</title>
    <link href="/2025/02/13/2025-02-13-%E5%85%B3%E4%BA%8EC++20%E4%B8%AD%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7-ranges%E5%92%8Cviews%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
    <url>/2025/02/13/2025-02-13-%E5%85%B3%E4%BA%8EC++20%E4%B8%AD%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7-ranges%E5%92%8Cviews%E7%9A%84%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1>ranges</h1><h1>views</h1><h2 id="std-views-transform">std::views::transform</h2><p><strong>特点</strong>：</p><ul><li><strong>惰性求值</strong>：转换操作不会立即执行，只有在你迭代这个视图时，lambda 函数才会应用到每个元素。</li><li><strong>不修改原容器</strong>，仅生成一个转换后的视图。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ranges&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><br>    <span class="hljs-comment">// 构造一个视图，每个元素乘以 2</span><br>    <span class="hljs-keyword">auto</span> transformed_view = v | std::views::<span class="hljs-built_in">transform</span>([](<span class="hljs-type">int</span> n) &#123; <span class="hljs-keyword">return</span> n * <span class="hljs-number">2</span>; &#125;);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> n : transformed_view) &#123;<br>        std::cout &lt;&lt; n &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 输出: 2 4 6 8 10</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="std-views-filter">std::views::filter</h2><p>创建一个视图，该视图仅包含满足给定谓词条件的元素，同样是惰性计算的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ranges&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;;<br><br>    <span class="hljs-comment">// 构造一个视图，只保留偶数元素</span><br>    <span class="hljs-keyword">auto</span> filtered_view = v | std::views::<span class="hljs-built_in">filter</span>([](<span class="hljs-type">int</span> n) &#123; <span class="hljs-keyword">return</span> n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>; &#125;);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> n : filtered_view) &#123;<br>        std::cout &lt;&lt; n &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 输出: 2 4 6</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="std-views-take">std::views::take</h2><p>用于构造一个视图，该视图只“取”原始范围的前 <em>n</em> 个元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ranges&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>&#125;;<br><br>    <span class="hljs-comment">// 构造一个视图，只取前 3 个元素</span><br>    <span class="hljs-keyword">auto</span> take_view = v | std::views::<span class="hljs-built_in">take</span>(<span class="hljs-number">3</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> n : take_view) &#123;<br>        std::cout &lt;&lt; n &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 输出: 10 20 30</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="std-views-drop">std::views::drop</h2><p>创建一个视图，跳过原始范围的前 <em>n</em> 个元素，只返回剩余部分。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ranges&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>&#125;;<br><br>    <span class="hljs-comment">// 构造一个视图，跳过前 2 个元素</span><br>    <span class="hljs-keyword">auto</span> drop_view = v | std::views::<span class="hljs-built_in">drop</span>(<span class="hljs-number">2</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> n : drop_view) &#123;<br>        std::cout &lt;&lt; n &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 输出: 30 40 50</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="std-views-reverse">std::views::reverse</h2><p>用于构造一个反向视图，不会修改原容器，只是在遍历时以相反顺序访问元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ranges&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><br>    <span class="hljs-comment">// 构造一个反向视图</span><br>    <span class="hljs-keyword">auto</span> rev_view = v | std::views::reverse;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> n : rev_view) &#123;<br>        std::cout &lt;&lt; n &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 输出: 5 4 3 2 1</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>或者说</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ranges&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><br>    <span class="hljs-comment">// 通过 std::views::reverse 创建一个反向视图</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> n : v | std::views::reverse) &#123;<br>        std::cout &lt;&lt; n &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 输出: 5 4 3 2 1</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="std-views-drop-last">std::views::drop_last</h2><p>它用于生成一个新的视图，<strong>去掉原始范围的最后 n 个元素</strong>。与 <code>std::views::drop</code> 类似，<code>std::views::drop_last</code> 也是一个惰性求值的操作符，它不会修改原容器，而是按需返回一个新的视图。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ranges&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><br>    <span class="hljs-comment">// 使用 drop_last 去掉最后两个元素</span><br>    <span class="hljs-keyword">auto</span> view = v | std::views::<span class="hljs-built_in">drop_last</span>(<span class="hljs-number">2</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> n : view) &#123;<br>        std::cout &lt;&lt; n &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 输出: 1 2 3</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="边界条件">边界条件</h3><ul><li><p>如果你指定的n大于等于容器的元素个数，结果将是一个空视图。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> empty_view = v | std::views::<span class="hljs-built_in">drop_last</span>(<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><p>这样就会得到一个空视图，因为容器中没有足够的元素可以去除。</p></li></ul><h2 id="这些函数可以通过管道运算符叠加使用-链式操作">这些函数可以通过管道运算符叠加使用(链式操作)</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ranges&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;;<br><br>    <span class="hljs-comment">// 使用 std::views::reverse 和 std::views::filter 链接，逆序并筛选掉奇数元素</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> n : v | std::views::reverse | std::views::<span class="hljs-built_in">filter</span>([](<span class="hljs-type">int</span> n) &#123; <span class="hljs-keyword">return</span> n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>; &#125;)) &#123;<br>        std::cout &lt;&lt; n &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 输出: 6 4 2</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>程设</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面向对象编程初步</title>
    <link href="/2025/02/12/2025-02-12-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%88%9D%E6%AD%A5/"/>
    <url>/2025/02/12/2025-02-12-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%88%9D%E6%AD%A5/</url>
    
    <content type="html"><![CDATA[<h1>类初步</h1><h2 id="什么是类？">什么是类？</h2><p>在C++中，类（<code>class</code>）是一个用户定义的数据类型，它不仅可以包含数据成员（类似于结构体的成员变量），还可以包含函数成员（也称为方法），这些函数成员可以操作类中的数据。类的设计初衷就是为了更好地封装数据和操作，使得代码更加模块化和可维护。</p><p>示例代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 定义一个表示学生的类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    string name;<br>    <span class="hljs-type">int</span> age;<br>    <span class="hljs-type">float</span> score;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-built_in">Student</span>(string n, <span class="hljs-type">int</span> a, <span class="hljs-type">float</span> s) : <span class="hljs-built_in">name</span>(n), <span class="hljs-built_in">age</span>(a), <span class="hljs-built_in">score</span>(s) &#123;&#125;<br><br>    <span class="hljs-comment">// 成员函数：打印学生信息</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printInfo</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;姓名：&quot;</span> &lt;&lt; name &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;年龄：&quot;</span> &lt;&lt; age &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;分数：&quot;</span> &lt;&lt; score &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 成员函数：更新分数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">updateScore</span><span class="hljs-params">(<span class="hljs-type">float</span> newScore)</span> </span>&#123;<br>        score = newScore;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 创建一个Student对象</span><br>    <span class="hljs-function">Student <span class="hljs-title">student1</span><span class="hljs-params">(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">20</span>, <span class="hljs-number">88.5</span>)</span></span>;<br><br>    <span class="hljs-comment">// 打印学生信息</span><br>    student<span class="hljs-number">1.</span><span class="hljs-built_in">printInfo</span>();<br><br>    <span class="hljs-comment">// 更新学生分数</span><br>    student<span class="hljs-number">1.</span><span class="hljs-built_in">updateScore</span>(<span class="hljs-number">92.0</span>);<br>    cout &lt;&lt; <span class="hljs-string">&quot;更新后的分数：&quot;</span> &lt;&lt; endl;<br>    student<span class="hljs-number">1.</span><span class="hljs-built_in">printInfo</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，我们定义了一个<code>Student</code>类，它包含了三个私有数据成员：<code>name</code>、<code>age</code>和<code>score</code>。这些成员只能通过类内部的函数成员（<code>printInfo</code>和<code>updateScore</code>）来访问和修改。</p><ul><li><strong>构造函数</strong>：<code>Student(string n, int a, float s)</code>是类的构造函数，它在创建对象时初始化数据成员。</li><li><strong>成员函数</strong>：<code>printInfo</code>用于打印学生信息，<code>updateScore</code>用于更新学生的分数。</li></ul><h2 id="结构体与类的异同">结构体与类的异同</h2><h4 id="相似点：">相似点：</h4><ol><li><strong>定义和使用</strong>：结构体和类的定义方式非常相似，都可以包含数据成员和函数成员。</li><li><strong>功能</strong>：结构体和类都可以实现封装数据和操作数据的功能。</li></ol><h4 id="不同点：">不同点：</h4><ol><li><strong>默认访问控制</strong>：结构体中的成员默认是<code>public</code>的，而类中的成员默认是<code>private</code>的。这是最主要的区别。</li><li><strong>用途和习惯</strong>：在C++中，结构体通常用于定义简单的数据结构，而类则用于定义更复杂的对象，并封装其行为和状态。</li></ol><h3 id="强调：结构体只是“all-public”的类">强调：结构体只是“<code>all public</code>”的类</h3><p>其实，结构体和类在C++中几乎是一样的。唯一的语法区别在于，结构体的成员默认是<code>public</code>的，而类的成员默认是<code>private</code>的。换句话说，结构体就是一个默认所有成员都是<code>public</code>的类。如果你将结构体的成员设置为<code>private</code>，并为它添加函数成员，那么它就和类没有区别了。</p>]]></content>
    
    
    <categories>
      
      <category>程设</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>语法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>同济大学2022年转专业（软件工程）机试</title>
    <link href="/2025/02/10/%E5%90%8C%E6%B5%8E%E5%A4%A7%E5%AD%A62022%E5%B9%B4%E8%BD%AC%E8%BD%AF%E6%9C%BA%E8%AF%95/"/>
    <url>/2025/02/10/%E5%90%8C%E6%B5%8E%E5%A4%A7%E5%AD%A62022%E5%B9%B4%E8%BD%AC%E8%BD%AF%E6%9C%BA%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<p><strong>共3题，每题100分，考试时间3小时。</strong></p><h1>第一题</h1><blockquote><h2 id="题目描述">题目描述</h2><p>给定一个字符串$s$和一个整数$k$，从字符串开头算起，每计数至$2k$个字符，就反转这$2k$字符中的前$k$个字符。</p><p>如果剩余字符少于$k$个，则将剩余字符全部反转。</p><p>如果剩余字符小于$2k$但大于或等于$k$个，则反转前$k$个字符，其余字符保持原样。</p><h2 id="输入格式">输入格式</h2><p>输入为$1$行，由一个纯字母组成的字符串和一个非负整数组成，字符串和整数之间用空格分隔开。</p><h2 id="输出格式">输出格式</h2><p>输出为$1$行，只需要输出反转后的字符串即可</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入">样例输入</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">abcdefg <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h3 id="样例输出">样例输出</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">bacdfeg<br></code></pre></td></tr></table></figure><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">abcd <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h3 id="样例输出-2">样例输出</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">bacd<br></code></pre></td></tr></table></figure></blockquote><h2 id="题解">题解</h2><p>这个问题等价于将字符串<code>s</code>分成$k$段，最后不足$k$的部分也计为一段，然后以每一段作为下标(从$0$开始)，第奇数段(即<code>(i+1)%!=0</code>或者<code>(i+1)&amp;1</code>）的字符串进行反转，注意最后不足$k$的部分可以通过一个取小函数来实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  string s;<br>  <span class="hljs-type">int</span> k;<br>  cin&gt;&gt;s&gt;&gt;k;<br>  <span class="hljs-type">int</span> len=(<span class="hljs-type">int</span>)s.<span class="hljs-built_in">size</span>();<br>  <span class="hljs-type">int</span> num=len/k;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;num;i++)&#123;<br>    <span class="hljs-keyword">if</span>((i<span class="hljs-number">+1</span>)&amp;<span class="hljs-number">1</span>) <span class="hljs-built_in">reverse</span>(s.<span class="hljs-built_in">begin</span>()+i*k,<span class="hljs-built_in">min</span>(s.<span class="hljs-built_in">begin</span>()+i*k+k,s.<span class="hljs-built_in">end</span>()));<br>  &#125;<br>  cout&lt;&lt;s;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1>第二题</h1><blockquote><h2 id="题目描述-2">题目描述</h2><p>毛哥买了一些糖果<code>candies</code>，打算把它们分给排好队的<code>n = num_people</code>个小朋友。</p><p>给第一个小朋友$1$颗糖果，第二个小朋友$2$颗，依此类推，直到给最后一个小朋友$n$颗糖果。</p><p>然后，我们再回到队伍的起点，给第一个小朋友$n + 1$颗糖果，第二个小朋友$n + 2$颗，依此类推，直到给最后一个小朋友$2 * n$颗糖果。</p><p>重复上述过程（每次都比上一次多给出一颗糖果，当到达队伍终点后再次从队伍起点开始），直到我们分完所有的糖果。注意，就算我们手中的剩下糖果数不够（不比前一次发出的糖果多），这些糖果也会全部发给当前的小朋友。</p><p>返回一个长度为<code>num_people</code>、元素之和为<code>candies</code>的数组（我们用<code>ans</code>来表示），以表示糖果的最终分发情况（即<code>ans[i]</code>表示第$i$个小朋友分到的糖果数）。</p><h2 id="输入格式-2">输入格式</h2><p>输入为$1$行，两个非负整数糖果数量（<code>candies</code>） 和 小朋友数量（<code>num_people</code>），他们之间用空格分隔开</p><h2 id="输出格式-2">输出格式</h2><p>输出为$1$行，<code>num_people</code>个整数，中间用空格分开。每个整数代表小朋友分到的糖果数。</p><h2 id="样例-1-2">样例 #1</h2><h3 id="样例输入-3">样例输入</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">7</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><h3 id="样例输出-3">样例输出</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h3 id="样例解释">样例解释</h3><p>第一次，<code>ans[0] += 1</code>，数组变为 <code>[1,0,0,0]</code>。</p><p>第二次，<code>ans[1] += 2</code>，数组变为 <code>[1,2,0,0]</code>。</p><p>第三次，<code>ans[2] += 3</code>，数组变为 <code>[1,2,3,0]</code>。</p><p>第四次，<code>ans[3] += 1</code>（因为此时只剩下 1 颗糖果），最终数组变为<code> [1,2,3,1]</code>。</p><h2 id="样例-2-2">样例 #2</h2><h3 id="样例输入-4">样例输入</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">10</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h3 id="样例输出-4">样例输出</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">5</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h3 id="样例解释-2">样例解释</h3><p>第一次，<code>ans[0] += 1</code>，数组变为 <code>[1,0,0]</code>。</p><p>第二次，<code>ans[1] += 2</code>，数组变为 <code>[1,2,0]</code>。</p><p>第三次，<code>ans[2] += 3</code>，数组变为 <code>[1,2,3]</code>。</p><p>第四次，<code>ans[0] += 4</code>，最终数组变为<code> [5,2,3]</code>。</p><h2 id="数据范围">数据范围</h2><p>$1$ ≤ <code>candies</code> ≤ $10^9$</p><p>$1$ ≤<code>num_people</code>≤ $1000$</p></blockquote><h1>题解</h1><p>依据题意模拟即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-type">int</span> candies,num_people;<br>  cin&gt;&gt;candies&gt;&gt;num_people;<br>  <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(num_people,<span class="hljs-number">0</span>)</span></span>;<br>  <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>  <span class="hljs-type">int</span> cnt=<span class="hljs-number">1</span>;<br>  <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span>(sum+cnt&lt;=candies)&#123;<br>    ans[i%num_people]+=cnt;<br>    sum+=cnt;<br>    cnt++;<br>    i++;<br>  &#125;<br>  ans[i%num_people]+=candies-sum;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x:ans) cout&lt;&lt;x&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1>第三题</h1><blockquote><h2 id="题目描述-3">题目描述</h2><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><h2 id="输入格式-3">输入格式</h2><p>输入为$n+1$行</p><p>第一行为两个用空格隔开的整数$n$和$m$</p><p>第$1$ - $n+1$行为$n × m$矩阵，其中每行有$m$个用空格隔开的非负整数。</p><h2 id="输出格式-3">输出格式</h2><p>输出为一个整数，即岛屿数量。</p><h2 id="样例-1-3">样例 #1</h2><h3 id="样例输入-5">样例输入</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">4</span> <span class="hljs-number">5</span><br><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span><br><span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span><br><span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h3 id="样例输出-5">样例输出</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h2 id="样例-2-3">样例 #2</h2><h3 id="样例输入-6">样例输入</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">4</span> <span class="hljs-number">5</span><br><span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span><br><span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span><br><span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span><br><span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h3 id="样例输出-6">样例输出</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h3 id="样例解释-3">样例解释</h3><p>没有’0’（水），全都是’1’（陆地），也按一个岛屿计算。</p><h2 id="数据范围-2">数据范围</h2><p>$1$ ≤ $m,n$≤ $200$</p></blockquote><h1>题解</h1><p>深搜板子题。</p><p>使用bfs的思想：枚举每一个位置的元素，如果是0就跳过，如果是1就使用bfs查询与该位置相邻的4个元素（前提是不出界），判断是否为1，如果是1那么继续查询，直到整个1块访问完毕。而为了避免走回头路可以定义一个bool数组inq(即in queue的缩写)来记录每个位置是否在bfs中已经入过队。</p><blockquote><p>[!TIP]</p><p>对于当前位置(x,y)而言，可以设置两个增量数组来访问相邻的4个位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> X[]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>&#125;;<br><span class="hljs-type">int</span> Y[]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<br></code></pre></td></tr></table></figure><p>分别对应(x,y+1) (x,y-1) (x+1,y) (x-1,y)</p><p>这样就可以用for循环去枚举4个方向，以确定当前坐标(nowX,nowY)相邻的4个位置</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;<br> newX=nowX+X[i];<br> newY=nowY+Y[i];<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//BFS做法</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">105</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>    <span class="hljs-type">int</span> x,y; <span class="hljs-comment">//存放位置</span><br>&#125;Node;<br><span class="hljs-type">int</span> n,m; <span class="hljs-comment">//矩阵大小</span><br><span class="hljs-type">int</span> matrix[maxn][maxn]; <span class="hljs-comment">//01矩阵</span><br><span class="hljs-type">bool</span> inq[maxn][maxn]=&#123;<span class="hljs-literal">false</span>&#125;; <span class="hljs-comment">//记录是否入过队</span><br><span class="hljs-type">int</span> X[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>&#125;,Y[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;; <span class="hljs-comment">//坐标增量数组</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(x&gt;m||x&lt;<span class="hljs-number">1</span>||y&gt;n||y&lt;<span class="hljs-number">1</span>||inq[x][y]||matrix[x][y]==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">//只要出界||入过队||在该点不为1,就不访问</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-comment">//访问位置(x,y)所在的块，设置一个块内的1的inq为true</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>    queue&lt;node&gt; q;<br>    Node.x=x;Node.y=y;<br>    q.<span class="hljs-built_in">push</span>(Node);<br>    <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>        node top=q.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">//取队首元素top</span><br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123; <span class="hljs-comment">//得到相邻位置</span><br>            <span class="hljs-type">int</span> newX=top.x+X[i],newY=top.y+Y[i];<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">judge</span>(newX,newY))&#123; <span class="hljs-comment">//如果这个新位置是符合要求的，需要访问</span><br>                Node.x=newX;Node.y=newY;<br>                q.<span class="hljs-built_in">push</span>(Node); <span class="hljs-comment">//入队</span><br>                inq[newX][newY]=<span class="hljs-literal">true</span>; <span class="hljs-comment">//已经入过队</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;m&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>            cin&gt;&gt;matrix[i][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>; <span class="hljs-comment">//记录答案（块数</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>            <span class="hljs-keyword">if</span>(matrix[i][j]==<span class="hljs-number">1</span>&amp;&amp;!inq[i][j])&#123; <span class="hljs-comment">//如果这个位置是1而且没有被访问过</span><br>                ans++; <span class="hljs-comment">//块数++</span><br>                <span class="hljs-built_in">bfs</span>(i,j);<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;ans;<br>&#125;<br></code></pre></td></tr></table></figure><p>也可以使用DFS来实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">/*dfs的思路：</span><br><span class="hljs-comment">从输入的点开始搜索，如果碰到0了就return</span><br><span class="hljs-comment">否则走岔路口：往四个方向走*/</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">105</span>;<br><span class="hljs-type">int</span> m,n,matrix[maxn][maxn];<br><span class="hljs-type">int</span> X[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>&#125;,Y[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;; <span class="hljs-comment">//坐标增量数组</span><br><span class="hljs-type">bool</span> visited[maxn][maxn];<span class="hljs-comment">//记录是否查询过</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">1</span>||x&gt;m||y&lt;<span class="hljs-number">1</span>||y&gt;n||visited[x][y]||!matrix[x][y]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">//只要出界||入过队||在该点不为1,就不访问</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-comment">//搜索一个块内，并标记为true</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">judge</span>(x,y)) <span class="hljs-keyword">return</span>;<br>    visited[x][y]=<span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;<br>        <span class="hljs-type">int</span> newX=x+X[i],newY=y+Y[i];<br>        <span class="hljs-built_in">dfs</span>(newX,newY);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>            cin&gt;&gt;matrix[i][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>; <span class="hljs-comment">//记录答案（块数</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>            <span class="hljs-keyword">if</span>(matrix[i][j]&amp;&amp;!visited[i][j])&#123; <span class="hljs-comment">//如果这个位置是1而且没有被访问过</span><br>                <span class="hljs-built_in">dfs</span>(i,j);<br>                ans++;<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;ans;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>程设</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分答案题目的一些经验规律</title>
    <link href="/2025/02/01/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88%E9%A2%98%E7%9B%AE%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%8F%E9%AA%8C%E8%A7%84%E5%BE%8B/"/>
    <url>/2025/02/01/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88%E9%A2%98%E7%9B%AE%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%8F%E9%AA%8C%E8%A7%84%E5%BE%8B/</url>
    
    <content type="html"><![CDATA[<h1>思路基础</h1><p>将一个序列分成左侧的蓝色区域和右侧的红色区域，</p><p>那么我们有基础代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-type">int</span> left,<span class="hljs-type">int</span> right)</span></span>&#123;<br><span class="hljs-type">int</span> mid;<br><span class="hljs-keyword">while</span>(left<span class="hljs-number">+1</span>!=right)&#123;<br>mid=left+(right-left&gt;&gt;<span class="hljs-number">1</span>);<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">isBlue</span>(mid)) left=mid; <span class="hljs-comment">// if(isRed(mid)) right=mid;</span><br><span class="hljs-keyword">else</span> right=mid; <span class="hljs-comment">//left=mid;</span><br>&#125;<br><span class="hljs-keyword">return</span> left; <span class="hljs-comment">//return right;</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">if(check(right)) return right;</span><br><span class="hljs-comment">else return left;</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">if(check(;eft)) return left;</span><br><span class="hljs-comment">else return right;</span><br><span class="hljs-comment">*/</span><br>&#125;<br></code></pre></td></tr></table></figure><p>下面我们来逐一解析这里面的区别。</p><h1>求最小值的最大的问题</h1><p>这种情况下我们需要写<code>isBlue()</code>函数，循环体内如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span>(left<span class="hljs-number">+1</span>!=right)&#123;<br>    mid=left+(right-left&gt;&gt;<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isBlue</span>(mid)) left=mid; <br>    <span class="hljs-keyword">else</span> right=mid; <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意<code>isBlue()</code>最后的返回的不等式要取等，将答案纳入蓝色边界内</strong>。</p><p>然后最后返回<code>left</code>。</p><p>但是如果没有AC，那么可能是因为边际条件的问题。</p><p>我们需要这样写返回值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(<span class="hljs-built_in">isBlue</span>(right)) <span class="hljs-keyword">return</span> right;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> left;<br></code></pre></td></tr></table></figure><p>这样可以保证输出是最大的可能答案。</p><h1>求最大值的最小的问题。</h1><p>这种情况下我们需要写<code>isRed()</code>函数，循环体内如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span>(left<span class="hljs-number">+1</span>!=right)&#123;<br>    mid=left+(right-left&gt;&gt;<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span>(isRedmid)) right=mid; <br>    <span class="hljs-keyword">else</span> left=mid; <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意<code>isRed()</code>最后的返回的不等式要取等，将答案纳入红色边界内</strong>。</p><p>然后最后返回<code>right</code>。</p><p>但是如果没有AC，那么可能是因为边际条件的问题。</p><p>我们需要这样写返回值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(<span class="hljs-built_in">isRed</span>(left)) <span class="hljs-keyword">return</span> left;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> right;<br></code></pre></td></tr></table></figure><p>这样可以保证输出是最小的可能答案。</p>]]></content>
    
    
    <categories>
      
      <category>程设</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>算法</tag>
      
      <tag>二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>J-数据时间？_2025牛客寒假算法基础集训营2 题解</title>
    <link href="/2025/01/24/J-%E6%95%B0%E6%8D%AE%E6%97%B6%E9%97%B4%EF%BC%9F_2025%E7%89%9B%E5%AE%A2%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E9%9B%86%E8%AE%AD%E8%90%A52%20%E9%A2%98%E8%A7%A3/"/>
    <url>/2025/01/24/J-%E6%95%B0%E6%8D%AE%E6%97%B6%E9%97%B4%EF%BC%9F_2025%E7%89%9B%E5%AE%A2%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E9%9B%86%E8%AE%AD%E8%90%A52%20%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<blockquote><p>链接：<a href="https://ac.nowcoder.com/acm/contest/95334/J">https://ac.nowcoder.com/acm/contest/95334/J</a><br>来源：牛客网</p><h2 id="题目描述">题目描述</h2><p>牛可乐正在分析最近几个月用户登录牛客 APP 的情况，他所收集的数据由三个字段构成，分别为：user_id表示用户 ID，login_date表示登录日期，login_time表示登录时间<br>他想请你帮助他统计h年m月份通勤、午休、临睡这三个时段各有多少人登录过 APP。特别地，同一个人在同一时段多次登录视作一次。</p><p>在本题中，通勤时间段为 07:00:00-09:00:00和18:00:00-20:00:00；午休时间段为11:00:00-13:00:00；临睡时间段为 22:00:00-01:00:00。时间段均包含左右边界值。</p><h2 id="输入描述">输入描述:</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">第一行输入三个整数 n,h,m(1≦n≤105; 2000≦h≦2030; 1≦m≦12)代表你需要处理的数据总数目、查询的年份、查询的月份。 <br>此后n行，每行先输入一个整数 user<span class="hljs-emphasis">_id (1≦user_</span>id≦10^20)代表用户 ID；再输入一个 YYYY-MM-DD 模式的日期 login<span class="hljs-emphasis">_date代表用户登录日期；最后输入一个 hh:mm:ss 模式的时间 login_</span>time代表用户登录时间。<br><br>YYYY-MM-DD 模式的时间定义为：2000≦YYYY≦2030代表年份，1≦MM≦12代表月份，1≦DD≦31代表日期。日期遵照平闰年规则。<br>hh:mm:ss 模式的时间定义为：0≦hh≦23代表小时、0≦mm≦59代表分钟、0≦ss≦59代表秒。<br></code></pre></td></tr></table></figure><h2 id="输出描述">输出描述:</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">在一行上输出三个整数代表通勤、午休、临睡三个时段的登录人次。注意，同一个人在同一时段多次登录视作一次。          <br></code></pre></td></tr></table></figure><h2 id="输入">输入</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs markdown">13 2021 12<br>2 2021-11-08 20:00:00<br>2 2021-12-03 07:00:00<br>3 2021-12-03 11:00:00<br>3 2021-12-05 12:00:00<br>4 2024-11-08 20:00:00<br>2 2021-12-06 09:20:00<br>2 2021-12-06 18:20:00<br>2 2021-12-07 13:00:00<br>2 2021-12-31 22:00:00<br>3 2021-12-30 21:00:00<br>4 2021-12-30 00:50:00<br>4 2021-12-31 00:30:00<br>2 2021-11-09 17:00:00<br></code></pre></td></tr></table></figure><h2 id="输出">输出</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">1 2 2<br></code></pre></td></tr></table></figure><p>​                            示例2</p><h2 id="输入-2">输入</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">2 2025 1<br>1000 2024-12-31 23:59:59<br>1000 2025-01-01 00:00:00<br></code></pre></td></tr></table></figure><h2 id="输出-2">输出</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">0 0 1<br></code></pre></td></tr></table></figure><h2 id="说明">说明</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">先判定年份与月份，再判定时间。<br></code></pre></td></tr></table></figure><p>​                            示例3</p><h2 id="输入-3">输入</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">2 2025 1<br>1 2025-01-23 00:00:00<br>1 2025-01-22 00:00:00<br></code></pre></td></tr></table></figure><h2 id="输出-3">输出</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">0 0 1<br></code></pre></td></tr></table></figure><h2 id="说明-2">说明</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">同一时间段不作重复计算。<br></code></pre></td></tr></table></figure></blockquote><h1>题解</h1><p>本题实际上不难，是一道模拟，但是可以灵活使用多种STL容器来让本题的代码实现非常简单。</p><p>首先为了统计每个人的登录次数，我们不需要把所有人的所有信息都记录下来之后再进行判断，而只需要在循环中的一次读入内判断完就可以了。</p><p>其次，题目中的要求“同一个人在同一时段多次登录视作一次”，理解成是自动去重，我们不难考虑到unordered_set容器，可以自动去重。</p><p>于是我们定义三个时间段的容器，分别存储在三个时间登录过APP的人数即可。</p><p>即每次insert账号，最后输出size()。</p><p>然后就是这几个时间。</p><p>首先是年份和月份，我们可以读入login_date之后使用sscanf函数和最开始读入的h和m进行比较，如果未通过就continue。</p><p>但是我们使用的是string进行读入，而sscanf函数只支持char[]，该如何是好呢？</p><p>我们可以使用<code>std::string</code> 类的一个成员函数.c_str()，用于将 <code>std::string</code> 对象转换为 C 风格的字符串（即以 <code>\0</code> 结尾的字符数组）。</p><p>再之后就是login_time的问题了，我们注意到由于格式都一样，我们可以直接使用字典序进行比较来确定是否落在我们需要的时间里面。</p><p>也就是可以定义一个这样的函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">P</span><span class="hljs-params">(string time,string start,string end)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> time&gt;=start&amp;&amp;time&lt;=end;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果落在我们需要的范围内就会返回true。</p><p>接下来如果只是这样暴力的<code>if(P(login_time,&quot;07:00:00&quot;,&quot;09:00:00&quot;)||P(login_time,&quot;18:00:00&quot;,&quot;20:00:00&quot;))</code>当然也是可以的，但是我们可以有更好的选择，</p><p>我们注意到一个时间段由两个部分组成：开始和结束，这让我们不禁考虑到使用pair来存储一个时间段，而通勤时间和临睡时间由两个时间段组成，这样我们可以使用vector来存储pair，再使用based循环来解决问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 定义时间段</span><br>vector&lt;pair&lt;string, string&gt;&gt; rushHours = &#123;&#123;<span class="hljs-string">&quot;07:00:00&quot;</span>, <span class="hljs-string">&quot;09:00:00&quot;</span>&#125;, &#123;<span class="hljs-string">&quot;18:00:00&quot;</span>, <span class="hljs-string">&quot;20:00:00&quot;</span>&#125;&#125;;<br>vector&lt;pair&lt;string, string&gt;&gt; lunchHours = &#123;&#123;<span class="hljs-string">&quot;11:00:00&quot;</span>, <span class="hljs-string">&quot;13:00:00&quot;</span>&#125;&#125;;<br>vector&lt;pair&lt;string, string&gt;&gt; sleepHours = &#123;&#123;<span class="hljs-string">&quot;22:00:00&quot;</span>, <span class="hljs-string">&quot;23:59:59&quot;</span>&#125;, &#123;<span class="hljs-string">&quot;00:00:00&quot;</span>, <span class="hljs-string">&quot;01:00:00&quot;</span>&#125;&#125;; <span class="hljs-comment">//记得拆分</span><br></code></pre></td></tr></table></figure><p>最终的代码实现如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_set&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">1e5</span><span class="hljs-number">+10</span>;<br><span class="hljs-type">int</span> n,h,m;<br>string user_id,login_date,login_time;<br>unordered_set&lt;string&gt; tongqing,wuxiu,lingshui;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">P</span><span class="hljs-params">(string time,string s,string e)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> time&gt;=s&amp;&amp;time&lt;=e;<br>&#125;<br><span class="hljs-comment">// 定义时间段</span><br>vector&lt;pair&lt;string, string&gt;&gt; rushHours = &#123;&#123;<span class="hljs-string">&quot;07:00:00&quot;</span>, <span class="hljs-string">&quot;09:00:00&quot;</span>&#125;, &#123;<span class="hljs-string">&quot;18:00:00&quot;</span>, <span class="hljs-string">&quot;20:00:00&quot;</span>&#125;&#125;;<br>vector&lt;pair&lt;string, string&gt;&gt; lunchHours = &#123;&#123;<span class="hljs-string">&quot;11:00:00&quot;</span>, <span class="hljs-string">&quot;13:00:00&quot;</span>&#125;&#125;;<br>vector&lt;pair&lt;string, string&gt;&gt; sleepHours = &#123;&#123;<span class="hljs-string">&quot;22:00:00&quot;</span>, <span class="hljs-string">&quot;23:59:59&quot;</span>&#125;, &#123;<span class="hljs-string">&quot;00:00:00&quot;</span>, <span class="hljs-string">&quot;01:00:00&quot;</span>&#125;&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;h&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        cin&gt;&gt;user_id&gt;&gt;login_date&gt;&gt;login_time;<br>        <span class="hljs-type">int</span> year,month;<br>        <span class="hljs-built_in">sscanf</span>(login_date.<span class="hljs-built_in">c_str</span>(),<span class="hljs-string">&quot;%d-%d&quot;</span>,&amp;year,&amp;month);<br>        <span class="hljs-keyword">if</span>(year!=h||month!=m) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; x:rushHours)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">P</span>(login_time,x.first,x.second))&#123;<br>                tongqing.<span class="hljs-built_in">insert</span>(user_id);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; x:lunchHours)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">P</span>(login_time,x.first,x.second))&#123;<br>                wuxiu.<span class="hljs-built_in">insert</span>(user_id);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; x:sleepHours)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">P</span>(login_time,x.first,x.second))&#123;<br>                lingshui.<span class="hljs-built_in">insert</span>(user_id);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;tongqing.<span class="hljs-built_in">size</span>()&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>&lt;&lt;wuxiu.<span class="hljs-built_in">size</span>()&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>&lt;&lt;lingshui.<span class="hljs-built_in">size</span>()&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>程设</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>算法</tag>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>G-一起铸最好的剑！_2025牛客寒假算法基础集训营2 题解</title>
    <link href="/2025/01/24/G-%E4%B8%80%E8%B5%B7%E9%93%B8%E6%9C%80%E5%A5%BD%E7%9A%84%E5%89%91%EF%BC%81_2025%E7%89%9B%E5%AE%A2%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E9%9B%86%E8%AE%AD%E8%90%A52%20%E9%A2%98%E8%A7%A3/"/>
    <url>/2025/01/24/G-%E4%B8%80%E8%B5%B7%E9%93%B8%E6%9C%80%E5%A5%BD%E7%9A%84%E5%89%91%EF%BC%81_2025%E7%89%9B%E5%AE%A2%E5%AF%92%E5%81%87%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E9%9B%86%E8%AE%AD%E8%90%A52%20%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<blockquote><p>链接：<a href="https://ac.nowcoder.com/acm/contest/95334/G">https://ac.nowcoder.com/acm/contest/95334/G</a><br>来源：牛客网</p><h2 id="题目描述">题目描述</h2><p>牛可乐从古籍中得知，铸剑的温度越接近n度，剑的品质越好。现在，他正在研究他家的铸剑炉，想要铸出全村最好的剑。<br>启动炉子时，牛可乐已经添过了一次柴，所以铸剑炉的初始温度为m度。此后，牛可乐每次添柴可以使得铸剑炉的温度提高到原来的m倍，即温度变为m^2, m^3, …</p><p>牛可乐想要知道，他最少需要添多少次柴（包括启动炉子时添的那一次），才能使得铸剑炉的温度最接近n度，这样他就能铸出一把品质最好的剑。</p><h2 id="输入描述">输入描述:</h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs latex">每个测试文件均包含多组测试数据。第一行输入一个整数 T(1≦T≦105)代表数据组数，每组测试数据描述如下：<br><br>在一行上输入两个整数 n,m(1≦n,m≦10<span class="hljs-built_in">^</span>9)代表最佳铸剑温度、牛可乐每次添柴可以使得铸剑炉的温度提高的倍数。<br></code></pre></td></tr></table></figure><h2 id="输出描述">输出描述:</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">对于每组测试数据，新起一行。输出一个整数，代表牛可乐最少需要的添柴次数。                    <br></code></pre></td></tr></table></figure><h2 id="输入">输入</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">3</span><br><span class="hljs-number">7</span> <span class="hljs-number">6</span><br><span class="hljs-number">6</span> <span class="hljs-number">2</span><br><span class="hljs-number">9</span> <span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><h2 id="输出">输出</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h2 id="说明">说明</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">对于第一组数据，牛可乐启动炉子时，铸剑炉的温度为 666 度，如果再添一次柴，铸剑炉的温度会达到36度，显然更劣。所以牛可乐只需要初始时添一次柴即可。<br>对于第二组数据，牛可乐启动炉子时，铸剑炉的温度为 222 度，此后每次添柴会使得火炉温度变为：4,8,16,32,⋯。<br></code></pre></td></tr></table></figure></blockquote><h1>题解</h1><p><strong>需要注意到题目的数据有1≦n,m≦10^9， 而$2^32&gt; 10^9$，因此我们只需要遍历32次即可</strong></p><p>此外如何衡量ans是否合适？可以定义一个差值变量，不停的取小并更新ans</p><p>代码实现如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-type">const</span> ll inf=<span class="hljs-number">1e18</span>;<br><span class="hljs-type">int</span> T,n,m;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;T;<br>    <span class="hljs-keyword">while</span>(T--)&#123;<br>        cin&gt;&gt;n&gt;&gt;m;<br>        ll minEps=inf,ans,nowTemp=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">32</span>;i++)&#123;<br>            <span class="hljs-keyword">if</span>(nowTemp&gt;=inf/m) <span class="hljs-keyword">break</span>; <span class="hljs-comment">//如果当前温度*m要比inf大了就break防止溢出</span><br>            nowTemp*=m;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">abs</span>(n-nowTemp)&lt;minEps)&#123;<br>                minEps=<span class="hljs-built_in">abs</span>(n-nowTemp); <span class="hljs-comment">//更新最小差值</span><br>                ans=i;<br>            &#125;<br>        &#125;<br>        cout&lt;&lt;ans&lt;&lt;endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>程设</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>算法</tag>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>P1259 黑白棋子的移动 题解</title>
    <link href="/2025/01/23/%E6%B4%9B%E8%B0%B7P1259%20%E9%BB%91%E7%99%BD%E6%A3%8B%E5%AD%90%E7%9A%84%E7%A7%BB%E5%8A%A8%20%E9%A2%98%E8%A7%A3/"/>
    <url>/2025/01/23/%E6%B4%9B%E8%B0%B7P1259%20%E9%BB%91%E7%99%BD%E6%A3%8B%E5%AD%90%E7%9A%84%E7%A7%BB%E5%8A%A8%20%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<blockquote><h2 id="题目描述">题目描述</h2><p>有 $2n$ 个棋子排成一行，开始为位置白子全部在左边，黑子全部在右边，如下图为 $n=5$ 的情况：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/dzfwand6.png" alt=""></p><p>移动棋子的规则是：每次必须同时移动相邻的两个棋子，颜色不限，可以左移也可以右移到空位上去，但不能调换两个棋子的左右位置。每次移动必须跳过若干个棋子（不能平移），要求最后能移成黑白相间的一行棋子。如 $n=5$ 时，成为：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/yus9ph6d.png" alt=""></p><p>任务：编程打印出移动过程。</p><h2 id="输入格式">输入格式</h2><p>一个整数 $n$。</p><h2 id="输出格式">输出格式</h2><p>若干行，表示初始状态和每次移动的状态，用 $\verb!o!$ 表示白子，$\verb!*!$ 表示黑子，$\verb!-!$ 表示空行。</p><p><strong>Speical Judge</strong></p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">7<br></code></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs markdown">ooooooo<span class="hljs-strong">****</span><span class="hljs-strong">**<span class="hljs-emphasis">*--</span></span><br><span class="hljs-emphasis"><span class="hljs-strong">oooooo--*</span>**</span><span class="hljs-strong">**<span class="hljs-emphasis">*o*</span></span><br><span class="hljs-strong">oooooo**</span><span class="hljs-strong">****</span>--o*<br>ooooo--<span class="hljs-strong">****</span><span class="hljs-emphasis">*o*</span>o*<br>ooooo<span class="hljs-strong">****</span><span class="hljs-emphasis">*--o*</span>o*<br>oooo--<span class="hljs-strong">****</span>o<span class="hljs-emphasis">*o*</span>o*<br>oooo<span class="hljs-strong">****</span>--o<span class="hljs-emphasis">*o*</span>o*<br>ooo--<span class="hljs-strong">**<span class="hljs-emphasis">*o*</span>o<span class="hljs-emphasis">*o*</span>o*</span><br><span class="hljs-strong">ooo<span class="hljs-emphasis">*o*</span><span class="hljs-emphasis">*--*</span>o<span class="hljs-emphasis">*o*</span>o*</span><br><span class="hljs-strong">o--<span class="hljs-emphasis">*o*</span><span class="hljs-emphasis">*oo*</span>o<span class="hljs-emphasis">*o*</span>o*</span><br><span class="hljs-strong">o<span class="hljs-emphasis">*o*</span>o<span class="hljs-emphasis">*--o*</span>o<span class="hljs-emphasis">*o*</span>o*</span><br><span class="hljs-strong">--o<span class="hljs-emphasis">*o*</span>o<span class="hljs-emphasis">*o*</span>o<span class="hljs-emphasis">*o*</span>o<span class="hljs-emphasis">*</span></span><br></code></pre></td></tr></table></figure><h2 id="提示">提示</h2><p>$ 4\leq n\leq 100$</p></blockquote><h1>题解</h1><p>看着似乎没有头绪？我们不妨先按照样例所示的规律来用纸笔画一画</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span> <span class="hljs-number">12</span> <span class="hljs-number">13</span><br>ooooooo*******--<br>oooooo--******o*<br>oooooo******--o*<br>ooooo--*****o*o*<br>ooooo*****--o*o*<br>oooo--****o*o*o*<br>oooo****--o*o*o*<br>ooo--***o*o*o*o*<br>ooo*o**--*o*o*o*<br>o--*o**oo*o*o*o*<br>o*o*o*--o*o*o*o*<br>--o*o*o*o*o*o*o*<br></code></pre></td></tr></table></figure><p>然后再考虑几种简单的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span><br>oooo****--<br>ooo--***o*<br>ooo*o**--*<br>o--*o**oo*<br>o*o*o*--o*<br>--o*o*o*o*<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span><br>ooooo*****--<br>oooo--****o*<br>oooo****--o*<br>ooo--***o*o*<br>ooo*o**--*o*<br>o--*o**oo*o*<br>o*o*o*--o*o*<br>--o*o*o*o*o*<br></code></pre></td></tr></table></figure><p>这个时候我们可以注意到如下几个细节：</p><ol><li><p>最后5行的规律总是相同的：即</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">ooo--***o*<br>ooo*o**--*<br>o--*o**oo*<br>o*o*o*--o*<br>--o*o*o*o*<br></code></pre></td></tr></table></figure><p>再在末尾跟上n-4个&quot;o*&quot;</p></li><li><p>前面部分的移动规律：考虑i从第n个开始，交换i和i+i+1的位置，交换i-1和i-1+i+1的位置，输出改变之后的字符串；然后再交换i和i+i-1的位置，交换i-1和i-1+i-1的位置，再输出</p><p>(这样的规律是如何发现的？可以多写出来诸如这样的部分</p><table><thead><tr><th>开始(n=7时)</th><th>第一次交换的下标</th><th>第二次交换的下标</th></tr></thead><tbody><tr><td>i=7</td><td>15</td><td>13</td></tr><tr><td>i-1=6</td><td>14</td><td>12</td></tr><tr><td>i=6</td><td>13</td><td>11</td></tr><tr><td>i-1=5</td><td>12</td><td>10</td></tr><tr><td>i=5</td><td>11</td><td>9</td></tr><tr><td>i-1=4</td><td>10</td><td>8</td></tr><tr><td>差值</td><td>i+1</td><td>i-1</td></tr></tbody></table><p>得到差值之后也就轻松了。</p><p>)</p><p>这样的移动操作总共需要进行n-4次，也就是i从n遍历到5即可</p><p>（为什么是n-4次？也可以从最后的角度考虑，我们要创造出n-4个&quot;o*&quot;，而每进行一次这样的操作就是会多一个&quot;o*&quot;的结构</p></li></ol><p>于是我们就可以进行代码实现了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">move</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>    string s;<br>    <span class="hljs-comment">//初始化</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        s.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;o&#x27;</span>);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n;i&lt;<span class="hljs-number">2</span>*n;i++)&#123;<br>        s.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;*&#x27;</span>);<br>    &#125;<br>    s.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;-&#x27;</span>);<br>    s.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;-&#x27;</span>);<br>    cout&lt;&lt;s&lt;&lt;endl;<br>    <span class="hljs-comment">//进行改变</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n;i&gt;=<span class="hljs-number">5</span>;i--)&#123;<br>        <span class="hljs-built_in">swap</span>(s[i],s[<span class="hljs-number">2</span>*i<span class="hljs-number">+1</span>]);<br>        <span class="hljs-built_in">swap</span>(s[i<span class="hljs-number">-1</span>],s[<span class="hljs-number">2</span>*i]);<br>        cout&lt;&lt;s&lt;&lt;endl;<br>        <span class="hljs-built_in">swap</span>(s[i],s[<span class="hljs-number">2</span>*i<span class="hljs-number">-1</span>]);<br>        <span class="hljs-built_in">swap</span>(s[i<span class="hljs-number">-1</span>],s[<span class="hljs-number">2</span>*i<span class="hljs-number">-2</span>]);<br>        cout&lt;&lt;s&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-comment">//定义尾部字符串</span><br>    string s0;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">2</span>*(n<span class="hljs-number">-4</span>);i+=<span class="hljs-number">2</span>)&#123;<br>        s<span class="hljs-number">0.</span><span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;o&#x27;</span>);<br>s<span class="hljs-number">0.</span><span class="hljs-built_in">push_back</span>(<span class="hljs-string">&#x27;*&#x27;</span>);<br>    &#125;<br>    cout&lt;&lt;<span class="hljs-string">&quot;ooo--***o*&quot;</span>&lt;&lt;s0&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-string">&quot;ooo*o**--*&quot;</span>&lt;&lt;s0&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-string">&quot;o--*o**oo*&quot;</span>&lt;&lt;s0&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-string">&quot;o*o*o*--o*&quot;</span>&lt;&lt;s0&lt;&lt;endl;<br>    cout&lt;&lt;<span class="hljs-string">&quot;--o*o*o*o*&quot;</span>&lt;&lt;s0;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-built_in">move</span>(n);<br>&#125;<br></code></pre></td></tr></table></figure><p>还有一个需要注意的点</p><p>这样去初始化字符串</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">2</span>*(n<span class="hljs-number">-4</span>);i+=<span class="hljs-number">2</span>)&#123;<br>    s0[i]=<span class="hljs-string">&#x27;o&#x27;</span>;<br>    s0[i<span class="hljs-number">+1</span>]=<span class="hljs-string">&#x27;*&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>是不可以的。因为直接通过下标访问一个空字符串的字符是未定义行为（undefined behavior），这可能导致程序崩溃或没有任何输出。</p><p>正确做法：统一使用push_back()函数。</p>]]></content>
    
    
    <categories>
      
      <category>程设</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>算法</tag>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>P3612 [USACO17JAN] Secret Cow Code S题解</title>
    <link href="/2025/01/23/P3612%20%5BUSACO17JAN%5D%20Secret%20Cow%20Code%20S%E9%A2%98%E8%A7%A3/"/>
    <url>/2025/01/23/P3612%20%5BUSACO17JAN%5D%20Secret%20Cow%20Code%20S%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>洛谷一道比较有意思的题目</p><blockquote><h1>P3612 [USACO17JAN] Secret Cow Code S</h1><h2 id="题面翻译">题面翻译</h2><p>奶牛正在试验秘密代码，并设计了一种方法来创建一个无限长的字符串作为其代码的一部分使用。</p><p>给定一个字符串，对字符串进行一次操作（每一次正确的操作，最后一个字符都会成为新的第一个字符），然后把操作后的字符串放到操作前的字符串的后面。也就是说，给定一个初始字符串，之后的每一步都会增加当前字符串的长度。</p><p>给定初始字符串和 $N$，请帮助奶牛计算无限字符串中位置为 $N$ 的字符。</p><p>第一行输入一个字符串。该字符串包含最多 $30$ 个大写字母，数据保证 $N \leq 10^{18}$。</p><p>第二行输入 一个整数 $N$。请注意，数据可能很大，放进一个标准的 $32$ 位整数容器可能不够，所以你可能要使用一个 $64$ 位的整数容器（例如，在 C/C++ 中是 <code>long long</code>）。</p><p>请输出从初始字符串生成的无限字符串中的下标为 $N$ 的字符。第一个字符的下标是 $N=1$。</p><p>感谢 @y_z_h 的翻译</p><h2 id="题目描述">题目描述</h2><p>The cows are experimenting with secret codes, and have devised a method for creating an infinite-length string to be used as part of one of their codes.</p><p>Given a string $s$, let $F(s)$ be $s$ followed by $s$ “rotated” one character to the right (in a right rotation, the last character of $s$ rotates around and becomes the new first character). Given an initial string $s$, the cows build their infinite-length code string by repeatedly applying $F$; each step therefore doubles the length of the current string.</p><p>Given the initial string and an index $N$, please help the cows compute the character at the $N$th position within the infinite code string.</p><h2 id="输入格式">输入格式</h2><p>The input consists of a single line containing a string followed by $N$. The string consists of at most 30 uppercase characters, and $N \leq 10^{18}$.</p><p>Note that $N$ may be too large to fit into a standard 32-bit integer, so you may want to use a 64-bit integer type (e.g., a “long long” in C/C++).</p><h2 id="输出格式">输出格式</h2><p>Please output the $N$th character of the infinite code built from the initial string. The first character is $N=1$.</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">COW</span> <span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">C</span><br></code></pre></td></tr></table></figure><h2 id="提示">提示</h2><p>In this example, the initial string COW expands as follows:</p><p>COW -&gt; COWWCO -&gt; COWWCOOCOWWC</p><p>12345678</p></blockquote><h1>题解</h1><p>直接暴力模拟会MLE，所以我们必须要考虑规律。</p><p>设最开始，即原字符串的长度为$len$</p><p>不难注意到，假设我们把一个字符串分割成A+B的部分，其中B是最后一个字符，那么经过一次操作之后，我们就会得到A+B+B+A的形式。</p><p>我们设某一时刻字符串的长度已经扩增到了$l$，且位置n恰好处于$l$的后半部分，也即这个时候的$l$恰好”扩增到了能够让s[n-1]有意义的情况“。</p><p>考虑第n个字符处于后半部分的A的情况，这个时候根据对称性我们不难发现n处的字符==n-$l$/2-1处的字符。</p><p>考虑第n个字符处于后半部分的B的情况，那么根据对称性我们可以把n倒推回n-1。</p><p>这样我们成功分治，把原问题转化成了多个子问题。</p><p>现在我们就可以让n不断地减小，直到$len$≥n的时候，就可以直接输出了。</p><p>也即使用一个while(len&lt;n)的循环即可</p><p>代码实现如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br>ll n,l;<br>string s;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;s&gt;&gt;n;<br>    <span class="hljs-type">int</span> len=s.<span class="hljs-built_in">length</span>();<br>    <span class="hljs-comment">//我们画个图可以发现，当字符串的长度l恰好递增到我们可以求出n的时候，有n处的字符与n-l/2-1处的相同</span><br>    <span class="hljs-comment">//并且n-l/2-1恰好就在len的范围之内</span><br>    <span class="hljs-comment">//如何实现将n不断往回倒成n-l/2-1？</span><br>    <span class="hljs-comment">//还需要特判，当n正好卡在中间的时候，也即n=l/2+1时，n往回倒成n-1（因为中间两个相同）</span><br><br>    <span class="hljs-comment">//我们需要的是一直往回倒，能倒到直接在最开始的字符串里面求出来</span><br>    <span class="hljs-comment">//也就是说，我们需要先把l求到</span><br>    <span class="hljs-comment">//然后这个时候的n-l/2-1可以保证一定是在开始的len范围之内的</span><br>    <span class="hljs-keyword">while</span>(len&lt;n)&#123;<span class="hljs-comment">//假设字符串的长度不够,n开始就超标使得我们无法直接求出</span><br>        l=len; <span class="hljs-comment">//l表示当前的字符串长度，这里开始递增</span><br>        <span class="hljs-keyword">while</span>(n&gt;l) l*=<span class="hljs-number">2</span>;<span class="hljs-comment">//当字符串的长度还不够整个包住n的时候，就一直翻倍</span><br>        <span class="hljs-comment">//上面的循环结束的时候，就是恰好能够包住n了（k&gt;=n）</span><br>        <span class="hljs-comment">//依据上面的思路，我们需要n-l/2-1</span><br>        n-=l/<span class="hljs-number">2</span><span class="hljs-number">+1</span>; <span class="hljs-comment">//这样就实现了迭代，n在不断地减小，通过外层的while循环可以反复倒回去</span><br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>) n=l/<span class="hljs-number">2</span>; <span class="hljs-comment">//即n=l/2+1时，n往回倒成n-1</span><br>    &#125;<br>    cout&lt;&lt;s[n<span class="hljs-number">-1</span>];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>程设</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>算法</tag>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>德语写作顺承关系词使用</title>
    <link href="/2025/01/07/%E4%BD%BF%E7%94%A8%E9%A1%BA%E6%89%BF%E5%85%B3%E7%B3%BB%E8%AF%8D/"/>
    <url>/2025/01/07/%E4%BD%BF%E7%94%A8%E9%A1%BA%E6%89%BF%E5%85%B3%E7%B3%BB%E8%AF%8D/</url>
    
    <content type="html"><![CDATA[<p>要写出流畅的过渡句，可以使用以下策略和句型来连接不同的段落或主题：</p><hr><h3 id="1-使用顺承关系词：继续谈论相关主题"><strong>1. 使用顺承关系词：继续谈论相关主题</strong></h3><p>这些词语可以帮助自然地引出下一个话题：</p><ul><li><strong>Außerdem</strong> (此外)</li><li><strong>Danach</strong> (之后)</li><li><strong>Dann</strong> (然后)</li><li><strong>Weiterhin</strong> (进一步地)</li><li><strong>Zudem</strong> (此外)</li></ul><p><strong>示例：</strong></p><ol><li><strong>Einleitung nach der Begrüßung:</strong><br><em>Ich freue mich sehr, dass du bald nach Shanghai kommst. Sicher hast du viele Fragen und ich helfe dir gern.</em></li><li><strong>Von Thema 1 zu Thema 2:</strong><br><em>Außerdem gibt es in Shanghai viele Möglichkeiten, die Freizeit zu genießen.</em></li></ol><hr><h3 id="2-使用因果关系词：解释理由或结果"><strong>2. 使用因果关系词：解释理由或结果</strong></h3><ul><li><strong>Deshalb</strong> (因此)</li><li><strong>Darum</strong> (所以)</li><li><strong>Aus diesem Grund</strong> (出于这个原因)</li><li><strong>Weil</strong> (因为)</li></ul><p><strong>示例：</strong></p><ol><li><strong>Von Thema 2 zu Thema 3:</strong><br><em>Weil viele junge Menschen gerne in Parks oder Cafés Zeit verbringen, kannst du dort leicht neue Kontakte knüpfen.</em></li></ol><hr><h3 id="3-使用对比关系词：强调不同或相似之处"><strong>3. 使用对比关系词：强调不同或相似之处</strong></h3><ul><li><strong>Einerseits … andererseits …</strong> (一方面……另一方面……)</li><li><strong>Im Gegensatz dazu</strong> (与此相反)</li><li><strong>Während</strong> (然而)</li></ul><p><strong>示例：</strong></p><ol><li><strong>Von Thema 3 zu Thema 4:</strong><br><em>Während die Stadt viele Aktivitäten bietet, gibt es auch schöne Orte außerhalb von Shanghai für einen Wochenendausflug.</em></li></ol><hr><h3 id="4-使用总结和强调的表达"><strong>4. 使用总结和强调的表达</strong></h3><ul><li><strong>Zusammenfassend kann man sagen, dass…</strong> (总结来说，可以说……)</li><li><strong>Zum Schluss möchte ich sagen, dass…</strong> (最后，我想说……)</li><li><strong>Ich hoffe, dass diese Informationen hilfreich für dich sind.</strong> (我希望这些信息对你有帮助。)</li></ul><hr><h3 id="具体应用示例："><strong>具体应用示例：</strong></h3><p><strong>Übergang von Thema 1 zu Thema 2:</strong><br><em>Nachdem du den besten Weg zur Arbeit gefunden hast, kannst du dich auf die Freizeitaktivitäten konzentrieren.</em></p><p><strong>Übergang von Thema 2 zu Thema 3:</strong><br><em>Wenn du deine Freizeit genießt, wirst du sicher auch neue Leute kennenlernen wollen.</em></p><p><strong>Übergang von Thema 3 zu Thema 4:</strong><br><em>Wenn du neue Kontakte geknüpft hast, kannst du mit ihnen auch Ausflüge am Wochenende planen.</em></p><hr><p>这些句子和技巧可以帮助你的作文结构更加连贯和自然！需要进一步的例子或帮助，可以继续讨论。</p>]]></content>
    
    
    <categories>
      
      <category>德语</category>
      
    </categories>
    
    
    <tags>
      
      <tag>德语</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>德语大一上期末写作范例</title>
    <link href="/2025/01/07/%E5%86%99%E4%BD%9C%E7%AC%94%E8%AE%B0%E5%A4%A7%E4%B8%80%E4%B8%8A%E6%9C%9F%E6%9C%AB/"/>
    <url>/2025/01/07/%E5%86%99%E4%BD%9C%E7%AC%94%E8%AE%B0%E5%A4%A7%E4%B8%80%E4%B8%8A%E6%9C%9F%E6%9C%AB/</url>
    
    <content type="html"><![CDATA[<p>Lieber Anna,</p><p>wie geht es Dir? Wir haben uns lange nicht mehr gesehen.</p><p>Komm doch mal in Wien! Du bist herzlich eingeladen. Ich könnte eine kleine Stadtführung durch die Altstadt für Dich gehen und anschließend können wir uns Schloss Schönbrunn schauen. Und Du kannst unbedingt mit mir in mein Lieblingskaffehaus gehen. Hast Du auch Lust auf ein Museum? In Wien gibt es sehr viele bekannte Museums und Ausstellungen.</p><p>Und natürlich kannst Du hier in Wien die berühmte Sachertorte probieren oder Apfelstrudel- der schmeckt nirgends so lecker wie bei uns! Bitte komm! Ich freue mich sehr über Dich!</p><p>Viele Grüßen</p><p>Mila</p><p>Liebe Sabrina,</p><p>wie geht es dir? Wie schön, dass du in dein Sommerferien einen Sprachkurs in Spanien machen möchtest!  Ich finde die Idee super, weil du nicht nur Spanisch lernen, sondern auch die spanische Kultur und das Leben dort erleben kannst.</p><p>Spanisch in Spanien zu lernen hat viele Vorteile. Zum Beispiel kannst du jeden Tag mit Einheimischen sprechen. So lernst du die Sprache viel schneller und verbesserst dabei deine Aussprache. Es ist wunderbar, die Ferien in Spanien zu verbringen, weil das Land sehr schön ist. Es gibt dort freundliche Leute und leckeres Essen. Besonders in der Sonne am Strand kann man die Zeit sehr genießen.</p><p>Auf die Reise musst du dich gut vorbereiten. Zuerst sollest du ein Flugticket und eine Unterkunft(z.B. ein Hotel) buchen. Außerdem brauchst du einen gültigen Reisepass. Um dich dort besser verständigen zu können, könntest du auch ein bisschen Spanisch vor der Abreise lernen.</p><p>Deshalb mächte ich gerne mitkommen. Es macht mehr Spaß, wenn wir zusammen reisen. Vielleicht können wir am Nachmittag nach dem Sprachkurs gemeinsam die Stadt erkunden.</p><p>Ich freue mich auf dich!</p><p>Viele Grüßen</p><p>Mila</p><p>Lieber Lukas,</p><p>vielen Dank für deinen Brief! Wie geht es dir?</p><p>Du fragst, wie man am besten zur Arbeit pendeln kann. Ich glaube, U-Bahn ist am schnellsten und am billigsten. Eine Taxifahrt ist sehr teuer, und mit dem Bus zu fahren kostet oft viel Zeit.</p><p>Es gibt große Unterschiede in den Freizeitbeschäftigungen zwischen deutschen und chinesischen jungen Leute. In Deutschland wandern sie gern in der Natur, während junge Leute in Shanghai den “Citywalk” bevorzugen und gern die Stadt erkundet.</p><p>Ich glaube, du willst neue Leute kennenlernen. Dann kannst du dich bei einem Verein oder einem Club anmelden. Am Wochenende möchtest du einen Ausflug machen? Du kannst an den Dishui See gehen, die Landschaft dort ist sehr schön. Trotz der Entfernung ist Suzhou auch ein gutes Ziel, denn die kleine Stadt ist bekannt für ihre wunderschönen Gärten.</p><p>Ich hoffe, dass meine Tipps dir weiter helfen. Schreib mir doch bald. Ich warte auf deine Email!</p><p>Liebe Grüße</p><p>A</p><p>Liebe Lukas,</p><p>schön, dann du bald ein Praktikum in Shanghai machst. Ich freue mich schon darauf.</p><p>Du fragst,  wie man am besten zur Arbeit pendeln kann. Ich denke, normalweise nimmt man das Bus oder die U-Bahn. Wenn die Strecke nicht zu lang ist, kann man auch mit dem Fahrrad fahren.</p><p>Du wolltest auch wissen, was junge Leute in Shanghai gern in der Freizeit machen und wo man Kontakt zu ihnen finden kann. Tja, das Leben junger Menschen hier ist eigentlich gar nichts so anders als deines. Oft machen wir mit einigen Freunden einen Spaziergang durch die Stadt, trinken Kaffee und unterhalten uns. Wir gehen auch gern ins Kino oder Theater. Du kannst dort viele junge Leute kennenlernen.</p><p>Also, in Shanghai gibt es wirklich viele Möglichkeiten, Spaß zu haben. Du kannst einfach das machen, worauf du Lust hast. Ich empfehle dir, dass du am Wochenende zum Ausflug auf Chongming Insel fährst, denn es gibt dort wunderschöne Landschaft.</p><p>Antworte mir bitte bald.</p><p>Liebe Grüße</p><p>Liebe Lisa,</p><p>vielen Dank für deinen Brief. Ich habe mich sehr darüber gefreut.</p><p>Du fragst, dass wie man am besten eine Unterkunft finden kann. Ich bin der Meinung, dass im Stadtzentrum zu wohnen am besten ist, weil alles dort in der Nähe ist.</p><p>Auch willst du die Sehenswürdigkeiten in Peking wissen. Tja, das hängt von deinem Interesse ab. Wenn du dich für die Kultur und Geschichte interesiert, der Tiananmen Platz und die Verbotene Stadt sind besonders sehenswert. Aber wenn du die schöne Landschaft besichtigen möchtest, die Große Mauer ist auch sehr gut.</p><p>Außerdem sind die Gerichte in Peking sehr lecker. Du sollst die Peking-Ente probieren. Sie schmeckt dir unbedingt gut.</p><p>Übrigens ist das Wetter im Sommer in Peking sehr warm. Du musst viele T-Shirts mitbringen.</p><p>Ich hoffe, dass meine Tipps dir weiter helfen. Schreib mir doch bald. Ich warte auf deine Email!</p><p>Liebe Grüße</p><p>Wen Daining.</p>]]></content>
    
    
    <categories>
      
      <category>德语</category>
      
    </categories>
    
    
    <tags>
      
      <tag>德语</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大物期末上复习</title>
    <link href="/2025/01/07/%E5%A4%A7%E7%89%A9%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2025/01/07/%E5%A4%A7%E7%89%A9%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="机械能部分">机械能部分</h2><p>机械能守恒定律：系统只有保守内力做功，质点系的总机械能保持不变</p><p><strong>机械能包括动能和势能（如电势能）</strong></p><p>等价表述：质点组机械能的改变与保守内力无关</p><p>所受合外力为零，内力都是保守力的系统，其机械能必然守恒 <strong>错误</strong></p><p>首先：合外力为零<strong>≠</strong>外力做功为零，考虑两只手拉弹簧即可</p><p>其次：即使合外力为零，系统仍可能受到<strong>外力矩</strong>的作用，外力矩会改变系统的转动动能，从而影响机械能，例如一个刚体在无摩擦的转轴上旋转时，即使合外力为零，外力矩仍可能做功，改变系统的机械能</p><p>König定理<br>$$<br>质点系的总动能=质心对惯性系的动能+各个质点相对于质心的动能<br>\E_k=\frac{1}{2}Mv_c^2+E’k=\frac{1}{2}Mv^2_c+\frac{1}{2} \sum_{i=1}^{n}m_iv^2_{ir}<br>$$</p><h2 id="刚体">刚体</h2><p>平行轴定理：<br>$$<br>对某一轴的转动惯量=对质心轴的转动惯量+m*(质心到某轴的距离)^2 \<br>J_o=J_c+md^2<br>$$</p><h2 id="振动">振动</h2><p>简谐运动的三个特征</p><ul><li><p>力学特征<br>$$<br>F=-kx<br>$$</p></li><li><p>动力学特征<br>$$<br>\frac{d^2x}{dt^2}+\omega x=0<br>$$</p></li><li><p>运动学特征<br>$$<br>x=A\cos (\omega x + \phi)<br>$$</p></li></ul><p>合振动忽强忽弱（振幅忽大忽小）的现象：拍</p><p>拍频：合振动变化的频率</p><h2 id="波">波</h2><h3 id="波的方程">波的方程</h3><p>$$<br>y(x,t)=A\cos[2\pi(\frac{t}{T} \mp \frac{x-x_0}{λ})+φ_0] \<br>取减号：波沿x轴正向传播，反之 \<br>x处的质元比O处的相位落后 \frac{2 \pi x}{λ}<br>$$</p><h3 id="波的能量：">波的能量：</h3><p>在波动过程中任一质元的动能和势能相等且同相位变化，机械能不守恒（因为不是孤立体系）</p><p>能量密度<br>$$<br>\omega = \frac{dE}{dV} = \rho A^2\sin^2\omega(t-\frac{x}{u})<br>$$<br>平均能量密度<br>$$<br>\bar \omega = \frac{1}{2}\rho A^2\omega^2<br>$$<br>能流<br>$$<br>P=\omega u S<br>$$<br>平均能流<br>$$<br>\bar P =\bar \omega u S<br>$$<br>平均能流密度<br>$$<br>I=\frac{\bar P}{S}=\bar \omega u =\frac{1}{2}\rho A^2\omega^2 u<br>$$</p><h3 id="驻波的能量">驻波的能量</h3><p>波节处始终有Ek=0</p><p>在同段内各点通过平衡位置时，动能均最大，波节及其他点Ep=0</p><p>在同段内各点通过最大位移时，动能均趋零，波节及其他点Ep最大</p><h2 id="热力学">热力学</h2><p>等值过程<strong>不一定</strong>是可逆过程，准静态过程<strong>不一定</strong>是可逆过程，<strong>可逆过程一定是准静态过程</strong>，</p>]]></content>
    
    
    <categories>
      
      <category>物理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大学物理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>德语大一上期末复习</title>
    <link href="/2025/01/07/%E5%A4%A7%E4%B8%80%E4%B8%8A%E6%9C%9F%E6%9C%AB%E8%AF%BE%E6%9C%AC%E5%A4%8D%E4%B9%A0/"/>
    <url>/2025/01/07/%E5%A4%A7%E4%B8%80%E4%B8%8A%E6%9C%9F%E6%9C%AB%E8%AF%BE%E6%9C%AC%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1>Lek15-18</h1><ul><li><p>sich anmelden zu etw 报名，登记</p></li><li><p>sich entschuldigen bei jm. für A</p></li><li><p>sich erkundigen bei jm nach etw</p></li><li><p><strong>bei jm für etw</strong> 和 <strong>bei jm nach etw</strong> 是两个很常见的结构，至于到底是für还是nach可以看语义的</p></li><li><p>sich langweilen mit D</p></li><li><p>sich etwas vorstellen 想象</p></li><li><p>sich beeilen 赶时间</p></li><li><p>sich bewerben um etw 申请（有竞争的意味）</p></li><li><p>sich umsehen 到处看</p></li><li><p>sich vergnügen 娱乐</p></li><li><p>问路:Wie komme ich nach…</p></li><li><p>das Turnier 比赛、竞赛</p></li><li><p>die Sporthalle 体育馆</p></li><li><p>an etwas teilnehmen 参加</p></li><li><p>wählen zwischen D 从…中选择</p></li><li><p>sonst 否则</p></li><li><p>entwerten 激活</p></li><li><p>Grenze 边界</p></li><li><p>je nach D 视…而定 = Das hängt von … ab</p></li><li><p>Entfernung 距离</p></li><li><p>der Laden 店铺</p></li><li><p>Ich gehe einfach weiter. 我干脆继续走了</p></li><li><p>Ich fahre <strong>erleichtert</strong> nach Hause. 一身轻松地</p></li><li><p>regelten 用某种规章制度来管理</p></li><li><p>begleiteten A 陪伴</p></li><li><p>z.B. Sondern begleitete mich auch noch ein Stück. <strong>ein Stück 一段路</strong></p></li><li><p>die Umwelt 环境-  umweltfreundlich 环保的</p></li><li><p>die Leistungen 成绩</p></li><li><p>der Vortrag halten 开讲座</p></li><li><p>das Referat 课堂报告</p></li><li><p>gilt als = (in Englisch)works as, functions as…</p></li><li><p>sich anmelden/einschreiben 报到</p></li><li><p>das Turnen 体操</p></li><li><p>die Leichtathletik 田径</p></li><li><ul><li>laufen 跑</li><li>springen 跑</li><li>joggen</li></ul></li><li><p>Es gibt grundlegende Unterschiede 这存在根本上的区别</p></li><li><p>halten den Schläger wie Essstäbchen/Messer und Gabel</p></li><li><p>regagieren A 对…做出反应</p></li><li><p>aus Spaß spielen 处于乐趣来玩</p></li><li><p>为什么年轻人喜欢极限运动？ -Viele junge Menschen treiben diesen Sport wegen der Gefahr und Spannung.</p></li><li><p>课文金句 Die körplicher Bewegung ist eine nötige Abwechslung in einer Technisierten Welt.</p></li><li><p>dynamisch-abwechslungsreich 动态的、有活力的</p></li><li><p>Sport macht Spaß und bietet Spannung.</p></li><li><p>im Fernsehen übertragen 在电视转播</p></li><li><p>Im Stadion ist es viel spannender, die Menschen, die Jubel, die ganze Atmosphäre.</p></li><li><p>Angst vor etwas haben</p></li><li><p>描述一个休闲、爱好 ein guter <strong>Ausgleich</strong> zur Arbeit und zum Stress <strong>平衡、调剂</strong></p></li><li><p>sich entwickeln 发展</p></li><li><p>entwickeln 开发、发明</p></li><li><p>Es fällt mir auf, … 我注意到</p></li><li><p>Es hängt davon ab, … 这取决于…</p></li><li><p>einsam 孤独的</p></li><li><p>traurig 悲伤的</p></li><li><p>erfahren-wissen</p></li><li><p>suchen-finden</p></li><li><p>finden-<strong>feststellen</strong> (得出结论 瞬间的)</p></li><li><p>der Lebensstteil bewusst wählen 有意选择生活方式</p></li><li><p>(sich) Zeit nehmen für A 抽出时间干…</p></li><li><p>schaffen</p></li><li><ul><li>geschaffen 创作</li><li>geschafft 搞定</li></ul></li><li><p>überfallen 抢劫</p></li><li><p>转折</p></li><li><ul><li>obwohl (先行词)</li><li>trotzdem (adv.)</li><li>trotz G (präp.)</li></ul></li><li><p>Ich habe keine Ahnung davon.</p></li><li><p>zugleich 同时</p></li><li><p>mit</p></li><li><ul><li>jm umgehen 与某人周旋</li><li>etw umgehen 搞定某事</li></ul></li><li><p>vielleicht=wahrscheinlich</p></li><li><p>immerhin=wiesowie 反正</p></li><li><p>losgehen 动身</p></li><li><p>Darüber hinaus= außerdem</p></li><li><p>Es ist allen bekannt, dass…</p></li><li><p>die Pflicht 义务</p></li><li><p>raten zu 劝告</p></li><li><p>versuchen 计划去做</p></li><li><p>versprechen D A 承诺</p></li><li><p>sich gewöhnen an… 使习惯于</p></li><li><p>Er ist erlaubt/verboten, …</p></li><li><p>gut ausgebildet 受良好教育的</p></li><li><p>hoch qualifizerte = highly qualified</p></li><li><p>Die Eltern schicken ihre Kinder gern an die berühmten Hochschulen, damit sie eine gute Ausbildung bekommen.</p></li><li><p>Häusliche Erziehung ist sehr wichtig für die Entwicklung der Kinder.</p></li><li><p>Seine Hauptaufgabe <strong>besteht darin</strong>, die Lehrlinge auszubilden. 在于…</p></li><li><p>führen zu = leads to评价？</p></li><li><p>der Verhalten 行为举止</p></li><li><p>Freizeit bedeutet: Zeit ohne Pflichten</p></li><li><p>Sie wollen am Ende ihres Lebens das Rechts aus Ruhe und Freiheit genießen.</p></li><li><p>Obwohl er sehr beschäftigt ist, … 尽管他很忙，…</p></li><li><p>sogenannte 所谓的</p></li><li><p>die Freude 令人开心的事情</p></li><li><p>三个“发生”</p></li><li><ul><li>passiert sein</li><li>geschehen- geschieht (sein)</li><li>vorkommen</li></ul></li><li><p>z.B. Wann die Freude passiert sein…</p></li><li><p>sich die Belastbung leisten 承受压力</p></li><li><p>streng planmäßig leben 过有规律的生活</p></li><li><p>Genussmittel 用以享受的物品</p></li><li><p>sich Wohl fühlen, bequem sein 感到舒适</p></li><li><p>mit A einverstanden sein 同意A</p></li><li><p>sich die Wettkämpfe anschauen 看比赛</p></li></ul><hr><h2 id="连词">连词</h2><p><strong>und aber oder denn(因为) sondern</strong>(而是)</p><p>后加正语序，全部都不占位</p><p><strong>entweder(占)…oder(不占)… 要么要么</strong></p><p><strong>nicht nur…sondern auch… 不仅而且</strong> nicht nur作为一个整体当成nicht/kein来放</p><p><strong>weder(占)…noch(占)…既不也不</strong></p><ul><li><strong>一般加零冠词</strong></li><li>z.B. Weder fahre ich mit dem Bus, noch gehe ich zu Fuß.</li></ul><p><strong>sowohl(不占)…als auch(不占)…既又</strong></p><p><strong>zwar(占)…aber(不占)…虽然但是</strong></p><p><strong>deshalb(占位)(不加从句) 所以</strong></p><p><strong>denn 因为 (不占位)， dann 那么 (占位)</strong></p><p>总结一下：da weil denn deshalb wegen 与因果关系有关</p><hr><h2 id="从句">从句</h2><h3 id="dass-ob">dass-ob</h3><p>Ich weiß (es), dass …<strong>es一定要省略</strong></p><h3 id="weil-da-原因状语从句">weil/da 原因状语从句</h3><p><strong>da：只在原因非常明显时在句首使用</strong></p><h3 id="wenn-falls-条件状语从句">wenn/falls 条件状语从句</h3><p><strong>类似原因状语从句，Falls只能在句首</strong></p><h3 id="让步状语从句-obwohl-尽管">让步状语从句 obwohl 尽管</h3><hr><h2 id="二格">二格</h2><p>ein der größte Stadt in China<br>​=one (of) the largest city in China.</p><p>人名：-s -x -z -ß 结尾的，直接打 **’ **即可</p><hr><h2 id="二格的介词">二格的介词</h2><p><strong>trotz wegen während statt</strong></p><p>während des Aufenthalt in Deutschland 在留德期间</p><hr><h1>Lek 14</h1><ul><li><p>das Geschirr 厨具</p></li><li><p>der Inhalt 内容</p></li><li><p>Das fällt mir ein, … <strong>einfallen使想起</strong></p></li><li><p>Das Wort bestellt aus zwei Teilen.</p></li><li><p>Erst nach meinem Tod bemerkten die Menschen meinen Irrtum.</p></li><li><p>Dann verschieben wir das Theater auf übernächste Woche.</p></li><li><ul><li><strong>动词“verschieben”表示变动</strong>，涉及时间的变化，因此 <strong>auf 后面接第四格</strong></li><li>推迟到某一时间用auf</li></ul></li><li><p>Es geht mir viel besser <strong>als am Anfang</strong>. <strong>als做时间状语</strong></p></li><li><p>das Möbel 家具 - möbliert pII 有家具的</p></li><li><p>Vorteil - Nachteil</p></li><li><p>… ist nicht besonders gut, aber schlecht ist es auch nicht.</p></li><li><p>die Auswahl 选择范围（抽象概念）</p></li><li><p>allgemein 一般的</p></li><li><p>Ich möchte dir gerne mein Zimmer zeigen. Wann kommst du mich besuchen? Hoffentlich bis bald!</p></li><li><p>经常用过去时的时间状语：</p></li><li><ul><li>früher</li><li>vor drei Jahren</li></ul></li><li><p>die Suppe essen</p></li><li><p>schlürfen 发出响声地啜饮</p></li><li><p>ausschlürfen 咕咚咕咚地喝水</p></li><li><p>schmatzen 吃饭吧唧嘴</p></li><li><p>spucken 吐</p></li><li><p>der Befehl 命令，指令</p></li><li><p>vorsichtig 小心的</p></li><li><p>aus/zu machen 开/关</p></li><li><p>im Krankenhaus liegen 住院</p></li><li><p>Ich soll dich sehr herzlich von Herrn Müller grüßen. 我应该代Herr Müller向你问好 <strong>注意Herr是阳性弱变化名词</strong></p></li><li><p>Anschließend 紧接着</p></li><li><p>Wo <strong>liegt</strong> mein <strong>Brille</strong>? 眼镜在哪 用liegen</p></li><li><p>Ich war noch nicht da. 我还从来没去过那</p></li></ul><hr><h1>Lek 13</h1><ul><li><ul><li>die Zukunft 未来</li><li>die Vergangenheit 过去</li><li>die Gegenwart 现在</li></ul></li><li>verwirrt 迷惘的、糊涂的</li><li>hübsch 漂亮的 可爱的</li><li>Er <strong>fiel</strong> sicher <strong>auf</strong> wie <strong>ein bunter Hund</strong>. 他肯定很引人注目</li><li><ul><li>auffallen- auffiel 引人注目</li><li>短语**„auffallen wie ein bunter Hund“**是德语中的一种俗语，比喻某人或某物特别引人注意，就像一只五颜六色的狗在人群中显得格外突出一样</li></ul></li><li>Die Münchner <strong>aßen</strong> <strong>selten</strong> Reis.</li><li><ul><li>aßen - essen的过去式</li><li>selten = (in English) seldom</li></ul></li><li>überraschen 使感到意外 - pII überrascht 感到意外的</li><li>das Schloss 城堡</li><li>der Stadtbummel = citywalk</li><li>die Abkürzung für A   …的缩写</li></ul><hr><h1>Lek 12</h1><ul><li>der Herd 灶</li><li>der Backofen 烤箱</li></ul><p>das Appartement/EInzelzimmer 一室一厅</p><p>玄关：</p><ul><li>die Flur 强调走廊</li><li>die Diele 强调门厅</li></ul><p>vermieten 出租 - mieten 租</p><p>nach+方向</p><ul><li>nach Osten</li><li>nach Süden</li><li>nach Westen</li><li>nach Norden</li><li>nach oben (adv.)</li><li>nach unten (adv.)</li></ul><p>das Haushaltsgeräte 家用电器</p><p>der Sessel 沙发椅</p><p>die Waschmaschine</p><p>das Bücherregal</p><p>die Pflanze 绿植</p><p>der Teppich 地毯</p><p>Besonders für Ausländer ist eine WG sehr <strong>günstig</strong>(有利的). Sie haben Kontakt zu ihren Mitbewohnern und bei Fragen oder Problemen können die Mitbewohner helfen. Natürlich muss jeder Mitbewohner auf die anderen Rücksicht nehmen.</p><p>EIn Zimmer zur Untermiete bedeutet: Ein Student mietet ein Zimmer in einer Wohnung.</p><p>zufrieden 满意的</p>]]></content>
    
    
    <categories>
      
      <category>德语</category>
      
    </categories>
    
    
    <tags>
      
      <tag>德语</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>德语学习经验分享会</title>
    <link href="/2024/11/26/%E5%BE%B7%E8%AF%AD%E5%AD%A6%E4%B9%A0%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB%E4%BC%9A/"/>
    <url>/2024/11/26/%E5%BE%B7%E8%AF%AD%E5%AD%A6%E4%B9%A0%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB%E4%BC%9A/</url>
    
    <content type="html"><![CDATA[<h1>德语学习经验分享会</h1><p><em>2024.11.26</em></p><h2 id="1-王羽芃">1. 王羽芃</h2><h2 id="德语学习进度">德语学习进度</h2><p>大一上 A1</p><p>大一下 A2</p><p>期中考试后B1</p><p>大二上B1-B2</p><p>大二下TestDaF冲刺</p><h2 id="听说读写能力">听说读写能力</h2><h3 id="语法：">语法：</h3><p>A1 -A2：多积累和巩固语法知识</p><h3 id="A2结业考试之后：词汇量">A2结业考试之后：词汇量</h3><p>多联系各个不同的词，词义相近的词</p><p>词有很多前缀，比如sprechen，去搞懂每个前缀对应的含义</p><p>不用记很多很多，重在记得牢、记得精</p><p>掌握单词在语境中的用法</p><p>一位20分学长：一页纸只记两、三个单词，但是一整页都是这个单词在语境中的应用</p><p>多积累固定搭配、积累可分动词</p><h3 id="语感的培养">语感的培养</h3><p>拿到阅读、听力的原文：朗读出来，积累语感</p><h2 id="德福考试">德福考试</h2><h4 id="Test-Deutsch-als-Fremdsprache">Test Deutsch als Fremdsprache</h4><p>3月易、7月难、11月中</p><p>阅读部分：3篇，60min</p><p>作文：60min，给一个图表，描述+讨论问题</p><h2 id="2-殷江民">2.殷江民</h2><h2 id="大一的德语学习">大一的德语学习</h2><h3 id="1-培养语感">1. 培养语感</h3><p>说起来怎么样？听起来怎么样？写起来怎么样？</p><p>放开声读文章，对口型念单词</p><h3 id="2-训练基本功">2.训练基本功</h3><p>基本的词汇、格位、时态、造句</p><h3 id="3-和英语区分开">3.和英语区分开</h3><p>专心学德语，不过有能力还是可以两种语言一起学</p><p>考过四级、大二大三把六级考过去</p><h2 id="大二的德语学习">大二的德语学习</h2><h3 id="1-节奏更快">1.节奏更快</h3><p>需要打好语感和基本功基础</p><h3 id="2-尽量下半学期寒假一过就考一次德福">2. 尽量下半学期寒假一过就考一次德福</h3><h3 id="3-在2的基础上好好听下半学期的德福考试技巧，这样在7月的德福考试可以更从容一点">3. 在2的基础上好好听下半学期的德福考试技巧，这样在7月的德福考试可以更从容一点</h3><h2 id="听力">听力</h2><p>德语初级听力 外语教学与研究出版社，刷刷刷</p><h2 id="阅读">阅读</h2><h3 id="1-新求精的小短文认真读，利用好上课的时间，跟着老师把文中的知识点读透">1.新求精的小短文认真读，利用好上课的时间，跟着老师把文中的知识点读透</h3><h3 id="2-自己课下抽空出声朗读培养语感">2.自己课下抽空出声朗读培养语感</h3><h3 id="3-德福的阅读要刷题-技巧，但是这个听老师讲述的方法就完全够用">3.德福的阅读要刷题+技巧，但是这个听老师讲述的方法就完全够用</h3><h2 id="写作">写作</h2><h3 id="1-大一的写作类似记叙文">1.大一的写作类似记叙文</h3><p>地点、美食、哪里好玩、课余时间喜欢干什么</p><h3 id="2-老师上课的现场练习要认真对待">2.老师上课的现场练习要认真对待</h3><p>积极让老师批改寻找优化点、仔细阅读范文、多背诵</p><h2 id="口语">口语</h2><h3 id="1-大一主要以生活的话题有关：">1.大一主要以生活的话题有关：</h3><p>课余生活、美食、方位，主要是以自己干的事情为主，实事求是为主</p><p>练习方法：</p><ol><li><p>大声朗读课文</p></li><li><p>自己写一段德语日记、描述做了些什么，然后自己默背、潜移默化地就能用德语说了</p></li></ol><h2 id="自测">自测</h2><p>找A1\A2的卷子</p>]]></content>
    
    
    <categories>
      
      <category>德语</category>
      
    </categories>
    
    
    <tags>
      
      <tag>德语</tag>
      
      <tag>经验分享</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数学公式测试</title>
    <link href="/1970/01/02/%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E6%B5%8B%E8%AF%95/"/>
    <url>/1970/01/02/%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<p>这是一个行内公式：$E = mc^2$。</p><p>这是一个块级公式：<br>$$<br>\int_{-\infty}^{\infty} e^{-x^2} dx = \sqrt{\pi}<br>$$</p>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>测试文章</title>
    <link href="/1970/01/01/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/"/>
    <url>/1970/01/01/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<p>这是一篇测试文章</p><p><img src="/img/test.png" alt="test"></p><h1>文本</h1><p>这是一段正文内容样式，以下是不同文本样式效果： <a href="https://github.com/cayxc/mdmdt">这是超链接样式: https://github.com/cayxc/mdmdt</a>,  <strong>这是加粗文本样式</strong>,  <em>这是斜体字样式</em>,  <code>This is a single line code style</code>,  <u>这是下划线样式</u>,  <s>这是删除线效果样式</s>,  ==这是文字高亮效果==，这是上下标样式: $\LaTeX$, X^2^, H~2~O,  <span style='background:var(--color-2-0-c)'> 这是鼠标选中效果 </span>, 这是键盘键样式：<kbd>Command+Q</kbd>, 这是数学公式： $$ u(t,x,y) = \frac{1}{2\pi c} \frac{\part}{\part t} \iint\limits_{r&lt;ct} \frac{m^2(m+n)}{\sqrt{c^2t^2 -r^2 }}dmdn $$,  这些是图标：🐳 😀 🇨🇳</p><p>This is a text content style and the following are the effects of different text styles: <strong>This is a bold text style</strong>, <a href="https://github.com/cayxc/mdmdt">This is a hyperlink style: https://github.com/cayxc/mdmdt</a>,  <code>This is a single line code style</code>,  <u>This is the underline style</u>, ==This is the text highlighting effect==,  <s>This is the strikethrough effect style</s>,  <em>This is the italic font style</em>, This is the subscript style: $\LaTeX$, X^2^, H~2~O,  This is the keyboard key style: <kbd>Command+Q</kbd>,  <span style='background:var(--color-2-0-c)'>This is the mouse selection effect</span>, This is a mathematical formula: $$ u(t,x,y) = \frac{1}{2\pi c} \frac{\part}{\part t} \iint\limits_{r&lt;ct} \frac{m^2(m+n)}{\sqrt{c^2t^2 -r^2 }}dmdn $$​,  These are icons: 🐳 😀 🇨🇳</p><!-- 这是注释内容......, This is the annotation content --><h1>列表</h1><p>这些是列表样式效果:</p><ol><li>这是有序列表 A</li><li>这是有序列表 B</li></ol><ul><li>This is Item 1.</li><li>This is Item 2.</li><li>[x] Something is Not TODO.</li><li>[ ] Something is DONE.</li></ul><hr><ol><li>这是有序列表 A</li><li>这是有序列表 B<ol><li>这是有序列表 A</li><li>这是有序列表 B</li></ol></li></ol><ul><li>This is Item 1.</li><li>This is Item 2.<ul><li>This is Item 1.</li><li>This is Item 2.</li></ul></li></ul><hr><p>这是嵌套列表样式：</p><ol><li>这是有序列表 A</li><li>这是有序列表 B<ul><li>This is Item 1.</li><li>This is Item 2.<ul><li>[x] Something is Not TODO.</li><li>[ ] Something is DONE.</li></ul></li></ul></li></ol><ul><li>这是有序列表 A</li><li>这是有序列表 B<ol><li>This is Item 1.</li><li>This is Item 2.<ul><li>[ ] Something is Not TODO.</li><li>[x] Something is DONE.</li></ul></li></ol></li></ul><h1>代码</h1><p>单行代码样式：<code>composer require --dev barryvdh/laravel-ide-helper</code></p><p>大段代码块样式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * ----------------------------------------</span><br><span class="hljs-comment">  * 设置递增的 level 编号</span><br><span class="hljs-comment">  * ----------------------------------------</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@param</span> tag obj 标签对象</span><br><span class="hljs-comment">  *</span><br><span class="hljs-comment">  */</span><br> <span class="hljs-title function_">setLevelNumber</span> (tag) &#123;<br>   <span class="hljs-keyword">try</span> &#123;<br>     <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">typeof</span> tag) != <span class="hljs-string">&#x27;object&#x27;</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-string">&#x27;setLevelNumber() 调用时参数类型错误，必须是一个h标签的对象集合！&#x27;</span>;<br>     &#125;<br>     <span class="hljs-keyword">let</span> str = tag.<span class="hljs-property">id</span>;<br>     <span class="hljs-keyword">if</span> (str.<span class="hljs-property">lastIndexOf</span> (<span class="hljs-string">&#x27;.&#x27;</span>) == - <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">//如果是一级目录形式 level-1000</span><br>        <span class="hljs-keyword">let</span> newValue = <span class="hljs-built_in">parseInt</span> (str.<span class="hljs-property">slice</span> (<span class="hljs-number">6</span>))+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;level-&#x27;</span>+newValue;<br>     &#125;<br>   &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>      <span class="hljs-keyword">return</span> err;<br>   &#125;<br> &#125;<br></code></pre></td></tr></table></figure><h1>表格样式</h1><table><thead><tr><th style="text-align:left">Left-Aligned</th><th style="text-align:center">Center Aligned</th><th style="text-align:right">Right Aligned</th></tr></thead><tbody><tr><td style="text-align:left">This is the first line</td><td style="text-align:center"><code>this is code</code> some wordy text and some code</td><td style="text-align:right">$160</td></tr><tr><td style="text-align:left">This is the second line</td><td style="text-align:center">some code: <code>this is code</code> centered</td><td style="text-align:right">$1200.99</td></tr><tr><td style="text-align:left">This is the third line</td><td style="text-align:center">These are some texts</td><td style="text-align:right">$125.5</td></tr></tbody></table><h1>引用文本框</h1><blockquote><p>[!NOTE]</p><p>This is a Note text box … <code>this is code style</code></p><blockquote><p>This is a Note text box …</p></blockquote></blockquote><blockquote><p>[!TIP]</p><p>This is a Tip text box …</p></blockquote><blockquote><p>[!IMPORTANT]</p><p>This is a Important text box …</p></blockquote><blockquote><p>[!WARNING]</p><p>This is a Warning text box …</p></blockquote><blockquote><p>[!CAUTION]</p><p>This is a Caution text box …</p></blockquote><h1>一级标题1</h1><h2 id="二级标题2">二级标题2</h2><h3 id="三级标题3">三级标题3</h3><h4 id="四级标题4">四级标题4</h4><h5 id="五级标题5">五级标题5</h5><h6 id="六级标题6">六级标题6</h6>]]></content>
    
    
    <categories>
      
      <category>test</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
